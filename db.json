{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1562057278369},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1562057278369},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1562057278369},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1562057278370},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1562057278370},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1562057278375},{"_id":"source/.DS_Store","hash":"7b677ded122b99db487d52aef200ac608c5cf3ec","modified":1562121118106},{"_id":"source/_posts/cell_高度自适应.md","hash":"8d20d447221502c540f8cd57c6298210f5de6d0e","modified":1562057278368},{"_id":"source/_posts/lldb.md","hash":"637f861701fac6adec9f74374dde098c8c7a50dd","modified":1562057278368},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562121085011},{"_id":"source/to-dos/KIF.md","hash":"dab7fd162ec60cf374b7440f2d9fdb509cb3a40f","modified":1562057278367},{"_id":"source/to-dos/Runtime.md","hash":"882381909d57a7b8f94c9b9b7f2bad741cc11049","modified":1562062333801},{"_id":"source/to-dos/cfrunloop.md","hash":"08ce2ce2de1ab64d799b39611bbcd00c422b9267","modified":1562057278368},{"_id":"source/to-dos/concurrency_programming_guide.md","hash":"a508c9ff9c55161b4aba0985958d12cf20c59b6b","modified":1562057278368},{"_id":"source/to-dos/归档序列化变成指南.md","hash":"42c26ed084d125928fa5139776724a59a9e28f0d","modified":1562057278369},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1562057278370},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1562057278370},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1562057278370},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1562057278370},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1562057278371},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1562057278371},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1562057278371},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1562057278374},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1562057278374},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1562057278374},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1562057278375},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1562057278375},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1562057278375},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1562057278375},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1562057278375},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1562057278371},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1562057278371},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1562057278371},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1562057278371},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1562057278373},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1562057278373},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1562057278373},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1562057278374},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1562057278374},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1562057278374},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1562057278375},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1562057278377},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1562057278382},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1562057278383},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1562057278383},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1562057278383},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1562057278383},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1562057278383},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1562057278385},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1562057278385},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1562057278386},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1562057278386},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1562057278372},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1562057278373},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1562057278373},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1562057278373},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1562057278373},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1562057278373},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1562057278376},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1562057278377},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1562057278377},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1562057278377},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1562057278377},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1562057278377},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1562057278378},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1562057278378},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1562057278381},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1562057278384},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1562057278385},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1562057278381},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1562057278379},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1562057278382},{"_id":"public/to-dos/KIF.html","hash":"ae7407387676042ecd381e411997556116f29b00","modified":1562121135839},{"_id":"public/to-dos/cfrunloop.html","hash":"fb71e7c82c22acf636d5641c78db852615f4ff54","modified":1562121135839},{"_id":"public/to-dos/concurrency_programming_guide.html","hash":"72a85353fff5733ee61736d012f2560f9c10f9ee","modified":1562121135840},{"_id":"public/2019/07/02/cell_高度自适应/index.html","hash":"71717b34100500f632f19afcb5db773fa3e75900","modified":1562121135840},{"_id":"public/2019/07/02/lldb/index.html","hash":"9b7ad372a32d07d0e27dc4484168bd8acdf8862f","modified":1562121135840},{"_id":"public/archives/index.html","hash":"20c825c5ad5b287a3ad789a705b59eb19e5820ab","modified":1562121135840},{"_id":"public/archives/2019/index.html","hash":"80b2631504e1a39f584453d4d33ca0997dba229e","modified":1562121135840},{"_id":"public/archives/2019/07/index.html","hash":"bbca85e3a817362dad82cd279881e6b1e3b50b4a","modified":1562121135840},{"_id":"public/index.html","hash":"9ac4749100571867ec4c6520a83ed52aacc189c3","modified":1562121135840},{"_id":"public/to-dos/归档序列化变成指南.html","hash":"9ba77e9671cd00766a453036904d183625e2918f","modified":1562121135840},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1562121135841},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1562121135841},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1562121135842},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1562121135842},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1562121135842},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1562121135842},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1562121135842},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1562121135842},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1562121135842},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1562121135842},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1562121136127},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1562121136128},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1562121136128},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1562121136128},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1562121136128},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1562121136128},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1562121136128},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1562121136128},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1562121136129},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1562121136129},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1562121136129},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1562121136130},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1562121136130}],"Category":[],"Data":[],"Page":[{"_content":"# KIF 文档\n  \n>  **原文地址：**[https://github.com/kif-framework/KIF](https://github.com/kif-framework/KIF).  \n>  **KIF文档地址：**[http://cocoadocs.org/docsets/KIF/2.0.0/index.html](http://cocoadocs.org/docsets/KIF/2.0.0/index.html)\n<!-- more -->\n\n## 1.KIF介绍\n* 关键类： **KIFTestCase**是**XCTestCase**的子类、**KIFUITestActor**\n* 主要方法：     \n\n```  \ncase类: beforeEach, afterEach, testXXXX;\nactor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,\n在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;\nswitch: setOn: forSwitchWithAccessibilityLabel:  \n```\t\t    \n\n## 2.KIF集成（使用cocoapods）\n\n* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  \n* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  \n* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  \n* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成  \n\n```\ntarget 'Acceptance Tests', :exclusive => true do \npod 'KIF', '~> 3.0', :configurations => ['Debug']  \nend\n```  \n\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target->Build Phases->Target Dependencies，点+，选中响应target；  \n* Build Setting->Linking->Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting->Testing->Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###\t使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?\t\n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`\t\n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n\n","source":"to-dos/KIF.md","raw":"# KIF 文档\n  \n>  **原文地址：**[https://github.com/kif-framework/KIF](https://github.com/kif-framework/KIF).  \n>  **KIF文档地址：**[http://cocoadocs.org/docsets/KIF/2.0.0/index.html](http://cocoadocs.org/docsets/KIF/2.0.0/index.html)\n<!-- more -->\n\n## 1.KIF介绍\n* 关键类： **KIFTestCase**是**XCTestCase**的子类、**KIFUITestActor**\n* 主要方法：     \n\n```  \ncase类: beforeEach, afterEach, testXXXX;\nactor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,\n在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;\nswitch: setOn: forSwitchWithAccessibilityLabel:  \n```\t\t    \n\n## 2.KIF集成（使用cocoapods）\n\n* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  \n* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  \n* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  \n* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成  \n\n```\ntarget 'Acceptance Tests', :exclusive => true do \npod 'KIF', '~> 3.0', :configurations => ['Debug']  \nend\n```  \n\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target->Build Phases->Target Dependencies，点+，选中响应target；  \n* Build Setting->Linking->Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting->Testing->Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###\t使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?\t\n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`\t\n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n\n","date":"2019-07-03T02:31:58.124Z","updated":"2019-07-02T08:47:58.367Z","path":"to-dos/KIF.html","title":"","comments":1,"layout":"page","_id":"cjxmmlac50000iixpeltpoc37","content":"<h1 id=\"KIF-文档\"><a href=\"#KIF-文档\" class=\"headerlink\" title=\"KIF 文档\"></a>KIF 文档</h1><blockquote>\n<p> <strong>原文地址：</strong><a href=\"https://github.com/kif-framework/KIF\" target=\"_blank\" rel=\"noopener\">https://github.com/kif-framework/KIF</a>.<br> <strong>KIF文档地址：</strong><a href=\"http://cocoadocs.org/docsets/KIF/2.0.0/index.html\" target=\"_blank\" rel=\"noopener\">http://cocoadocs.org/docsets/KIF/2.0.0/index.html</a></p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"1-KIF介绍\"><a href=\"#1-KIF介绍\" class=\"headerlink\" title=\"1.KIF介绍\"></a>1.KIF介绍</h2><ul>\n<li>关键类： <strong>KIFTestCase</strong>是<strong>XCTestCase</strong>的子类、<strong>KIFUITestActor</strong></li>\n<li>主要方法：     </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case类: beforeEach, afterEach, testXXXX;</span><br><span class=\"line\">actor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,</span><br><span class=\"line\">在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;</span><br><span class=\"line\">switch: setOn: forSwitchWithAccessibilityLabel:  </span><br><span class=\"line\">```\t\t    </span><br><span class=\"line\"></span><br><span class=\"line\">## 2.KIF集成（使用cocoapods）</span><br><span class=\"line\"></span><br><span class=\"line\">* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  </span><br><span class=\"line\">* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  </span><br><span class=\"line\">* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  </span><br><span class=\"line\">* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成</span><br></pre></td></tr></table></figure>\n\n<p>target ‘Acceptance Tests’, :exclusive =&gt; true do<br>pod ‘KIF’, ‘~&gt; 3.0’, :configurations =&gt; [‘Debug’]<br>end</p>\n<pre><code>\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target-&gt;Build Phases-&gt;Target Dependencies，点+，选中响应target；  \n* Build Setting-&gt;Linking-&gt;Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting-&gt;Testing-&gt;Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###    使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?    \n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`    \n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"KIF-文档\"><a href=\"#KIF-文档\" class=\"headerlink\" title=\"KIF 文档\"></a>KIF 文档</h1><blockquote>\n<p> <strong>原文地址：</strong><a href=\"https://github.com/kif-framework/KIF\" target=\"_blank\" rel=\"noopener\">https://github.com/kif-framework/KIF</a>.<br> <strong>KIF文档地址：</strong><a href=\"http://cocoadocs.org/docsets/KIF/2.0.0/index.html\" target=\"_blank\" rel=\"noopener\">http://cocoadocs.org/docsets/KIF/2.0.0/index.html</a></p>\n</blockquote>","more":"<h2 id=\"1-KIF介绍\"><a href=\"#1-KIF介绍\" class=\"headerlink\" title=\"1.KIF介绍\"></a>1.KIF介绍</h2><ul>\n<li>关键类： <strong>KIFTestCase</strong>是<strong>XCTestCase</strong>的子类、<strong>KIFUITestActor</strong></li>\n<li>主要方法：     </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case类: beforeEach, afterEach, testXXXX;</span><br><span class=\"line\">actor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,</span><br><span class=\"line\">在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;</span><br><span class=\"line\">switch: setOn: forSwitchWithAccessibilityLabel:  </span><br><span class=\"line\">```\t\t    </span><br><span class=\"line\"></span><br><span class=\"line\">## 2.KIF集成（使用cocoapods）</span><br><span class=\"line\"></span><br><span class=\"line\">* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  </span><br><span class=\"line\">* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  </span><br><span class=\"line\">* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  </span><br><span class=\"line\">* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成</span><br></pre></td></tr></table></figure>\n\n<p>target ‘Acceptance Tests’, :exclusive =&gt; true do<br>pod ‘KIF’, ‘~&gt; 3.0’, :configurations =&gt; [‘Debug’]<br>end</p>\n<pre><code>\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target-&gt;Build Phases-&gt;Target Dependencies，点+，选中响应target；  \n* Build Setting-&gt;Linking-&gt;Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting-&gt;Testing-&gt;Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###    使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?    \n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`    \n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n</code></pre>"},{"_content":"# CFRunLoop\n\n名词：Core Foundation, run loop, `sources`, `timers` 和 `observers`\nneed process:\t需要处理\t\ncallout:\t\t调出\n\n`run loop` 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。\n<!-- more -->\t\n`run loop`监听三种类型的对象：`sources`, `timer`, `observers`。通过**CFRunLoopAddSource**, **CFRunLoopAddTimer**, 或者** CFRunLoopAddObserver**方法把这些对象加入到 `run loop` 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 `run loop` 中移除。  \n每个添加到 `run loop` 中的 `source`, `time`, `observer`都必须关联一个或多个` run loop` 模式。模式决定了一个迭代中需要处理什么事件。`run loop` 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 `sources`, `timers` 和 `observers`。大多数的 `source` 都会被添加到 `run loop` 的默认模式中--这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 `run loop` 从而限制哪些已经处理的`sources`, `timers` 和 `observers`。因为 `run loop` 模式都是指定为字符串，你可以自定义模式限制事件的处理。\t\n\n`Core Foundation` 定义了一个特殊的模式:**common modes**,你可以关联多个具有**共同指定**的 `sources`, `timers` 和 `observers`的模式。当配置一个对象的时候，使用'kCFRunLoopCommonModes'来指定为common modes。每个run loop都有他自己的common modes，**默认模式总是包含在其中**。用'CFRunLoopAddCommonMode'往集合中添加模式。\t\n每个线程都必定有一个 `run loop`。你不能创建和销毁一个线程的`run loop`。需要的时候`Core Foundation`会自动为你创建。使用 `CFRunLoopGetCurrent` 获取当前线程的 `run loop`。调用 `CFRunLoopRun` 使当前线程 `run loop` 运行在默认的模式直到调用 `CFRunLoopStop` 停止。你也可以调用 `CFRunLoopRunInMode` 使当前 `run loop` 运行在指定的模式一段时间（或者当 `run loop` 被停止）。一个模式只会当请求的模式有至少一个 `source` 或者 timer to monitor。\t\nrun loop可以递归运行。你可以在任意run loop的调出中调用'CFRunLoopRun or CFRunLoopRunInMode'，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。\t\n\nCocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。\n\n\n\n## AFN\n### GET\n不管是哪种请求方式，内部都调用\t\n\n\tHTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:\t\n\n通过这个方法创建'NSMutableURLRequst'对象，再调用\n\n\tHTTPRequestOperationWithRequest:success:failure:failure\n\t\nrequestSerializer\t\n\n\n\n# 自动释放池\n对象什么时候释放？  \n`observer`\t两次睡眠之间释放\n\n# 引用策略\nCore Foundation\n\n用于'Core Foundation'对象\t\t\n\nCore Foundation的函数命名非常友好。\t\n\n*\t函数名字中包含**Create**或者**Copy**，你就持有这个对象；如果包含**Get**，那就没有持有对象。","source":"to-dos/cfrunloop.md","raw":"# CFRunLoop\n\n名词：Core Foundation, run loop, `sources`, `timers` 和 `observers`\nneed process:\t需要处理\t\ncallout:\t\t调出\n\n`run loop` 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。\n<!-- more -->\t\n`run loop`监听三种类型的对象：`sources`, `timer`, `observers`。通过**CFRunLoopAddSource**, **CFRunLoopAddTimer**, 或者** CFRunLoopAddObserver**方法把这些对象加入到 `run loop` 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 `run loop` 中移除。  \n每个添加到 `run loop` 中的 `source`, `time`, `observer`都必须关联一个或多个` run loop` 模式。模式决定了一个迭代中需要处理什么事件。`run loop` 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 `sources`, `timers` 和 `observers`。大多数的 `source` 都会被添加到 `run loop` 的默认模式中--这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 `run loop` 从而限制哪些已经处理的`sources`, `timers` 和 `observers`。因为 `run loop` 模式都是指定为字符串，你可以自定义模式限制事件的处理。\t\n\n`Core Foundation` 定义了一个特殊的模式:**common modes**,你可以关联多个具有**共同指定**的 `sources`, `timers` 和 `observers`的模式。当配置一个对象的时候，使用'kCFRunLoopCommonModes'来指定为common modes。每个run loop都有他自己的common modes，**默认模式总是包含在其中**。用'CFRunLoopAddCommonMode'往集合中添加模式。\t\n每个线程都必定有一个 `run loop`。你不能创建和销毁一个线程的`run loop`。需要的时候`Core Foundation`会自动为你创建。使用 `CFRunLoopGetCurrent` 获取当前线程的 `run loop`。调用 `CFRunLoopRun` 使当前线程 `run loop` 运行在默认的模式直到调用 `CFRunLoopStop` 停止。你也可以调用 `CFRunLoopRunInMode` 使当前 `run loop` 运行在指定的模式一段时间（或者当 `run loop` 被停止）。一个模式只会当请求的模式有至少一个 `source` 或者 timer to monitor。\t\nrun loop可以递归运行。你可以在任意run loop的调出中调用'CFRunLoopRun or CFRunLoopRunInMode'，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。\t\n\nCocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。\n\n\n\n## AFN\n### GET\n不管是哪种请求方式，内部都调用\t\n\n\tHTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:\t\n\n通过这个方法创建'NSMutableURLRequst'对象，再调用\n\n\tHTTPRequestOperationWithRequest:success:failure:failure\n\t\nrequestSerializer\t\n\n\n\n# 自动释放池\n对象什么时候释放？  \n`observer`\t两次睡眠之间释放\n\n# 引用策略\nCore Foundation\n\n用于'Core Foundation'对象\t\t\n\nCore Foundation的函数命名非常友好。\t\n\n*\t函数名字中包含**Create**或者**Copy**，你就持有这个对象；如果包含**Get**，那就没有持有对象。","date":"2019-07-03T02:31:58.118Z","updated":"2019-07-02T08:47:58.368Z","path":"to-dos/cfrunloop.html","title":"","comments":1,"layout":"page","_id":"cjxmmlaca0002iixp4xu8tjrh","content":"<h1 id=\"CFRunLoop\"><a href=\"#CFRunLoop\" class=\"headerlink\" title=\"CFRunLoop\"></a>CFRunLoop</h1><p>名词：Core Foundation, run loop, <code>sources</code>, <code>timers</code> 和 <code>observers</code><br>need process:    需要处理<br>callout:        调出</p>\n<p><code>run loop</code> 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。</p>\n<a id=\"more\"></a>    \n<p><code>run loop</code>监听三种类型的对象：<code>sources</code>, <code>timer</code>, <code>observers</code>。通过<strong>CFRunLoopAddSource</strong>, <strong>CFRunLoopAddTimer</strong>, 或者** CFRunLoopAddObserver**方法把这些对象加入到 <code>run loop</code> 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 <code>run loop</code> 中移除。<br>每个添加到 <code>run loop</code> 中的 <code>source</code>, <code>time</code>, <code>observer</code>都必须关联一个或多个<code>run loop</code> 模式。模式决定了一个迭代中需要处理什么事件。<code>run loop</code> 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>。大多数的 <code>source</code> 都会被添加到 <code>run loop</code> 的默认模式中–这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 <code>run loop</code> 从而限制哪些已经处理的<code>sources</code>, <code>timers</code> 和 <code>observers</code>。因为 <code>run loop</code> 模式都是指定为字符串，你可以自定义模式限制事件的处理。    </p>\n<p><code>Core Foundation</code> 定义了一个特殊的模式:<strong>common modes</strong>,你可以关联多个具有<strong>共同指定</strong>的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>的模式。当配置一个对象的时候，使用’kCFRunLoopCommonModes’来指定为common modes。每个run loop都有他自己的common modes，<strong>默认模式总是包含在其中</strong>。用’CFRunLoopAddCommonMode’往集合中添加模式。<br>每个线程都必定有一个 <code>run loop</code>。你不能创建和销毁一个线程的<code>run loop</code>。需要的时候<code>Core Foundation</code>会自动为你创建。使用 <code>CFRunLoopGetCurrent</code> 获取当前线程的 <code>run loop</code>。调用 <code>CFRunLoopRun</code> 使当前线程 <code>run loop</code> 运行在默认的模式直到调用 <code>CFRunLoopStop</code> 停止。你也可以调用 <code>CFRunLoopRunInMode</code> 使当前 <code>run loop</code> 运行在指定的模式一段时间（或者当 <code>run loop</code> 被停止）。一个模式只会当请求的模式有至少一个 <code>source</code> 或者 timer to monitor。<br>run loop可以递归运行。你可以在任意run loop的调出中调用’CFRunLoopRun or CFRunLoopRunInMode’，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。    </p>\n<p>Cocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。</p>\n<h2 id=\"AFN\"><a href=\"#AFN\" class=\"headerlink\" title=\"AFN\"></a>AFN</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>不管是哪种请求方式，内部都调用    </p>\n<pre><code>HTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:    </code></pre><p>通过这个方法创建’NSMutableURLRequst’对象，再调用</p>\n<pre><code>HTTPRequestOperationWithRequest:success:failure:failure</code></pre><p>requestSerializer    </p>\n<h1 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h1><p>对象什么时候释放？<br><code>observer</code>    两次睡眠之间释放</p>\n<h1 id=\"引用策略\"><a href=\"#引用策略\" class=\"headerlink\" title=\"引用策略\"></a>引用策略</h1><p>Core Foundation</p>\n<p>用于’Core Foundation’对象        </p>\n<p>Core Foundation的函数命名非常友好。    </p>\n<ul>\n<li>函数名字中包含<strong>Create</strong>或者<strong>Copy</strong>，你就持有这个对象；如果包含<strong>Get</strong>，那就没有持有对象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"CFRunLoop\"><a href=\"#CFRunLoop\" class=\"headerlink\" title=\"CFRunLoop\"></a>CFRunLoop</h1><p>名词：Core Foundation, run loop, <code>sources</code>, <code>timers</code> 和 <code>observers</code><br>need process:    需要处理<br>callout:        调出</p>\n<p><code>run loop</code> 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。</p>","more":"<p><code>run loop</code>监听三种类型的对象：<code>sources</code>, <code>timer</code>, <code>observers</code>。通过<strong>CFRunLoopAddSource</strong>, <strong>CFRunLoopAddTimer</strong>, 或者** CFRunLoopAddObserver**方法把这些对象加入到 <code>run loop</code> 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 <code>run loop</code> 中移除。<br>每个添加到 <code>run loop</code> 中的 <code>source</code>, <code>time</code>, <code>observer</code>都必须关联一个或多个<code>run loop</code> 模式。模式决定了一个迭代中需要处理什么事件。<code>run loop</code> 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>。大多数的 <code>source</code> 都会被添加到 <code>run loop</code> 的默认模式中–这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 <code>run loop</code> 从而限制哪些已经处理的<code>sources</code>, <code>timers</code> 和 <code>observers</code>。因为 <code>run loop</code> 模式都是指定为字符串，你可以自定义模式限制事件的处理。    </p>\n<p><code>Core Foundation</code> 定义了一个特殊的模式:<strong>common modes</strong>,你可以关联多个具有<strong>共同指定</strong>的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>的模式。当配置一个对象的时候，使用’kCFRunLoopCommonModes’来指定为common modes。每个run loop都有他自己的common modes，<strong>默认模式总是包含在其中</strong>。用’CFRunLoopAddCommonMode’往集合中添加模式。<br>每个线程都必定有一个 <code>run loop</code>。你不能创建和销毁一个线程的<code>run loop</code>。需要的时候<code>Core Foundation</code>会自动为你创建。使用 <code>CFRunLoopGetCurrent</code> 获取当前线程的 <code>run loop</code>。调用 <code>CFRunLoopRun</code> 使当前线程 <code>run loop</code> 运行在默认的模式直到调用 <code>CFRunLoopStop</code> 停止。你也可以调用 <code>CFRunLoopRunInMode</code> 使当前 <code>run loop</code> 运行在指定的模式一段时间（或者当 <code>run loop</code> 被停止）。一个模式只会当请求的模式有至少一个 <code>source</code> 或者 timer to monitor。<br>run loop可以递归运行。你可以在任意run loop的调出中调用’CFRunLoopRun or CFRunLoopRunInMode’，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。    </p>\n<p>Cocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。</p>\n<h2 id=\"AFN\"><a href=\"#AFN\" class=\"headerlink\" title=\"AFN\"></a>AFN</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>不管是哪种请求方式，内部都调用    </p>\n<pre><code>HTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:    </code></pre><p>通过这个方法创建’NSMutableURLRequst’对象，再调用</p>\n<pre><code>HTTPRequestOperationWithRequest:success:failure:failure</code></pre><p>requestSerializer    </p>\n<h1 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h1><p>对象什么时候释放？<br><code>observer</code>    两次睡眠之间释放</p>\n<h1 id=\"引用策略\"><a href=\"#引用策略\" class=\"headerlink\" title=\"引用策略\"></a>引用策略</h1><p>Core Foundation</p>\n<p>用于’Core Foundation’对象        </p>\n<p>Core Foundation的函数命名非常友好。    </p>\n<ul>\n<li>函数名字中包含<strong>Create</strong>或者<strong>Copy</strong>，你就持有这个对象；如果包含<strong>Get</strong>，那就没有持有对象。</li>\n</ul>"},{"_content":"# 并发编程指南\n\n为了提高 `CPU` 计算能力，增加芯片核心数，为了让应用更充分利用 `CPU`，应用使用多线程\n\n\n## 操作队列\n\n*\tNSOperation 基类\n\n通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 `GCD` );\n如果不加到操作队列，可以直接调用 `start`。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 `start` 就会发出异常。\n<!-- more -->\n\n**依赖**\t\t\n设置依赖是一个很方便的确定操作执行顺序的方法。`addDependency:`,`removeDependency:`。只有依赖执行完了，这个操作才能进入就绪状态。\t\n不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，\n由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。\n\n**键值观察属性**\t\t\nisCancelled - read-only\t\t\nisAsynchronous - read-only\t\nisExecuting - read-only\t\t\nisFinished - read-only\t\t\nisReady - read-only\t\t\ndependencies - read-only\t\nqueuePriority - readable and writable\t\ncompletionBlock - readable and writable\t\t\n虽然可以讲观察者绑定在这些属性，但不应该和**视图**元素绑定，因为关于视图的代码要在**主线程**执行，操作可以在任何线程执行，和这些操作绑定的 `KVO` 通知也会在任何线程执行。\n\n**多线程注意**\t\t\n`NSOperation` 子类，实现一些 `accessors`，要注意线程同步。\n\n**异步VS同步**\n\n**方法重写**\n不并发的操作，只需要重写 `main`，可能有数据，如果实现了`settter`, `getter`，要保证线程安全;并发的操作，至少实现这些方法或属性 `start`, `asynchronous`, `executing`, `finished`。\n`start`负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 `executing` 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;\n\n**cancel命令**\t\n`cancel` 不会立即强行停止操作。所有的操作都认可 `cancelled` 属性，你可以在代码中判断。**NOTE**:一个线程是否被加入到队列中决定了 `cancel` 的行为。未加入，这个方法会将操作标记成**已完成**；已加入，将操作标记成**就绪**，并立刻调 `start`,然后退出，操作从队列中清楚。\t\n主要代码要周期性地检查 `cancelled` 属性。实现 `start` 方法，应该早点检查是否取消然后再决定怎么做。\t\n\n**执行operation**\t\t\n`start`: 更新执行状态，并调用 `main`；手动执行操作才调用这个方法。\t\n`main`: 实现这个方法，不要调 `super`。自动执行在 `NSOperation` 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。\t\t\n`cancel`: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。\n如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 `start`，并将它移出队列。\n\n*\tNSBlockOperation\t\n\n一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。\t\n添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。\t\t\n操作正在执行或已经执行结束的时候调用`addExecutionBlock:`会抛出异常。\n\n初始化至少添加一个代码块。当要执行一个`NSBlockOperation`时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，\n\n*\tNSInvocationOperation\n\n管理一个方法封装的单个任务。这个类实习了一个非并发的操作。\n\n```\n- (instancetype)initWithTarget:(id)target\n                      selector:(SEL)sel\n                        object:(id)arg   \nsel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。\n                  \n```\n\n`- (instancetype)initWithInvocation:(NSInvocation *)inv`, `inv` 会对他的参数引用计数加一。\n可以通过查看 `result` 属性，看是否有异常。\n\n使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。\n\n\n**自定义操作**\t\n自定义非并行操作只需要响应`主任务`和`取消`；并行操作则需要重写更多代码。\n\n---\t\n无论什么操作，都要在创建之后，添加到队列中之前，进行配置。\t\n多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。\t\n**优先级**\t\n添加到队列中的操作的执行顺序，**首先**是根据操作的就绪状态；**然后**是根据优先级。\t\n通过 `setQueuePriority:` 改变优先级。\t\n优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。\t\n\n如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。\n\n**执行**\t\n通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。\n\n** 重要 **\t\t\n不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。\n\n虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(`setMaxConcurrentOperationCount:`)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 `GCD` 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。\n\n** 手动执行 **\t\n手动执行要确保操作处于就绪状态，并且调用 `start`。`start` 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。\t\n如果定义了一个并发的操作，应该最开始判断 `isConcurrent`，如果返回 `NO`，确保能决定是否重开一条线程。\n\n\n## 分发队列\n\n## 分发源","source":"to-dos/concurrency_programming_guide.md","raw":"# 并发编程指南\n\n为了提高 `CPU` 计算能力，增加芯片核心数，为了让应用更充分利用 `CPU`，应用使用多线程\n\n\n## 操作队列\n\n*\tNSOperation 基类\n\n通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 `GCD` );\n如果不加到操作队列，可以直接调用 `start`。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 `start` 就会发出异常。\n<!-- more -->\n\n**依赖**\t\t\n设置依赖是一个很方便的确定操作执行顺序的方法。`addDependency:`,`removeDependency:`。只有依赖执行完了，这个操作才能进入就绪状态。\t\n不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，\n由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。\n\n**键值观察属性**\t\t\nisCancelled - read-only\t\t\nisAsynchronous - read-only\t\nisExecuting - read-only\t\t\nisFinished - read-only\t\t\nisReady - read-only\t\t\ndependencies - read-only\t\nqueuePriority - readable and writable\t\ncompletionBlock - readable and writable\t\t\n虽然可以讲观察者绑定在这些属性，但不应该和**视图**元素绑定，因为关于视图的代码要在**主线程**执行，操作可以在任何线程执行，和这些操作绑定的 `KVO` 通知也会在任何线程执行。\n\n**多线程注意**\t\t\n`NSOperation` 子类，实现一些 `accessors`，要注意线程同步。\n\n**异步VS同步**\n\n**方法重写**\n不并发的操作，只需要重写 `main`，可能有数据，如果实现了`settter`, `getter`，要保证线程安全;并发的操作，至少实现这些方法或属性 `start`, `asynchronous`, `executing`, `finished`。\n`start`负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 `executing` 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;\n\n**cancel命令**\t\n`cancel` 不会立即强行停止操作。所有的操作都认可 `cancelled` 属性，你可以在代码中判断。**NOTE**:一个线程是否被加入到队列中决定了 `cancel` 的行为。未加入，这个方法会将操作标记成**已完成**；已加入，将操作标记成**就绪**，并立刻调 `start`,然后退出，操作从队列中清楚。\t\n主要代码要周期性地检查 `cancelled` 属性。实现 `start` 方法，应该早点检查是否取消然后再决定怎么做。\t\n\n**执行operation**\t\t\n`start`: 更新执行状态，并调用 `main`；手动执行操作才调用这个方法。\t\n`main`: 实现这个方法，不要调 `super`。自动执行在 `NSOperation` 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。\t\t\n`cancel`: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。\n如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 `start`，并将它移出队列。\n\n*\tNSBlockOperation\t\n\n一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。\t\n添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。\t\t\n操作正在执行或已经执行结束的时候调用`addExecutionBlock:`会抛出异常。\n\n初始化至少添加一个代码块。当要执行一个`NSBlockOperation`时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，\n\n*\tNSInvocationOperation\n\n管理一个方法封装的单个任务。这个类实习了一个非并发的操作。\n\n```\n- (instancetype)initWithTarget:(id)target\n                      selector:(SEL)sel\n                        object:(id)arg   \nsel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。\n                  \n```\n\n`- (instancetype)initWithInvocation:(NSInvocation *)inv`, `inv` 会对他的参数引用计数加一。\n可以通过查看 `result` 属性，看是否有异常。\n\n使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。\n\n\n**自定义操作**\t\n自定义非并行操作只需要响应`主任务`和`取消`；并行操作则需要重写更多代码。\n\n---\t\n无论什么操作，都要在创建之后，添加到队列中之前，进行配置。\t\n多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。\t\n**优先级**\t\n添加到队列中的操作的执行顺序，**首先**是根据操作的就绪状态；**然后**是根据优先级。\t\n通过 `setQueuePriority:` 改变优先级。\t\n优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。\t\n\n如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。\n\n**执行**\t\n通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。\n\n** 重要 **\t\t\n不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。\n\n虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(`setMaxConcurrentOperationCount:`)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 `GCD` 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。\n\n** 手动执行 **\t\n手动执行要确保操作处于就绪状态，并且调用 `start`。`start` 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。\t\n如果定义了一个并发的操作，应该最开始判断 `isConcurrent`，如果返回 `NO`，确保能决定是否重开一条线程。\n\n\n## 分发队列\n\n## 分发源","date":"2019-07-03T02:31:58.122Z","updated":"2019-07-02T08:47:58.368Z","path":"to-dos/concurrency_programming_guide.html","title":"","comments":1,"layout":"page","_id":"cjxmmlacb0004iixp4uke9lxw","content":"<h1 id=\"并发编程指南\"><a href=\"#并发编程指南\" class=\"headerlink\" title=\"并发编程指南\"></a>并发编程指南</h1><p>为了提高 <code>CPU</code> 计算能力，增加芯片核心数，为了让应用更充分利用 <code>CPU</code>，应用使用多线程</p>\n<h2 id=\"操作队列\"><a href=\"#操作队列\" class=\"headerlink\" title=\"操作队列\"></a>操作队列</h2><ul>\n<li>NSOperation 基类</li>\n</ul>\n<p>通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 <code>GCD</code> );<br>如果不加到操作队列，可以直接调用 <code>start</code>。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 <code>start</code> 就会发出异常。</p>\n<a id=\"more\"></a>\n\n<p><strong>依赖</strong><br>设置依赖是一个很方便的确定操作执行顺序的方法。<code>addDependency:</code>,<code>removeDependency:</code>。只有依赖执行完了，这个操作才能进入就绪状态。<br>不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，<br>由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。</p>\n<p><strong>键值观察属性</strong><br>isCancelled - read-only<br>isAsynchronous - read-only<br>isExecuting - read-only<br>isFinished - read-only<br>isReady - read-only<br>dependencies - read-only<br>queuePriority - readable and writable<br>completionBlock - readable and writable<br>虽然可以讲观察者绑定在这些属性，但不应该和<strong>视图</strong>元素绑定，因为关于视图的代码要在<strong>主线程</strong>执行，操作可以在任何线程执行，和这些操作绑定的 <code>KVO</code> 通知也会在任何线程执行。</p>\n<p><strong>多线程注意</strong><br><code>NSOperation</code> 子类，实现一些 <code>accessors</code>，要注意线程同步。</p>\n<p><strong>异步VS同步</strong></p>\n<p><strong>方法重写</strong><br>不并发的操作，只需要重写 <code>main</code>，可能有数据，如果实现了<code>settter</code>, <code>getter</code>，要保证线程安全;并发的操作，至少实现这些方法或属性 <code>start</code>, <code>asynchronous</code>, <code>executing</code>, <code>finished</code>。<br><code>start</code>负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 <code>executing</code> 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;</p>\n<p><strong>cancel命令</strong><br><code>cancel</code> 不会立即强行停止操作。所有的操作都认可 <code>cancelled</code> 属性，你可以在代码中判断。<strong>NOTE</strong>:一个线程是否被加入到队列中决定了 <code>cancel</code> 的行为。未加入，这个方法会将操作标记成<strong>已完成</strong>；已加入，将操作标记成<strong>就绪</strong>，并立刻调 <code>start</code>,然后退出，操作从队列中清楚。<br>主要代码要周期性地检查 <code>cancelled</code> 属性。实现 <code>start</code> 方法，应该早点检查是否取消然后再决定怎么做。    </p>\n<p><strong>执行operation</strong><br><code>start</code>: 更新执行状态，并调用 <code>main</code>；手动执行操作才调用这个方法。<br><code>main</code>: 实现这个方法，不要调 <code>super</code>。自动执行在 <code>NSOperation</code> 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。<br><code>cancel</code>: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。<br>如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 <code>start</code>，并将它移出队列。</p>\n<ul>\n<li>NSBlockOperation    </li>\n</ul>\n<p>一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。<br>添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。<br>操作正在执行或已经执行结束的时候调用<code>addExecutionBlock:</code>会抛出异常。</p>\n<p>初始化至少添加一个代码块。当要执行一个<code>NSBlockOperation</code>时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，</p>\n<ul>\n<li>NSInvocationOperation</li>\n</ul>\n<p>管理一个方法封装的单个任务。这个类实习了一个非并发的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithTarget:(id)target</span><br><span class=\"line\">                      selector:(SEL)sel</span><br><span class=\"line\">                        object:(id)arg   </span><br><span class=\"line\">sel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。</span><br></pre></td></tr></table></figure>\n\n<p><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code>, <code>inv</code> 会对他的参数引用计数加一。<br>可以通过查看 <code>result</code> 属性，看是否有异常。</p>\n<p>使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。</p>\n<p><strong>自定义操作</strong><br>自定义非并行操作只需要响应<code>主任务</code>和<code>取消</code>；并行操作则需要重写更多代码。</p>\n<hr>\n<p>无论什么操作，都要在创建之后，添加到队列中之前，进行配置。<br>多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。<br><strong>优先级</strong><br>添加到队列中的操作的执行顺序，<strong>首先</strong>是根据操作的就绪状态；<strong>然后</strong>是根据优先级。<br>通过 <code>setQueuePriority:</code> 改变优先级。<br>优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。    </p>\n<p>如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。</p>\n<p><strong>执行</strong><br>通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。</p>\n<p>** 重要 **<br>不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。</p>\n<p>虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(<code>setMaxConcurrentOperationCount:</code>)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 <code>GCD</code> 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。</p>\n<p>** 手动执行 **<br>手动执行要确保操作处于就绪状态，并且调用 <code>start</code>。<code>start</code> 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。<br>如果定义了一个并发的操作，应该最开始判断 <code>isConcurrent</code>，如果返回 <code>NO</code>，确保能决定是否重开一条线程。</p>\n<h2 id=\"分发队列\"><a href=\"#分发队列\" class=\"headerlink\" title=\"分发队列\"></a>分发队列</h2><h2 id=\"分发源\"><a href=\"#分发源\" class=\"headerlink\" title=\"分发源\"></a>分发源</h2>","site":{"data":{}},"excerpt":"<h1 id=\"并发编程指南\"><a href=\"#并发编程指南\" class=\"headerlink\" title=\"并发编程指南\"></a>并发编程指南</h1><p>为了提高 <code>CPU</code> 计算能力，增加芯片核心数，为了让应用更充分利用 <code>CPU</code>，应用使用多线程</p>\n<h2 id=\"操作队列\"><a href=\"#操作队列\" class=\"headerlink\" title=\"操作队列\"></a>操作队列</h2><ul>\n<li>NSOperation 基类</li>\n</ul>\n<p>通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 <code>GCD</code> );<br>如果不加到操作队列，可以直接调用 <code>start</code>。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 <code>start</code> 就会发出异常。</p>","more":"<p><strong>依赖</strong><br>设置依赖是一个很方便的确定操作执行顺序的方法。<code>addDependency:</code>,<code>removeDependency:</code>。只有依赖执行完了，这个操作才能进入就绪状态。<br>不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，<br>由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。</p>\n<p><strong>键值观察属性</strong><br>isCancelled - read-only<br>isAsynchronous - read-only<br>isExecuting - read-only<br>isFinished - read-only<br>isReady - read-only<br>dependencies - read-only<br>queuePriority - readable and writable<br>completionBlock - readable and writable<br>虽然可以讲观察者绑定在这些属性，但不应该和<strong>视图</strong>元素绑定，因为关于视图的代码要在<strong>主线程</strong>执行，操作可以在任何线程执行，和这些操作绑定的 <code>KVO</code> 通知也会在任何线程执行。</p>\n<p><strong>多线程注意</strong><br><code>NSOperation</code> 子类，实现一些 <code>accessors</code>，要注意线程同步。</p>\n<p><strong>异步VS同步</strong></p>\n<p><strong>方法重写</strong><br>不并发的操作，只需要重写 <code>main</code>，可能有数据，如果实现了<code>settter</code>, <code>getter</code>，要保证线程安全;并发的操作，至少实现这些方法或属性 <code>start</code>, <code>asynchronous</code>, <code>executing</code>, <code>finished</code>。<br><code>start</code>负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 <code>executing</code> 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;</p>\n<p><strong>cancel命令</strong><br><code>cancel</code> 不会立即强行停止操作。所有的操作都认可 <code>cancelled</code> 属性，你可以在代码中判断。<strong>NOTE</strong>:一个线程是否被加入到队列中决定了 <code>cancel</code> 的行为。未加入，这个方法会将操作标记成<strong>已完成</strong>；已加入，将操作标记成<strong>就绪</strong>，并立刻调 <code>start</code>,然后退出，操作从队列中清楚。<br>主要代码要周期性地检查 <code>cancelled</code> 属性。实现 <code>start</code> 方法，应该早点检查是否取消然后再决定怎么做。    </p>\n<p><strong>执行operation</strong><br><code>start</code>: 更新执行状态，并调用 <code>main</code>；手动执行操作才调用这个方法。<br><code>main</code>: 实现这个方法，不要调 <code>super</code>。自动执行在 <code>NSOperation</code> 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。<br><code>cancel</code>: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。<br>如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 <code>start</code>，并将它移出队列。</p>\n<ul>\n<li>NSBlockOperation    </li>\n</ul>\n<p>一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。<br>添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。<br>操作正在执行或已经执行结束的时候调用<code>addExecutionBlock:</code>会抛出异常。</p>\n<p>初始化至少添加一个代码块。当要执行一个<code>NSBlockOperation</code>时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，</p>\n<ul>\n<li>NSInvocationOperation</li>\n</ul>\n<p>管理一个方法封装的单个任务。这个类实习了一个非并发的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithTarget:(id)target</span><br><span class=\"line\">                      selector:(SEL)sel</span><br><span class=\"line\">                        object:(id)arg   </span><br><span class=\"line\">sel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。</span><br></pre></td></tr></table></figure>\n\n<p><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code>, <code>inv</code> 会对他的参数引用计数加一。<br>可以通过查看 <code>result</code> 属性，看是否有异常。</p>\n<p>使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。</p>\n<p><strong>自定义操作</strong><br>自定义非并行操作只需要响应<code>主任务</code>和<code>取消</code>；并行操作则需要重写更多代码。</p>\n<hr>\n<p>无论什么操作，都要在创建之后，添加到队列中之前，进行配置。<br>多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。<br><strong>优先级</strong><br>添加到队列中的操作的执行顺序，<strong>首先</strong>是根据操作的就绪状态；<strong>然后</strong>是根据优先级。<br>通过 <code>setQueuePriority:</code> 改变优先级。<br>优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。    </p>\n<p>如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。</p>\n<p><strong>执行</strong><br>通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。</p>\n<p>** 重要 **<br>不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。</p>\n<p>虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(<code>setMaxConcurrentOperationCount:</code>)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 <code>GCD</code> 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。</p>\n<p>** 手动执行 **<br>手动执行要确保操作处于就绪状态，并且调用 <code>start</code>。<code>start</code> 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。<br>如果定义了一个并发的操作，应该最开始判断 <code>isConcurrent</code>，如果返回 <code>NO</code>，确保能决定是否重开一条线程。</p>\n<h2 id=\"分发队列\"><a href=\"#分发队列\" class=\"headerlink\" title=\"分发队列\"></a>分发队列</h2><h2 id=\"分发源\"><a href=\"#分发源\" class=\"headerlink\" title=\"分发源\"></a>分发源</h2>"},{"_content":"# 归档(Archive)\n\n归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。  \n支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：`union`, `void *`, 函数指针, 长链表的指针。\t\n归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: [异常情况](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072)。  \n<!-- more -->\n\n## 编码对象\n对象要通过**编码对象**写入或读取归档。编码对象是 `NSCoder(抽象类)` 之类的实例。 `NSCoder` 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。  \n编码对象通过适当的方法编解码。归档：发送 `encodeWithCoder:` 给对象，解档：发送 `initWithCoder:`。只有遵循了 `NSCoding` 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 `OC` 值的类型的标识以及在层级结构中的位置。\t\n为了解决冗余和约束的问题，引入根对象和条件对象。\t\n\n### 根对象\n两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。  \n解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。  \n`NSCoder` 不会实现对根对象的支持；`NSCoder` 的 `encodeRootObject:` 实现，通过调用 `encodeObject:` 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。\t\n### 条件对象\n有些对象图不适合完全编码。比如某个视图引用了非常多对象（`window`, `target`），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。  \n条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 `encodeConditionalObject:forKey:` 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。  \n`NSCoder` 不实现对条件对象的支持；`NSCoder` 的 `encodeConditionalObject:forKey:` 实现，通过调用 `encodeObject:forKey:` 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。\t\n\n## 有键的归档\n有键归档是通过 `NSKeyedArchiver` 对象创建，`NSKeyedUnarchiver` 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。\t\n\n### 值命名\n对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。\t\n对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。  \n避免使用`$`。\t\n子类也要一定程度上当心前缀的使用，避免和父类冲突。\n\n### 键缺失情况下的返回值\n解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（`nil for objects`, `NO for booleans`, `0.0 for reals`, `NSZeroSize for sizes`等等）。可以用 `containsValueForKey:` 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。\n\n### 类型强制转换\n`NSKeyedUnarchiver` 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。[NSRangeException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException)。此外，浮点整形互转会抛异常[NSInvalidUnarchiveOperationException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException)。\t\n\n### 类版本控制\n### 代理\n`NSKeyedArchiver`, `NSKeyedUnarchiver`都有代理。\n### 无键的编码方法\n可以使用没有没有键的编码，但不提倡。\n\n# 创建以及提取归档\n## 创建归档对象\n被编码对象要遵循 `NSCoding` 协议，实现协议方法：\n\n```\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];\n        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];\n        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];\n    }\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];\n    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];\n    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];\n}\n```\n归档操作:\t\n\n```\nPerson* aPerson = [Person new];\naPerson.name = @\"Kai\";\naPerson.age = 24;\naPerson.gender = @\"male\";\n    \nNSMutableData* data = [[NSMutableData alloc] init];\nNSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];\n[archiver encodeObject:aPerson forKey:personKey];\n[archiver finishEncoding];\n    \nNSString* path = [self pathForArchive];\nBOOL result = [data writeToFile:path atomically:YES];\n```\n解档操作:\n\n```\nNSData* data = [NSData dataWithContentsOfFile:path];\n    \nNSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];\nid obj = [unarchiver decodeObjectForKey:personKey];\n[unarchiver finishDecoding];\n```\n# 编解码对象\n## 编码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。\n\n## 解码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。\n\n### 注意事项\n编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。  \n不需要的项不要将其写出。\t\n尽量不要使用 `containsValueForKey:` ，除非要区分空值的默认值和真实值相同的情况。  \n加速解码比加速编码更有意义。\t\n避免使用`$`。\n\n## 编码期间使用替换\n\n# 序列化属性列表\n`NSPropertyListSerialization`","source":"to-dos/归档序列化变成指南.md","raw":"# 归档(Archive)\n\n归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。  \n支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：`union`, `void *`, 函数指针, 长链表的指针。\t\n归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: [异常情况](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072)。  \n<!-- more -->\n\n## 编码对象\n对象要通过**编码对象**写入或读取归档。编码对象是 `NSCoder(抽象类)` 之类的实例。 `NSCoder` 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。  \n编码对象通过适当的方法编解码。归档：发送 `encodeWithCoder:` 给对象，解档：发送 `initWithCoder:`。只有遵循了 `NSCoding` 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 `OC` 值的类型的标识以及在层级结构中的位置。\t\n为了解决冗余和约束的问题，引入根对象和条件对象。\t\n\n### 根对象\n两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。  \n解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。  \n`NSCoder` 不会实现对根对象的支持；`NSCoder` 的 `encodeRootObject:` 实现，通过调用 `encodeObject:` 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。\t\n### 条件对象\n有些对象图不适合完全编码。比如某个视图引用了非常多对象（`window`, `target`），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。  \n条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 `encodeConditionalObject:forKey:` 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。  \n`NSCoder` 不实现对条件对象的支持；`NSCoder` 的 `encodeConditionalObject:forKey:` 实现，通过调用 `encodeObject:forKey:` 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。\t\n\n## 有键的归档\n有键归档是通过 `NSKeyedArchiver` 对象创建，`NSKeyedUnarchiver` 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。\t\n\n### 值命名\n对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。\t\n对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。  \n避免使用`$`。\t\n子类也要一定程度上当心前缀的使用，避免和父类冲突。\n\n### 键缺失情况下的返回值\n解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（`nil for objects`, `NO for booleans`, `0.0 for reals`, `NSZeroSize for sizes`等等）。可以用 `containsValueForKey:` 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。\n\n### 类型强制转换\n`NSKeyedUnarchiver` 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。[NSRangeException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException)。此外，浮点整形互转会抛异常[NSInvalidUnarchiveOperationException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException)。\t\n\n### 类版本控制\n### 代理\n`NSKeyedArchiver`, `NSKeyedUnarchiver`都有代理。\n### 无键的编码方法\n可以使用没有没有键的编码，但不提倡。\n\n# 创建以及提取归档\n## 创建归档对象\n被编码对象要遵循 `NSCoding` 协议，实现协议方法：\n\n```\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];\n        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];\n        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];\n    }\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];\n    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];\n    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];\n}\n```\n归档操作:\t\n\n```\nPerson* aPerson = [Person new];\naPerson.name = @\"Kai\";\naPerson.age = 24;\naPerson.gender = @\"male\";\n    \nNSMutableData* data = [[NSMutableData alloc] init];\nNSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];\n[archiver encodeObject:aPerson forKey:personKey];\n[archiver finishEncoding];\n    \nNSString* path = [self pathForArchive];\nBOOL result = [data writeToFile:path atomically:YES];\n```\n解档操作:\n\n```\nNSData* data = [NSData dataWithContentsOfFile:path];\n    \nNSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];\nid obj = [unarchiver decodeObjectForKey:personKey];\n[unarchiver finishDecoding];\n```\n# 编解码对象\n## 编码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。\n\n## 解码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。\n\n### 注意事项\n编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。  \n不需要的项不要将其写出。\t\n尽量不要使用 `containsValueForKey:` ，除非要区分空值的默认值和真实值相同的情况。  \n加速解码比加速编码更有意义。\t\n避免使用`$`。\n\n## 编码期间使用替换\n\n# 序列化属性列表\n`NSPropertyListSerialization`","date":"2019-07-03T02:31:58.127Z","updated":"2019-07-02T08:47:58.369Z","path":"to-dos/归档序列化变成指南.html","title":"","comments":1,"layout":"page","_id":"cjxmmlacc0005iixp4cz8dlf1","content":"<h1 id=\"归档-Archive\"><a href=\"#归档-Archive\" class=\"headerlink\" title=\"归档(Archive)\"></a>归档(Archive)</h1><p>归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。<br>支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：<code>union</code>, <code>void *</code>, 函数指针, 长链表的指针。<br>归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: <a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072\" target=\"_blank\" rel=\"noopener\">异常情况</a>。  </p>\n<a id=\"more\"></a>\n\n<h2 id=\"编码对象\"><a href=\"#编码对象\" class=\"headerlink\" title=\"编码对象\"></a>编码对象</h2><p>对象要通过<strong>编码对象</strong>写入或读取归档。编码对象是 <code>NSCoder(抽象类)</code> 之类的实例。 <code>NSCoder</code> 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。<br>编码对象通过适当的方法编解码。归档：发送 <code>encodeWithCoder:</code> 给对象，解档：发送 <code>initWithCoder:</code>。只有遵循了 <code>NSCoding</code> 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 <code>OC</code> 值的类型的标识以及在层级结构中的位置。<br>为了解决冗余和约束的问题，引入根对象和条件对象。    </p>\n<h3 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h3><p>两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。<br>解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。<br><code>NSCoder</code> 不会实现对根对象的支持；<code>NSCoder</code> 的 <code>encodeRootObject:</code> 实现，通过调用 <code>encodeObject:</code> 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。    </p>\n<h3 id=\"条件对象\"><a href=\"#条件对象\" class=\"headerlink\" title=\"条件对象\"></a>条件对象</h3><p>有些对象图不适合完全编码。比如某个视图引用了非常多对象（<code>window</code>, <code>target</code>），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。<br>条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 <code>encodeConditionalObject:forKey:</code> 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。<br><code>NSCoder</code> 不实现对条件对象的支持；<code>NSCoder</code> 的 <code>encodeConditionalObject:forKey:</code> 实现，通过调用 <code>encodeObject:forKey:</code> 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。    </p>\n<h2 id=\"有键的归档\"><a href=\"#有键的归档\" class=\"headerlink\" title=\"有键的归档\"></a>有键的归档</h2><p>有键归档是通过 <code>NSKeyedArchiver</code> 对象创建，<code>NSKeyedUnarchiver</code> 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。    </p>\n<h3 id=\"值命名\"><a href=\"#值命名\" class=\"headerlink\" title=\"值命名\"></a>值命名</h3><p>对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。<br>对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。<br>避免使用<code>$</code>。<br>子类也要一定程度上当心前缀的使用，避免和父类冲突。</p>\n<h3 id=\"键缺失情况下的返回值\"><a href=\"#键缺失情况下的返回值\" class=\"headerlink\" title=\"键缺失情况下的返回值\"></a>键缺失情况下的返回值</h3><p>解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（<code>nil for objects</code>, <code>NO for booleans</code>, <code>0.0 for reals</code>, <code>NSZeroSize for sizes</code>等等）。可以用 <code>containsValueForKey:</code> 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。</p>\n<h3 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h3><p><code>NSKeyedUnarchiver</code> 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException\" target=\"_blank\" rel=\"noopener\">NSRangeException</a>。此外，浮点整形互转会抛异常<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException\" target=\"_blank\" rel=\"noopener\">NSInvalidUnarchiveOperationException</a>。    </p>\n<h3 id=\"类版本控制\"><a href=\"#类版本控制\" class=\"headerlink\" title=\"类版本控制\"></a>类版本控制</h3><h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p><code>NSKeyedArchiver</code>, <code>NSKeyedUnarchiver</code>都有代理。</p>\n<h3 id=\"无键的编码方法\"><a href=\"#无键的编码方法\" class=\"headerlink\" title=\"无键的编码方法\"></a>无键的编码方法</h3><p>可以使用没有没有键的编码，但不提倡。</p>\n<h1 id=\"创建以及提取归档\"><a href=\"#创建以及提取归档\" class=\"headerlink\" title=\"创建以及提取归档\"></a>创建以及提取归档</h1><h2 id=\"创建归档对象\"><a href=\"#创建归档对象\" class=\"headerlink\" title=\"创建归档对象\"></a>创建归档对象</h2><p>被编码对象要遵循 <code>NSCoding</code> 协议，实现协议方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class=\"line\">    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>归档操作:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* aPerson = [Person new];</span><br><span class=\"line\">aPerson.name = @&quot;Kai&quot;;</span><br><span class=\"line\">aPerson.age = 24;</span><br><span class=\"line\">aPerson.gender = @&quot;male&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">NSMutableData* data = [[NSMutableData alloc] init];</span><br><span class=\"line\">NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class=\"line\">[archiver encodeObject:aPerson forKey:personKey];</span><br><span class=\"line\">[archiver finishEncoding];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSString* path = [self pathForArchive];</span><br><span class=\"line\">BOOL result = [data writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>\n\n<p>解档操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData* data = [NSData dataWithContentsOfFile:path];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class=\"line\">id obj = [unarchiver decodeObjectForKey:personKey];</span><br><span class=\"line\">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"编解码对象\"><a href=\"#编解码对象\" class=\"headerlink\" title=\"编解码对象\"></a>编解码对象</h1><h2 id=\"编码一个对象\"><a href=\"#编码一个对象\" class=\"headerlink\" title=\"编码一个对象\"></a>编码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。</p>\n<h2 id=\"解码一个对象\"><a href=\"#解码一个对象\" class=\"headerlink\" title=\"解码一个对象\"></a>解码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。<br>不需要的项不要将其写出。<br>尽量不要使用 <code>containsValueForKey:</code> ，除非要区分空值的默认值和真实值相同的情况。<br>加速解码比加速编码更有意义。<br>避免使用<code>$</code>。</p>\n<h2 id=\"编码期间使用替换\"><a href=\"#编码期间使用替换\" class=\"headerlink\" title=\"编码期间使用替换\"></a>编码期间使用替换</h2><h1 id=\"序列化属性列表\"><a href=\"#序列化属性列表\" class=\"headerlink\" title=\"序列化属性列表\"></a>序列化属性列表</h1><p><code>NSPropertyListSerialization</code></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"归档-Archive\"><a href=\"#归档-Archive\" class=\"headerlink\" title=\"归档(Archive)\"></a>归档(Archive)</h1><p>归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。<br>支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：<code>union</code>, <code>void *</code>, 函数指针, 长链表的指针。<br>归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: <a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072\" target=\"_blank\" rel=\"noopener\">异常情况</a>。  </p>","more":"<h2 id=\"编码对象\"><a href=\"#编码对象\" class=\"headerlink\" title=\"编码对象\"></a>编码对象</h2><p>对象要通过<strong>编码对象</strong>写入或读取归档。编码对象是 <code>NSCoder(抽象类)</code> 之类的实例。 <code>NSCoder</code> 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。<br>编码对象通过适当的方法编解码。归档：发送 <code>encodeWithCoder:</code> 给对象，解档：发送 <code>initWithCoder:</code>。只有遵循了 <code>NSCoding</code> 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 <code>OC</code> 值的类型的标识以及在层级结构中的位置。<br>为了解决冗余和约束的问题，引入根对象和条件对象。    </p>\n<h3 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h3><p>两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。<br>解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。<br><code>NSCoder</code> 不会实现对根对象的支持；<code>NSCoder</code> 的 <code>encodeRootObject:</code> 实现，通过调用 <code>encodeObject:</code> 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。    </p>\n<h3 id=\"条件对象\"><a href=\"#条件对象\" class=\"headerlink\" title=\"条件对象\"></a>条件对象</h3><p>有些对象图不适合完全编码。比如某个视图引用了非常多对象（<code>window</code>, <code>target</code>），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。<br>条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 <code>encodeConditionalObject:forKey:</code> 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。<br><code>NSCoder</code> 不实现对条件对象的支持；<code>NSCoder</code> 的 <code>encodeConditionalObject:forKey:</code> 实现，通过调用 <code>encodeObject:forKey:</code> 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。    </p>\n<h2 id=\"有键的归档\"><a href=\"#有键的归档\" class=\"headerlink\" title=\"有键的归档\"></a>有键的归档</h2><p>有键归档是通过 <code>NSKeyedArchiver</code> 对象创建，<code>NSKeyedUnarchiver</code> 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。    </p>\n<h3 id=\"值命名\"><a href=\"#值命名\" class=\"headerlink\" title=\"值命名\"></a>值命名</h3><p>对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。<br>对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。<br>避免使用<code>$</code>。<br>子类也要一定程度上当心前缀的使用，避免和父类冲突。</p>\n<h3 id=\"键缺失情况下的返回值\"><a href=\"#键缺失情况下的返回值\" class=\"headerlink\" title=\"键缺失情况下的返回值\"></a>键缺失情况下的返回值</h3><p>解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（<code>nil for objects</code>, <code>NO for booleans</code>, <code>0.0 for reals</code>, <code>NSZeroSize for sizes</code>等等）。可以用 <code>containsValueForKey:</code> 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。</p>\n<h3 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h3><p><code>NSKeyedUnarchiver</code> 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException\" target=\"_blank\" rel=\"noopener\">NSRangeException</a>。此外，浮点整形互转会抛异常<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException\" target=\"_blank\" rel=\"noopener\">NSInvalidUnarchiveOperationException</a>。    </p>\n<h3 id=\"类版本控制\"><a href=\"#类版本控制\" class=\"headerlink\" title=\"类版本控制\"></a>类版本控制</h3><h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p><code>NSKeyedArchiver</code>, <code>NSKeyedUnarchiver</code>都有代理。</p>\n<h3 id=\"无键的编码方法\"><a href=\"#无键的编码方法\" class=\"headerlink\" title=\"无键的编码方法\"></a>无键的编码方法</h3><p>可以使用没有没有键的编码，但不提倡。</p>\n<h1 id=\"创建以及提取归档\"><a href=\"#创建以及提取归档\" class=\"headerlink\" title=\"创建以及提取归档\"></a>创建以及提取归档</h1><h2 id=\"创建归档对象\"><a href=\"#创建归档对象\" class=\"headerlink\" title=\"创建归档对象\"></a>创建归档对象</h2><p>被编码对象要遵循 <code>NSCoding</code> 协议，实现协议方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class=\"line\">    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>归档操作:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* aPerson = [Person new];</span><br><span class=\"line\">aPerson.name = @&quot;Kai&quot;;</span><br><span class=\"line\">aPerson.age = 24;</span><br><span class=\"line\">aPerson.gender = @&quot;male&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">NSMutableData* data = [[NSMutableData alloc] init];</span><br><span class=\"line\">NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class=\"line\">[archiver encodeObject:aPerson forKey:personKey];</span><br><span class=\"line\">[archiver finishEncoding];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSString* path = [self pathForArchive];</span><br><span class=\"line\">BOOL result = [data writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>\n\n<p>解档操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData* data = [NSData dataWithContentsOfFile:path];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class=\"line\">id obj = [unarchiver decodeObjectForKey:personKey];</span><br><span class=\"line\">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"编解码对象\"><a href=\"#编解码对象\" class=\"headerlink\" title=\"编解码对象\"></a>编解码对象</h1><h2 id=\"编码一个对象\"><a href=\"#编码一个对象\" class=\"headerlink\" title=\"编码一个对象\"></a>编码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。</p>\n<h2 id=\"解码一个对象\"><a href=\"#解码一个对象\" class=\"headerlink\" title=\"解码一个对象\"></a>解码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。<br>不需要的项不要将其写出。<br>尽量不要使用 <code>containsValueForKey:</code> ，除非要区分空值的默认值和真实值相同的情况。<br>加速解码比加速编码更有意义。<br>避免使用<code>$</code>。</p>\n<h2 id=\"编码期间使用替换\"><a href=\"#编码期间使用替换\" class=\"headerlink\" title=\"编码期间使用替换\"></a>编码期间使用替换</h2><h1 id=\"序列化属性列表\"><a href=\"#序列化属性列表\" class=\"headerlink\" title=\"序列化属性列表\"></a>序列化属性列表</h1><p><code>NSPropertyListSerialization</code></p>"}],"Post":[{"_content":"# cell 高度自适应\n  \n参考文章：[Raywenderich](https://www.raywenderlich.com/129059/self-sizing-table-view-cells)  \n  \n*\t 通过约束布局 `cell` 的子视图，子视图对 `cell` 的四个方向都需要建立约束；\n*\t `tableview` 要设置属性 `rowHeight`, `estimateRowHeight`\n\n```\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 380;\n```\nSo Easy!!","source":"_posts/cell_高度自适应.md","raw":"# cell 高度自适应\n  \n参考文章：[Raywenderich](https://www.raywenderlich.com/129059/self-sizing-table-view-cells)  \n  \n*\t 通过约束布局 `cell` 的子视图，子视图对 `cell` 的四个方向都需要建立约束；\n*\t `tableview` 要设置属性 `rowHeight`, `estimateRowHeight`\n\n```\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 380;\n```\nSo Easy!!","slug":"cell_高度自适应","published":1,"date":"2019-07-02T08:47:58.368Z","updated":"2019-07-02T08:47:58.368Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxmmlac60001iixpvigxw3ct","content":"<h1 id=\"cell-高度自适应\"><a href=\"#cell-高度自适应\" class=\"headerlink\" title=\"cell 高度自适应\"></a>cell 高度自适应</h1><p>参考文章：<a href=\"https://www.raywenderlich.com/129059/self-sizing-table-view-cells\" target=\"_blank\" rel=\"noopener\">Raywenderich</a>  </p>\n<ul>\n<li>通过约束布局 <code>cell</code> 的子视图，子视图对 <code>cell</code> 的四个方向都需要建立约束；</li>\n<li><code>tableview</code> 要设置属性 <code>rowHeight</code>, <code>estimateRowHeight</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</span><br><span class=\"line\">self.tableView.estimatedRowHeight = 380;</span><br></pre></td></tr></table></figure>\n\n<p>So Easy!!</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"cell-高度自适应\"><a href=\"#cell-高度自适应\" class=\"headerlink\" title=\"cell 高度自适应\"></a>cell 高度自适应</h1><p>参考文章：<a href=\"https://www.raywenderlich.com/129059/self-sizing-table-view-cells\" target=\"_blank\" rel=\"noopener\">Raywenderich</a>  </p>\n<ul>\n<li>通过约束布局 <code>cell</code> 的子视图，子视图对 <code>cell</code> 的四个方向都需要建立约束；</li>\n<li><code>tableview</code> 要设置属性 <code>rowHeight</code>, <code>estimateRowHeight</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</span><br><span class=\"line\">self.tableView.estimatedRowHeight = 380;</span><br></pre></td></tr></table></figure>\n\n<p>So Easy!!</p>\n"},{"_content":"# LLDB\t\n2016年8月30日 下午5:49\n\n## 打印\n`help`  \n`p(print)`用于打印，\t\t\n`e(expression)`，修改程序运行时的值\t\t\n`p` == `e --`\t\n`po(print object)`\t\n\n`p/<fmt>`,按照格式打印\t  \n`p/x`(16进制)   \n`p/t`(2进制)\n<!-- more -->  \n\n## 变量\nLLDB可以声明变量，不过都要以`$`开头。\n\t\n```\n(lldb) e int $a = 2\n(lldb) p $a * 19\n38\n(lldb) e NSArray *$array = @[ @\"Saturday\", @\"Sunday\", @\"Monday\" ]\n(lldb) p [$array count]\n2\n(lldb) po [[$array objectAtIndex:0] uppercaseString]\nSATURDAY\n```\n返回值类型无法确定的情况，需要声明:\n\n```\n(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n'M'\n(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n77\n```\n\n## 程序流程\n*\t`c(process continue)`,继续执行\n*\t`n(next step)`,下一步\n*\t`s(step in)`,进入函数\n*\t`thread return <value>`,使用场景：刚进入一个函数，直接模拟返回。\n\n## 断点\n### 管理断点\n*\t`breakpoint(br) list`,断点列表\n*\t`breakpoint enable`,允许断点\n*\t`breakpoint disable`,禁止断点\n\n### 创建断点\n这个方法创建的断点不会显示在界面上，下次重新运行就没了。\n\n*\t`br set -f <filename> -l <line>`\t缩写：`br <filename>:<line>`，某文件的某行加断点\n*\t`br set -F <functionname>`，某个函数加断点\n\n### 断点行为\naction 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。\t\n## 更新UI\n渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。\n\n```\n(lldb) e id $myView = (id)0x7fe3ed101bd0\n(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]\n(lldb) e (void)[CATransaction flush]\n```\n\n## 寻找按钮的action\n```\n(lldb) po [$myButton allTargets]\n{(\n    <MagicEventListener: 0x7fb58bd2e240>\n)}\n(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]\n<__NSArrayM 0x7fb58bd2aa40>(\n_handleTap:\n)\n```\n\n## 寻址\n`image lookup --address <address>`\n\n## 常见问题\n*\t不明类型或者类型不匹配\t\nerror: 'NSLog' has unknown return type; cast the call to its declared return type\t\nerror: 1 errors parsing expression\t\t\n\n需要显示声明类型。\t\t\nlldb是不支持宏的。\n\n*\t找不到方法\t\t\nerror: unsupported expression with unknown type\t\t\nerror: unsupported expression with unknown type\t\t\nerror: 2 errors parsing expression\t\n\t\nLLDB无法通过点语法访问属性，尝试适当改写是否可以通过。\n\n*\tExecution was interrupted\t\nerror: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).\t\t\nThe process has been returned to the state before expression evaluation.\t\t\n\n可能需要显示声明类型。","source":"_posts/lldb.md","raw":"# LLDB\t\n2016年8月30日 下午5:49\n\n## 打印\n`help`  \n`p(print)`用于打印，\t\t\n`e(expression)`，修改程序运行时的值\t\t\n`p` == `e --`\t\n`po(print object)`\t\n\n`p/<fmt>`,按照格式打印\t  \n`p/x`(16进制)   \n`p/t`(2进制)\n<!-- more -->  \n\n## 变量\nLLDB可以声明变量，不过都要以`$`开头。\n\t\n```\n(lldb) e int $a = 2\n(lldb) p $a * 19\n38\n(lldb) e NSArray *$array = @[ @\"Saturday\", @\"Sunday\", @\"Monday\" ]\n(lldb) p [$array count]\n2\n(lldb) po [[$array objectAtIndex:0] uppercaseString]\nSATURDAY\n```\n返回值类型无法确定的情况，需要声明:\n\n```\n(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n'M'\n(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n77\n```\n\n## 程序流程\n*\t`c(process continue)`,继续执行\n*\t`n(next step)`,下一步\n*\t`s(step in)`,进入函数\n*\t`thread return <value>`,使用场景：刚进入一个函数，直接模拟返回。\n\n## 断点\n### 管理断点\n*\t`breakpoint(br) list`,断点列表\n*\t`breakpoint enable`,允许断点\n*\t`breakpoint disable`,禁止断点\n\n### 创建断点\n这个方法创建的断点不会显示在界面上，下次重新运行就没了。\n\n*\t`br set -f <filename> -l <line>`\t缩写：`br <filename>:<line>`，某文件的某行加断点\n*\t`br set -F <functionname>`，某个函数加断点\n\n### 断点行为\naction 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。\t\n## 更新UI\n渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。\n\n```\n(lldb) e id $myView = (id)0x7fe3ed101bd0\n(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]\n(lldb) e (void)[CATransaction flush]\n```\n\n## 寻找按钮的action\n```\n(lldb) po [$myButton allTargets]\n{(\n    <MagicEventListener: 0x7fb58bd2e240>\n)}\n(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]\n<__NSArrayM 0x7fb58bd2aa40>(\n_handleTap:\n)\n```\n\n## 寻址\n`image lookup --address <address>`\n\n## 常见问题\n*\t不明类型或者类型不匹配\t\nerror: 'NSLog' has unknown return type; cast the call to its declared return type\t\nerror: 1 errors parsing expression\t\t\n\n需要显示声明类型。\t\t\nlldb是不支持宏的。\n\n*\t找不到方法\t\t\nerror: unsupported expression with unknown type\t\t\nerror: unsupported expression with unknown type\t\t\nerror: 2 errors parsing expression\t\n\t\nLLDB无法通过点语法访问属性，尝试适当改写是否可以通过。\n\n*\tExecution was interrupted\t\nerror: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).\t\t\nThe process has been returned to the state before expression evaluation.\t\t\n\n可能需要显示声明类型。","slug":"lldb","published":1,"date":"2019-07-02T08:47:58.368Z","updated":"2019-07-02T08:47:58.368Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxmmlaca0003iixp4halaoil","content":"<h1 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h1><p>2016年8月30日 下午5:49</p>\n<h2 id=\"打印\"><a href=\"#打印\" class=\"headerlink\" title=\"打印\"></a>打印</h2><p><code>help</code><br><code>p(print)</code>用于打印，<br><code>e(expression)</code>，修改程序运行时的值<br><code>p</code> == <code>e --</code><br><code>po(print object)</code>    </p>\n<p><code>p/&lt;fmt&gt;</code>,按照格式打印<br><code>p/x</code>(16进制)<br><code>p/t</code>(2进制)</p>\n<a id=\"more\"></a>  \n\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>LLDB可以声明变量，不过都要以<code>$</code>开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e int $a = 2</span><br><span class=\"line\">(lldb) p $a * 19</span><br><span class=\"line\">38</span><br><span class=\"line\">(lldb) e NSArray *$array = @[ @&quot;Saturday&quot;, @&quot;Sunday&quot;, @&quot;Monday&quot; ]</span><br><span class=\"line\">(lldb) p [$array count]</span><br><span class=\"line\">2</span><br><span class=\"line\">(lldb) po [[$array objectAtIndex:0] uppercaseString]</span><br><span class=\"line\">SATURDAY</span><br></pre></td></tr></table></figure>\n\n<p>返回值类型无法确定的情况，需要声明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">&apos;M&apos;</span><br><span class=\"line\">(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">77</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序流程\"><a href=\"#程序流程\" class=\"headerlink\" title=\"程序流程\"></a>程序流程</h2><ul>\n<li><code>c(process continue)</code>,继续执行</li>\n<li><code>n(next step)</code>,下一步</li>\n<li><code>s(step in)</code>,进入函数</li>\n<li><code>thread return &lt;value&gt;</code>,使用场景：刚进入一个函数，直接模拟返回。</li>\n</ul>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><h3 id=\"管理断点\"><a href=\"#管理断点\" class=\"headerlink\" title=\"管理断点\"></a>管理断点</h3><ul>\n<li><code>breakpoint(br) list</code>,断点列表</li>\n<li><code>breakpoint enable</code>,允许断点</li>\n<li><code>breakpoint disable</code>,禁止断点</li>\n</ul>\n<h3 id=\"创建断点\"><a href=\"#创建断点\" class=\"headerlink\" title=\"创建断点\"></a>创建断点</h3><p>这个方法创建的断点不会显示在界面上，下次重新运行就没了。</p>\n<ul>\n<li><code>br set -f &lt;filename&gt; -l &lt;line&gt;</code>    缩写：<code>br &lt;filename&gt;:&lt;line&gt;</code>，某文件的某行加断点</li>\n<li><code>br set -F &lt;functionname&gt;</code>，某个函数加断点</li>\n</ul>\n<h3 id=\"断点行为\"><a href=\"#断点行为\" class=\"headerlink\" title=\"断点行为\"></a>断点行为</h3><p>action 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。    </p>\n<h2 id=\"更新UI\"><a href=\"#更新UI\" class=\"headerlink\" title=\"更新UI\"></a>更新UI</h2><p>渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e id $myView = (id)0x7fe3ed101bd0</span><br><span class=\"line\">(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]</span><br><span class=\"line\">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻找按钮的action\"><a href=\"#寻找按钮的action\" class=\"headerlink\" title=\"寻找按钮的action\"></a>寻找按钮的action</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) po [$myButton allTargets]</span><br><span class=\"line\">&#123;(</span><br><span class=\"line\">    &lt;MagicEventListener: 0x7fb58bd2e240&gt;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]</span><br><span class=\"line\">&lt;__NSArrayM 0x7fb58bd2aa40&gt;(</span><br><span class=\"line\">_handleTap:</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻址\"><a href=\"#寻址\" class=\"headerlink\" title=\"寻址\"></a>寻址</h2><p><code>image lookup --address &lt;address&gt;</code></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ul>\n<li>不明类型或者类型不匹配<br>error: ‘NSLog’ has unknown return type; cast the call to its declared return type<br>error: 1 errors parsing expression        </li>\n</ul>\n<p>需要显示声明类型。<br>lldb是不支持宏的。</p>\n<ul>\n<li>找不到方法<br>error: unsupported expression with unknown type<br>error: unsupported expression with unknown type<br>error: 2 errors parsing expression    </li>\n</ul>\n<p>LLDB无法通过点语法访问属性，尝试适当改写是否可以通过。</p>\n<ul>\n<li>Execution was interrupted<br>error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).<br>The process has been returned to the state before expression evaluation.        </li>\n</ul>\n<p>可能需要显示声明类型。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h1><p>2016年8月30日 下午5:49</p>\n<h2 id=\"打印\"><a href=\"#打印\" class=\"headerlink\" title=\"打印\"></a>打印</h2><p><code>help</code><br><code>p(print)</code>用于打印，<br><code>e(expression)</code>，修改程序运行时的值<br><code>p</code> == <code>e --</code><br><code>po(print object)</code>    </p>\n<p><code>p/&lt;fmt&gt;</code>,按照格式打印<br><code>p/x</code>(16进制)<br><code>p/t</code>(2进制)</p>","more":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>LLDB可以声明变量，不过都要以<code>$</code>开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e int $a = 2</span><br><span class=\"line\">(lldb) p $a * 19</span><br><span class=\"line\">38</span><br><span class=\"line\">(lldb) e NSArray *$array = @[ @&quot;Saturday&quot;, @&quot;Sunday&quot;, @&quot;Monday&quot; ]</span><br><span class=\"line\">(lldb) p [$array count]</span><br><span class=\"line\">2</span><br><span class=\"line\">(lldb) po [[$array objectAtIndex:0] uppercaseString]</span><br><span class=\"line\">SATURDAY</span><br></pre></td></tr></table></figure>\n\n<p>返回值类型无法确定的情况，需要声明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">&apos;M&apos;</span><br><span class=\"line\">(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">77</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序流程\"><a href=\"#程序流程\" class=\"headerlink\" title=\"程序流程\"></a>程序流程</h2><ul>\n<li><code>c(process continue)</code>,继续执行</li>\n<li><code>n(next step)</code>,下一步</li>\n<li><code>s(step in)</code>,进入函数</li>\n<li><code>thread return &lt;value&gt;</code>,使用场景：刚进入一个函数，直接模拟返回。</li>\n</ul>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><h3 id=\"管理断点\"><a href=\"#管理断点\" class=\"headerlink\" title=\"管理断点\"></a>管理断点</h3><ul>\n<li><code>breakpoint(br) list</code>,断点列表</li>\n<li><code>breakpoint enable</code>,允许断点</li>\n<li><code>breakpoint disable</code>,禁止断点</li>\n</ul>\n<h3 id=\"创建断点\"><a href=\"#创建断点\" class=\"headerlink\" title=\"创建断点\"></a>创建断点</h3><p>这个方法创建的断点不会显示在界面上，下次重新运行就没了。</p>\n<ul>\n<li><code>br set -f &lt;filename&gt; -l &lt;line&gt;</code>    缩写：<code>br &lt;filename&gt;:&lt;line&gt;</code>，某文件的某行加断点</li>\n<li><code>br set -F &lt;functionname&gt;</code>，某个函数加断点</li>\n</ul>\n<h3 id=\"断点行为\"><a href=\"#断点行为\" class=\"headerlink\" title=\"断点行为\"></a>断点行为</h3><p>action 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。    </p>\n<h2 id=\"更新UI\"><a href=\"#更新UI\" class=\"headerlink\" title=\"更新UI\"></a>更新UI</h2><p>渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e id $myView = (id)0x7fe3ed101bd0</span><br><span class=\"line\">(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]</span><br><span class=\"line\">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻找按钮的action\"><a href=\"#寻找按钮的action\" class=\"headerlink\" title=\"寻找按钮的action\"></a>寻找按钮的action</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) po [$myButton allTargets]</span><br><span class=\"line\">&#123;(</span><br><span class=\"line\">    &lt;MagicEventListener: 0x7fb58bd2e240&gt;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]</span><br><span class=\"line\">&lt;__NSArrayM 0x7fb58bd2aa40&gt;(</span><br><span class=\"line\">_handleTap:</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻址\"><a href=\"#寻址\" class=\"headerlink\" title=\"寻址\"></a>寻址</h2><p><code>image lookup --address &lt;address&gt;</code></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ul>\n<li>不明类型或者类型不匹配<br>error: ‘NSLog’ has unknown return type; cast the call to its declared return type<br>error: 1 errors parsing expression        </li>\n</ul>\n<p>需要显示声明类型。<br>lldb是不支持宏的。</p>\n<ul>\n<li>找不到方法<br>error: unsupported expression with unknown type<br>error: unsupported expression with unknown type<br>error: 2 errors parsing expression    </li>\n</ul>\n<p>LLDB无法通过点语法访问属性，尝试适当改写是否可以通过。</p>\n<ul>\n<li>Execution was interrupted<br>error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).<br>The process has been returned to the state before expression evaluation.        </li>\n</ul>\n<p>可能需要显示声明类型。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}