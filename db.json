{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/cell_高度自适应.md","hash":"8d20d447221502c540f8cd57c6298210f5de6d0e","modified":1563705363087},{"_id":"source/_posts/lldb.md","hash":"637f861701fac6adec9f74374dde098c8c7a50dd","modified":1563705363087},{"_id":"source/to-dos/Runtime.md","hash":"882381909d57a7b8f94c9b9b7f2bad741cc11049","modified":1563705363088},{"_id":"source/.DS_Store","hash":"73a82675758adc4d2632b46b39c35a93c8f36dff","modified":1563706850861},{"_id":"source/to-dos/cfrunloop.md","hash":"08ce2ce2de1ab64d799b39611bbcd00c422b9267","modified":1563705363088},{"_id":"source/to-dos/concurrency_programming_guide.md","hash":"a508c9ff9c55161b4aba0985958d12cf20c59b6b","modified":1563705363088},{"_id":"source/to-dos/归档序列化变成指南.md","hash":"42c26ed084d125928fa5139776724a59a9e28f0d","modified":1563705363088},{"_id":"source/_posts/A-tour-of-the-dart-language.md","hash":"d9d71d4e1ed10c625da347216ba4aab15f06e12f","modified":1564008561235},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1563716015432},{"_id":"source/to-dos/KIF.md","hash":"dab7fd162ec60cf374b7440f2d9fdb509cb3a40f","modified":1563705363088},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1563705363089},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1563705363088},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1563705363089},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1563705363089},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1563705363089},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1563705363095},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1563705363089},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1563705363089},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1563705363090},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1563705363090},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1563705363090},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1563705363095},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1563705363090},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1563705363090},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1563705363094},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1563705363094},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1563705363094},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563705363095},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1563705363094},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563705363095},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1563705363095},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1563705363096},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1563705363098},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1563705363105},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1563705363093},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1563705363094},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1563705363093},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1563705363094},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1563705363094},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1563705363109},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1563705363091},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1563705363092},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1563705363092},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1563705363093},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1563705363105},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1563705363106},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1563705363106},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1563705363106},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1563705363106},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1563705363108},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1563705363106},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1563705363108},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1563705363109},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1563705363096},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1563705363096},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1563705363097},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1563705363096},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1563705363097},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1563705363097},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1563705363097},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1563705363097},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1563705363098},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1563705363097},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1563705363098},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1563705363098},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1563705363099},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1563705363099},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1563705363092},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1563705363092},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1563705363102},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1563705363092},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1563705363093},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1563705363093},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1563705363092},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1563705363108},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1563705363107},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1563705363107},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1563705363107},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1563705363108},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1563705363108},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1563705363102},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1563705363101},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1563705363104},{"_id":"public/to-dos/KIF.html","hash":"3caa23d797c3029abcc9831c94e6cf6b019cbc49","modified":1564008569701},{"_id":"public/to-dos/concurrency_programming_guide.html","hash":"6bcec9ddd592367f53653db69e779146c1092691","modified":1564008569701},{"_id":"public/to-dos/cfrunloop.html","hash":"94a4ead1ad9b173f8034443fb7afe0eaf50f8942","modified":1564008569700},{"_id":"public/archives/index.html","hash":"9dc76ad36969ea64a518413cc6f3bc7503c180c9","modified":1564008569701},{"_id":"public/index.html","hash":"df0205f882643934b9b83cd6e19084fc968803de","modified":1564008569701},{"_id":"public/2019/07/21/lldb/index.html","hash":"bfcb791e47a85cb50c42538554b3667dc2541b11","modified":1564008569701},{"_id":"public/2019/07/21/cell_高度自适应/index.html","hash":"50a1f6d4933bda04b6517971b6282f0d557f8653","modified":1564008569701},{"_id":"public/archives/2019/index.html","hash":"1afb49ff6b2742507c0fd70c93311bafb0cc7f15","modified":1564008569701},{"_id":"public/archives/2019/07/index.html","hash":"95035c0f031a1e49b7e720c257d76dbdc952b701","modified":1564008569701},{"_id":"public/to-dos/归档序列化变成指南.html","hash":"432851b2ffc0f23d6892f5a0086b6c8c087a1452","modified":1564008569702},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1564008458477},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1564008458477},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1564008458478},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1564008458478},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1564008458478},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1564008458478},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1564008458478},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1564008458478},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1564008458478},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1564008458478},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1564008458943},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1564008458946},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1564008458946},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1564008458946},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1564008458946},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1564008458946},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1564008458946},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1564008458946},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1564008458946},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1564008458947},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1564008458947},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1564008458948},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1564008458948},{"_id":"public/2019/07/24/A-tour-of-the-dart-language/index.html","hash":"7521cdb342891c473cbd722b00bca0d850f76275","modified":1564008569702},{"_id":"public/tags/flutter/index.html","hash":"5a1b60aa6cb2be5846592e536ed5aefa5765c88f","modified":1564008569702},{"_id":"public/tags/dart/index.html","hash":"0501f86eb330f6c297752ae58969c7a2d8404ee9","modified":1564008569703}],"Category":[],"Data":[],"Page":[{"_content":"# CFRunLoop\n\n名词：Core Foundation, run loop, `sources`, `timers` 和 `observers`\nneed process:\t需要处理\t\ncallout:\t\t调出\n\n`run loop` 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。\n<!-- more -->\t\n`run loop`监听三种类型的对象：`sources`, `timer`, `observers`。通过**CFRunLoopAddSource**, **CFRunLoopAddTimer**, 或者** CFRunLoopAddObserver**方法把这些对象加入到 `run loop` 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 `run loop` 中移除。  \n每个添加到 `run loop` 中的 `source`, `time`, `observer`都必须关联一个或多个` run loop` 模式。模式决定了一个迭代中需要处理什么事件。`run loop` 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 `sources`, `timers` 和 `observers`。大多数的 `source` 都会被添加到 `run loop` 的默认模式中--这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 `run loop` 从而限制哪些已经处理的`sources`, `timers` 和 `observers`。因为 `run loop` 模式都是指定为字符串，你可以自定义模式限制事件的处理。\t\n\n`Core Foundation` 定义了一个特殊的模式:**common modes**,你可以关联多个具有**共同指定**的 `sources`, `timers` 和 `observers`的模式。当配置一个对象的时候，使用'kCFRunLoopCommonModes'来指定为common modes。每个run loop都有他自己的common modes，**默认模式总是包含在其中**。用'CFRunLoopAddCommonMode'往集合中添加模式。\t\n每个线程都必定有一个 `run loop`。你不能创建和销毁一个线程的`run loop`。需要的时候`Core Foundation`会自动为你创建。使用 `CFRunLoopGetCurrent` 获取当前线程的 `run loop`。调用 `CFRunLoopRun` 使当前线程 `run loop` 运行在默认的模式直到调用 `CFRunLoopStop` 停止。你也可以调用 `CFRunLoopRunInMode` 使当前 `run loop` 运行在指定的模式一段时间（或者当 `run loop` 被停止）。一个模式只会当请求的模式有至少一个 `source` 或者 timer to monitor。\t\nrun loop可以递归运行。你可以在任意run loop的调出中调用'CFRunLoopRun or CFRunLoopRunInMode'，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。\t\n\nCocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。\n\n\n\n## AFN\n### GET\n不管是哪种请求方式，内部都调用\t\n\n\tHTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:\t\n\n通过这个方法创建'NSMutableURLRequst'对象，再调用\n\n\tHTTPRequestOperationWithRequest:success:failure:failure\n\t\nrequestSerializer\t\n\n\n\n# 自动释放池\n对象什么时候释放？  \n`observer`\t两次睡眠之间释放\n\n# 引用策略\nCore Foundation\n\n用于'Core Foundation'对象\t\t\n\nCore Foundation的函数命名非常友好。\t\n\n*\t函数名字中包含**Create**或者**Copy**，你就持有这个对象；如果包含**Get**，那就没有持有对象。","source":"to-dos/cfrunloop.md","raw":"# CFRunLoop\n\n名词：Core Foundation, run loop, `sources`, `timers` 和 `observers`\nneed process:\t需要处理\t\ncallout:\t\t调出\n\n`run loop` 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。\n<!-- more -->\t\n`run loop`监听三种类型的对象：`sources`, `timer`, `observers`。通过**CFRunLoopAddSource**, **CFRunLoopAddTimer**, 或者** CFRunLoopAddObserver**方法把这些对象加入到 `run loop` 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 `run loop` 中移除。  \n每个添加到 `run loop` 中的 `source`, `time`, `observer`都必须关联一个或多个` run loop` 模式。模式决定了一个迭代中需要处理什么事件。`run loop` 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 `sources`, `timers` 和 `observers`。大多数的 `source` 都会被添加到 `run loop` 的默认模式中--这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 `run loop` 从而限制哪些已经处理的`sources`, `timers` 和 `observers`。因为 `run loop` 模式都是指定为字符串，你可以自定义模式限制事件的处理。\t\n\n`Core Foundation` 定义了一个特殊的模式:**common modes**,你可以关联多个具有**共同指定**的 `sources`, `timers` 和 `observers`的模式。当配置一个对象的时候，使用'kCFRunLoopCommonModes'来指定为common modes。每个run loop都有他自己的common modes，**默认模式总是包含在其中**。用'CFRunLoopAddCommonMode'往集合中添加模式。\t\n每个线程都必定有一个 `run loop`。你不能创建和销毁一个线程的`run loop`。需要的时候`Core Foundation`会自动为你创建。使用 `CFRunLoopGetCurrent` 获取当前线程的 `run loop`。调用 `CFRunLoopRun` 使当前线程 `run loop` 运行在默认的模式直到调用 `CFRunLoopStop` 停止。你也可以调用 `CFRunLoopRunInMode` 使当前 `run loop` 运行在指定的模式一段时间（或者当 `run loop` 被停止）。一个模式只会当请求的模式有至少一个 `source` 或者 timer to monitor。\t\nrun loop可以递归运行。你可以在任意run loop的调出中调用'CFRunLoopRun or CFRunLoopRunInMode'，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。\t\n\nCocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。\n\n\n\n## AFN\n### GET\n不管是哪种请求方式，内部都调用\t\n\n\tHTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:\t\n\n通过这个方法创建'NSMutableURLRequst'对象，再调用\n\n\tHTTPRequestOperationWithRequest:success:failure:failure\n\t\nrequestSerializer\t\n\n\n\n# 自动释放池\n对象什么时候释放？  \n`observer`\t两次睡眠之间释放\n\n# 引用策略\nCore Foundation\n\n用于'Core Foundation'对象\t\t\n\nCore Foundation的函数命名非常友好。\t\n\n*\t函数名字中包含**Create**或者**Copy**，你就持有这个对象；如果包含**Get**，那就没有持有对象。","date":"2019-07-21T10:36:03.088Z","updated":"2019-07-21T10:36:03.088Z","path":"to-dos/cfrunloop.html","title":"","comments":1,"layout":"page","_id":"cjyhu95qr00019mxptv0lonsv","content":"<h1 id=\"CFRunLoop\"><a href=\"#CFRunLoop\" class=\"headerlink\" title=\"CFRunLoop\"></a>CFRunLoop</h1><p>名词：Core Foundation, run loop, <code>sources</code>, <code>timers</code> 和 <code>observers</code><br>need process:    需要处理<br>callout:        调出</p>\n<p><code>run loop</code> 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。</p>\n<a id=\"more\"></a>    \n<p><code>run loop</code>监听三种类型的对象：<code>sources</code>, <code>timer</code>, <code>observers</code>。通过<strong>CFRunLoopAddSource</strong>, <strong>CFRunLoopAddTimer</strong>, 或者** CFRunLoopAddObserver**方法把这些对象加入到 <code>run loop</code> 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 <code>run loop</code> 中移除。<br>每个添加到 <code>run loop</code> 中的 <code>source</code>, <code>time</code>, <code>observer</code>都必须关联一个或多个<code>run loop</code> 模式。模式决定了一个迭代中需要处理什么事件。<code>run loop</code> 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>。大多数的 <code>source</code> 都会被添加到 <code>run loop</code> 的默认模式中–这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 <code>run loop</code> 从而限制哪些已经处理的<code>sources</code>, <code>timers</code> 和 <code>observers</code>。因为 <code>run loop</code> 模式都是指定为字符串，你可以自定义模式限制事件的处理。    </p>\n<p><code>Core Foundation</code> 定义了一个特殊的模式:<strong>common modes</strong>,你可以关联多个具有<strong>共同指定</strong>的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>的模式。当配置一个对象的时候，使用’kCFRunLoopCommonModes’来指定为common modes。每个run loop都有他自己的common modes，<strong>默认模式总是包含在其中</strong>。用’CFRunLoopAddCommonMode’往集合中添加模式。<br>每个线程都必定有一个 <code>run loop</code>。你不能创建和销毁一个线程的<code>run loop</code>。需要的时候<code>Core Foundation</code>会自动为你创建。使用 <code>CFRunLoopGetCurrent</code> 获取当前线程的 <code>run loop</code>。调用 <code>CFRunLoopRun</code> 使当前线程 <code>run loop</code> 运行在默认的模式直到调用 <code>CFRunLoopStop</code> 停止。你也可以调用 <code>CFRunLoopRunInMode</code> 使当前 <code>run loop</code> 运行在指定的模式一段时间（或者当 <code>run loop</code> 被停止）。一个模式只会当请求的模式有至少一个 <code>source</code> 或者 timer to monitor。<br>run loop可以递归运行。你可以在任意run loop的调出中调用’CFRunLoopRun or CFRunLoopRunInMode’，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。    </p>\n<p>Cocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。</p>\n<h2 id=\"AFN\"><a href=\"#AFN\" class=\"headerlink\" title=\"AFN\"></a>AFN</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>不管是哪种请求方式，内部都调用    </p>\n<pre><code>HTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:    </code></pre><p>通过这个方法创建’NSMutableURLRequst’对象，再调用</p>\n<pre><code>HTTPRequestOperationWithRequest:success:failure:failure</code></pre><p>requestSerializer    </p>\n<h1 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h1><p>对象什么时候释放？<br><code>observer</code>    两次睡眠之间释放</p>\n<h1 id=\"引用策略\"><a href=\"#引用策略\" class=\"headerlink\" title=\"引用策略\"></a>引用策略</h1><p>Core Foundation</p>\n<p>用于’Core Foundation’对象        </p>\n<p>Core Foundation的函数命名非常友好。    </p>\n<ul>\n<li>函数名字中包含<strong>Create</strong>或者<strong>Copy</strong>，你就持有这个对象；如果包含<strong>Get</strong>，那就没有持有对象。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"CFRunLoop\"><a href=\"#CFRunLoop\" class=\"headerlink\" title=\"CFRunLoop\"></a>CFRunLoop</h1><p>名词：Core Foundation, run loop, <code>sources</code>, <code>timers</code> 和 <code>observers</code><br>need process:    需要处理<br>callout:        调出</p>\n<p><code>run loop</code> 对象监听加入到任务中的源，并且当这些源需要处理的时候分发控制。输入源的例子：用户输入，网络连接，周期或者延迟事件，异步回调。</p>","more":"<p><code>run loop</code>监听三种类型的对象：<code>sources</code>, <code>timer</code>, <code>observers</code>。通过<strong>CFRunLoopAddSource</strong>, <strong>CFRunLoopAddTimer</strong>, 或者** CFRunLoopAddObserver**方法把这些对象加入到 <code>run loop</code> 中，从而当他们需要处理的时候能够接收回调。如果不想再接受他们的回调，你可以把他们从 <code>run loop</code> 中移除。<br>每个添加到 <code>run loop</code> 中的 <code>source</code>, <code>time</code>, <code>observer</code>都必须关联一个或多个<code>run loop</code> 模式。模式决定了一个迭代中需要处理什么事件。<code>run loop</code> 每次执行的时候，他都是在指定的模式下工作。当在一个模式中，他指挥处理这个模式中关联的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>。大多数的 <code>source</code> 都会被添加到 <code>run loop</code> 的默认模式中–这个模式是应用空闲情况下用来处理事件。然而，系统会定义其他的模式，可能执行在这些模式中执行 <code>run loop</code> 从而限制哪些已经处理的<code>sources</code>, <code>timers</code> 和 <code>observers</code>。因为 <code>run loop</code> 模式都是指定为字符串，你可以自定义模式限制事件的处理。    </p>\n<p><code>Core Foundation</code> 定义了一个特殊的模式:<strong>common modes</strong>,你可以关联多个具有<strong>共同指定</strong>的 <code>sources</code>, <code>timers</code> 和 <code>observers</code>的模式。当配置一个对象的时候，使用’kCFRunLoopCommonModes’来指定为common modes。每个run loop都有他自己的common modes，<strong>默认模式总是包含在其中</strong>。用’CFRunLoopAddCommonMode’往集合中添加模式。<br>每个线程都必定有一个 <code>run loop</code>。你不能创建和销毁一个线程的<code>run loop</code>。需要的时候<code>Core Foundation</code>会自动为你创建。使用 <code>CFRunLoopGetCurrent</code> 获取当前线程的 <code>run loop</code>。调用 <code>CFRunLoopRun</code> 使当前线程 <code>run loop</code> 运行在默认的模式直到调用 <code>CFRunLoopStop</code> 停止。你也可以调用 <code>CFRunLoopRunInMode</code> 使当前 <code>run loop</code> 运行在指定的模式一段时间（或者当 <code>run loop</code> 被停止）。一个模式只会当请求的模式有至少一个 <code>source</code> 或者 timer to monitor。<br>run loop可以递归运行。你可以在任意run loop的调出中调用’CFRunLoopRun or CFRunLoopRunInMode’，并且可以在当前线程的调用栈中创建嵌套的run loop。在一个调出中，你不会被限制在一些可以运行的模式中。你可以创建其他的run loop激活状态，使其运行在任何可以得到的模式，包括调用栈中运行级别更高的模式。    </p>\n<p>Cocoa应用基于‘CFRunLoop’自定义实现级别更高的事件循环。</p>\n<h2 id=\"AFN\"><a href=\"#AFN\" class=\"headerlink\" title=\"AFN\"></a>AFN</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>不管是哪种请求方式，内部都调用    </p>\n<pre><code>HTTPRequestOperationWithHTTPMethod:URLString:parameters:success:failure:    </code></pre><p>通过这个方法创建’NSMutableURLRequst’对象，再调用</p>\n<pre><code>HTTPRequestOperationWithRequest:success:failure:failure</code></pre><p>requestSerializer    </p>\n<h1 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h1><p>对象什么时候释放？<br><code>observer</code>    两次睡眠之间释放</p>\n<h1 id=\"引用策略\"><a href=\"#引用策略\" class=\"headerlink\" title=\"引用策略\"></a>引用策略</h1><p>Core Foundation</p>\n<p>用于’Core Foundation’对象        </p>\n<p>Core Foundation的函数命名非常友好。    </p>\n<ul>\n<li>函数名字中包含<strong>Create</strong>或者<strong>Copy</strong>，你就持有这个对象；如果包含<strong>Get</strong>，那就没有持有对象。</li>\n</ul>"},{"_content":"# 并发编程指南\n\n为了提高 `CPU` 计算能力，增加芯片核心数，为了让应用更充分利用 `CPU`，应用使用多线程\n\n\n## 操作队列\n\n*\tNSOperation 基类\n\n通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 `GCD` );\n如果不加到操作队列，可以直接调用 `start`。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 `start` 就会发出异常。\n<!-- more -->\n\n**依赖**\t\t\n设置依赖是一个很方便的确定操作执行顺序的方法。`addDependency:`,`removeDependency:`。只有依赖执行完了，这个操作才能进入就绪状态。\t\n不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，\n由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。\n\n**键值观察属性**\t\t\nisCancelled - read-only\t\t\nisAsynchronous - read-only\t\nisExecuting - read-only\t\t\nisFinished - read-only\t\t\nisReady - read-only\t\t\ndependencies - read-only\t\nqueuePriority - readable and writable\t\ncompletionBlock - readable and writable\t\t\n虽然可以讲观察者绑定在这些属性，但不应该和**视图**元素绑定，因为关于视图的代码要在**主线程**执行，操作可以在任何线程执行，和这些操作绑定的 `KVO` 通知也会在任何线程执行。\n\n**多线程注意**\t\t\n`NSOperation` 子类，实现一些 `accessors`，要注意线程同步。\n\n**异步VS同步**\n\n**方法重写**\n不并发的操作，只需要重写 `main`，可能有数据，如果实现了`settter`, `getter`，要保证线程安全;并发的操作，至少实现这些方法或属性 `start`, `asynchronous`, `executing`, `finished`。\n`start`负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 `executing` 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;\n\n**cancel命令**\t\n`cancel` 不会立即强行停止操作。所有的操作都认可 `cancelled` 属性，你可以在代码中判断。**NOTE**:一个线程是否被加入到队列中决定了 `cancel` 的行为。未加入，这个方法会将操作标记成**已完成**；已加入，将操作标记成**就绪**，并立刻调 `start`,然后退出，操作从队列中清楚。\t\n主要代码要周期性地检查 `cancelled` 属性。实现 `start` 方法，应该早点检查是否取消然后再决定怎么做。\t\n\n**执行operation**\t\t\n`start`: 更新执行状态，并调用 `main`；手动执行操作才调用这个方法。\t\n`main`: 实现这个方法，不要调 `super`。自动执行在 `NSOperation` 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。\t\t\n`cancel`: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。\n如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 `start`，并将它移出队列。\n\n*\tNSBlockOperation\t\n\n一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。\t\n添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。\t\t\n操作正在执行或已经执行结束的时候调用`addExecutionBlock:`会抛出异常。\n\n初始化至少添加一个代码块。当要执行一个`NSBlockOperation`时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，\n\n*\tNSInvocationOperation\n\n管理一个方法封装的单个任务。这个类实习了一个非并发的操作。\n\n```\n- (instancetype)initWithTarget:(id)target\n                      selector:(SEL)sel\n                        object:(id)arg   \nsel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。\n                  \n```\n\n`- (instancetype)initWithInvocation:(NSInvocation *)inv`, `inv` 会对他的参数引用计数加一。\n可以通过查看 `result` 属性，看是否有异常。\n\n使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。\n\n\n**自定义操作**\t\n自定义非并行操作只需要响应`主任务`和`取消`；并行操作则需要重写更多代码。\n\n---\t\n无论什么操作，都要在创建之后，添加到队列中之前，进行配置。\t\n多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。\t\n**优先级**\t\n添加到队列中的操作的执行顺序，**首先**是根据操作的就绪状态；**然后**是根据优先级。\t\n通过 `setQueuePriority:` 改变优先级。\t\n优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。\t\n\n如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。\n\n**执行**\t\n通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。\n\n** 重要 **\t\t\n不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。\n\n虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(`setMaxConcurrentOperationCount:`)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 `GCD` 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。\n\n** 手动执行 **\t\n手动执行要确保操作处于就绪状态，并且调用 `start`。`start` 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。\t\n如果定义了一个并发的操作，应该最开始判断 `isConcurrent`，如果返回 `NO`，确保能决定是否重开一条线程。\n\n\n## 分发队列\n\n## 分发源","source":"to-dos/concurrency_programming_guide.md","raw":"# 并发编程指南\n\n为了提高 `CPU` 计算能力，增加芯片核心数，为了让应用更充分利用 `CPU`，应用使用多线程\n\n\n## 操作队列\n\n*\tNSOperation 基类\n\n通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 `GCD` );\n如果不加到操作队列，可以直接调用 `start`。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 `start` 就会发出异常。\n<!-- more -->\n\n**依赖**\t\t\n设置依赖是一个很方便的确定操作执行顺序的方法。`addDependency:`,`removeDependency:`。只有依赖执行完了，这个操作才能进入就绪状态。\t\n不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，\n由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。\n\n**键值观察属性**\t\t\nisCancelled - read-only\t\t\nisAsynchronous - read-only\t\nisExecuting - read-only\t\t\nisFinished - read-only\t\t\nisReady - read-only\t\t\ndependencies - read-only\t\nqueuePriority - readable and writable\t\ncompletionBlock - readable and writable\t\t\n虽然可以讲观察者绑定在这些属性，但不应该和**视图**元素绑定，因为关于视图的代码要在**主线程**执行，操作可以在任何线程执行，和这些操作绑定的 `KVO` 通知也会在任何线程执行。\n\n**多线程注意**\t\t\n`NSOperation` 子类，实现一些 `accessors`，要注意线程同步。\n\n**异步VS同步**\n\n**方法重写**\n不并发的操作，只需要重写 `main`，可能有数据，如果实现了`settter`, `getter`，要保证线程安全;并发的操作，至少实现这些方法或属性 `start`, `asynchronous`, `executing`, `finished`。\n`start`负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 `executing` 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;\n\n**cancel命令**\t\n`cancel` 不会立即强行停止操作。所有的操作都认可 `cancelled` 属性，你可以在代码中判断。**NOTE**:一个线程是否被加入到队列中决定了 `cancel` 的行为。未加入，这个方法会将操作标记成**已完成**；已加入，将操作标记成**就绪**，并立刻调 `start`,然后退出，操作从队列中清楚。\t\n主要代码要周期性地检查 `cancelled` 属性。实现 `start` 方法，应该早点检查是否取消然后再决定怎么做。\t\n\n**执行operation**\t\t\n`start`: 更新执行状态，并调用 `main`；手动执行操作才调用这个方法。\t\n`main`: 实现这个方法，不要调 `super`。自动执行在 `NSOperation` 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。\t\t\n`cancel`: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。\n如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 `start`，并将它移出队列。\n\n*\tNSBlockOperation\t\n\n一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。\t\n添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。\t\t\n操作正在执行或已经执行结束的时候调用`addExecutionBlock:`会抛出异常。\n\n初始化至少添加一个代码块。当要执行一个`NSBlockOperation`时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，\n\n*\tNSInvocationOperation\n\n管理一个方法封装的单个任务。这个类实习了一个非并发的操作。\n\n```\n- (instancetype)initWithTarget:(id)target\n                      selector:(SEL)sel\n                        object:(id)arg   \nsel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。\n                  \n```\n\n`- (instancetype)initWithInvocation:(NSInvocation *)inv`, `inv` 会对他的参数引用计数加一。\n可以通过查看 `result` 属性，看是否有异常。\n\n使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。\n\n\n**自定义操作**\t\n自定义非并行操作只需要响应`主任务`和`取消`；并行操作则需要重写更多代码。\n\n---\t\n无论什么操作，都要在创建之后，添加到队列中之前，进行配置。\t\n多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。\t\n**优先级**\t\n添加到队列中的操作的执行顺序，**首先**是根据操作的就绪状态；**然后**是根据优先级。\t\n通过 `setQueuePriority:` 改变优先级。\t\n优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。\t\n\n如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。\n\n**执行**\t\n通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。\n\n** 重要 **\t\t\n不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。\n\n虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(`setMaxConcurrentOperationCount:`)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 `GCD` 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。\n\n** 手动执行 **\t\n手动执行要确保操作处于就绪状态，并且调用 `start`。`start` 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。\t\n如果定义了一个并发的操作，应该最开始判断 `isConcurrent`，如果返回 `NO`，确保能决定是否重开一条线程。\n\n\n## 分发队列\n\n## 分发源","date":"2019-07-21T10:36:03.088Z","updated":"2019-07-21T10:36:03.088Z","path":"to-dos/concurrency_programming_guide.html","title":"","comments":1,"layout":"page","_id":"cjyhu95r300039mxpdd7j4wzb","content":"<h1 id=\"并发编程指南\"><a href=\"#并发编程指南\" class=\"headerlink\" title=\"并发编程指南\"></a>并发编程指南</h1><p>为了提高 <code>CPU</code> 计算能力，增加芯片核心数，为了让应用更充分利用 <code>CPU</code>，应用使用多线程</p>\n<h2 id=\"操作队列\"><a href=\"#操作队列\" class=\"headerlink\" title=\"操作队列\"></a>操作队列</h2><ul>\n<li>NSOperation 基类</li>\n</ul>\n<p>通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 <code>GCD</code> );<br>如果不加到操作队列，可以直接调用 <code>start</code>。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 <code>start</code> 就会发出异常。</p>\n<a id=\"more\"></a>\n\n<p><strong>依赖</strong><br>设置依赖是一个很方便的确定操作执行顺序的方法。<code>addDependency:</code>,<code>removeDependency:</code>。只有依赖执行完了，这个操作才能进入就绪状态。<br>不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，<br>由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。</p>\n<p><strong>键值观察属性</strong><br>isCancelled - read-only<br>isAsynchronous - read-only<br>isExecuting - read-only<br>isFinished - read-only<br>isReady - read-only<br>dependencies - read-only<br>queuePriority - readable and writable<br>completionBlock - readable and writable<br>虽然可以讲观察者绑定在这些属性，但不应该和<strong>视图</strong>元素绑定，因为关于视图的代码要在<strong>主线程</strong>执行，操作可以在任何线程执行，和这些操作绑定的 <code>KVO</code> 通知也会在任何线程执行。</p>\n<p><strong>多线程注意</strong><br><code>NSOperation</code> 子类，实现一些 <code>accessors</code>，要注意线程同步。</p>\n<p><strong>异步VS同步</strong></p>\n<p><strong>方法重写</strong><br>不并发的操作，只需要重写 <code>main</code>，可能有数据，如果实现了<code>settter</code>, <code>getter</code>，要保证线程安全;并发的操作，至少实现这些方法或属性 <code>start</code>, <code>asynchronous</code>, <code>executing</code>, <code>finished</code>。<br><code>start</code>负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 <code>executing</code> 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;</p>\n<p><strong>cancel命令</strong><br><code>cancel</code> 不会立即强行停止操作。所有的操作都认可 <code>cancelled</code> 属性，你可以在代码中判断。<strong>NOTE</strong>:一个线程是否被加入到队列中决定了 <code>cancel</code> 的行为。未加入，这个方法会将操作标记成<strong>已完成</strong>；已加入，将操作标记成<strong>就绪</strong>，并立刻调 <code>start</code>,然后退出，操作从队列中清楚。<br>主要代码要周期性地检查 <code>cancelled</code> 属性。实现 <code>start</code> 方法，应该早点检查是否取消然后再决定怎么做。    </p>\n<p><strong>执行operation</strong><br><code>start</code>: 更新执行状态，并调用 <code>main</code>；手动执行操作才调用这个方法。<br><code>main</code>: 实现这个方法，不要调 <code>super</code>。自动执行在 <code>NSOperation</code> 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。<br><code>cancel</code>: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。<br>如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 <code>start</code>，并将它移出队列。</p>\n<ul>\n<li>NSBlockOperation    </li>\n</ul>\n<p>一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。<br>添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。<br>操作正在执行或已经执行结束的时候调用<code>addExecutionBlock:</code>会抛出异常。</p>\n<p>初始化至少添加一个代码块。当要执行一个<code>NSBlockOperation</code>时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，</p>\n<ul>\n<li>NSInvocationOperation</li>\n</ul>\n<p>管理一个方法封装的单个任务。这个类实习了一个非并发的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithTarget:(id)target</span><br><span class=\"line\">                      selector:(SEL)sel</span><br><span class=\"line\">                        object:(id)arg   </span><br><span class=\"line\">sel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。</span><br></pre></td></tr></table></figure>\n\n<p><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code>, <code>inv</code> 会对他的参数引用计数加一。<br>可以通过查看 <code>result</code> 属性，看是否有异常。</p>\n<p>使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。</p>\n<p><strong>自定义操作</strong><br>自定义非并行操作只需要响应<code>主任务</code>和<code>取消</code>；并行操作则需要重写更多代码。</p>\n<hr>\n<p>无论什么操作，都要在创建之后，添加到队列中之前，进行配置。<br>多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。<br><strong>优先级</strong><br>添加到队列中的操作的执行顺序，<strong>首先</strong>是根据操作的就绪状态；<strong>然后</strong>是根据优先级。<br>通过 <code>setQueuePriority:</code> 改变优先级。<br>优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。    </p>\n<p>如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。</p>\n<p><strong>执行</strong><br>通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。</p>\n<p>** 重要 **<br>不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。</p>\n<p>虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(<code>setMaxConcurrentOperationCount:</code>)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 <code>GCD</code> 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。</p>\n<p>** 手动执行 **<br>手动执行要确保操作处于就绪状态，并且调用 <code>start</code>。<code>start</code> 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。<br>如果定义了一个并发的操作，应该最开始判断 <code>isConcurrent</code>，如果返回 <code>NO</code>，确保能决定是否重开一条线程。</p>\n<h2 id=\"分发队列\"><a href=\"#分发队列\" class=\"headerlink\" title=\"分发队列\"></a>分发队列</h2><h2 id=\"分发源\"><a href=\"#分发源\" class=\"headerlink\" title=\"分发源\"></a>分发源</h2>","site":{"data":{}},"excerpt":"<h1 id=\"并发编程指南\"><a href=\"#并发编程指南\" class=\"headerlink\" title=\"并发编程指南\"></a>并发编程指南</h1><p>为了提高 <code>CPU</code> 计算能力，增加芯片核心数，为了让应用更充分利用 <code>CPU</code>，应用使用多线程</p>\n<h2 id=\"操作队列\"><a href=\"#操作队列\" class=\"headerlink\" title=\"操作队列\"></a>操作队列</h2><ul>\n<li>NSOperation 基类</li>\n</ul>\n<p>通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 <code>GCD</code> );<br>如果不加到操作队列，可以直接调用 <code>start</code>。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 <code>start</code> 就会发出异常。</p>","more":"<p><strong>依赖</strong><br>设置依赖是一个很方便的确定操作执行顺序的方法。<code>addDependency:</code>,<code>removeDependency:</code>。只有依赖执行完了，这个操作才能进入就绪状态。<br>不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，<br>由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。</p>\n<p><strong>键值观察属性</strong><br>isCancelled - read-only<br>isAsynchronous - read-only<br>isExecuting - read-only<br>isFinished - read-only<br>isReady - read-only<br>dependencies - read-only<br>queuePriority - readable and writable<br>completionBlock - readable and writable<br>虽然可以讲观察者绑定在这些属性，但不应该和<strong>视图</strong>元素绑定，因为关于视图的代码要在<strong>主线程</strong>执行，操作可以在任何线程执行，和这些操作绑定的 <code>KVO</code> 通知也会在任何线程执行。</p>\n<p><strong>多线程注意</strong><br><code>NSOperation</code> 子类，实现一些 <code>accessors</code>，要注意线程同步。</p>\n<p><strong>异步VS同步</strong></p>\n<p><strong>方法重写</strong><br>不并发的操作，只需要重写 <code>main</code>，可能有数据，如果实现了<code>settter</code>, <code>getter</code>，要保证线程安全;并发的操作，至少实现这些方法或属性 <code>start</code>, <code>asynchronous</code>, <code>executing</code>, <code>finished</code>。<br><code>start</code>负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 <code>executing</code> 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;</p>\n<p><strong>cancel命令</strong><br><code>cancel</code> 不会立即强行停止操作。所有的操作都认可 <code>cancelled</code> 属性，你可以在代码中判断。<strong>NOTE</strong>:一个线程是否被加入到队列中决定了 <code>cancel</code> 的行为。未加入，这个方法会将操作标记成<strong>已完成</strong>；已加入，将操作标记成<strong>就绪</strong>，并立刻调 <code>start</code>,然后退出，操作从队列中清楚。<br>主要代码要周期性地检查 <code>cancelled</code> 属性。实现 <code>start</code> 方法，应该早点检查是否取消然后再决定怎么做。    </p>\n<p><strong>执行operation</strong><br><code>start</code>: 更新执行状态，并调用 <code>main</code>；手动执行操作才调用这个方法。<br><code>main</code>: 实现这个方法，不要调 <code>super</code>。自动执行在 <code>NSOperation</code> 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。<br><code>cancel</code>: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。<br>如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 <code>start</code>，并将它移出队列。</p>\n<ul>\n<li>NSBlockOperation    </li>\n</ul>\n<p>一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。<br>添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。<br>操作正在执行或已经执行结束的时候调用<code>addExecutionBlock:</code>会抛出异常。</p>\n<p>初始化至少添加一个代码块。当要执行一个<code>NSBlockOperation</code>时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，</p>\n<ul>\n<li>NSInvocationOperation</li>\n</ul>\n<p>管理一个方法封装的单个任务。这个类实习了一个非并发的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithTarget:(id)target</span><br><span class=\"line\">                      selector:(SEL)sel</span><br><span class=\"line\">                        object:(id)arg   </span><br><span class=\"line\">sel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。</span><br></pre></td></tr></table></figure>\n\n<p><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code>, <code>inv</code> 会对他的参数引用计数加一。<br>可以通过查看 <code>result</code> 属性，看是否有异常。</p>\n<p>使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。</p>\n<p><strong>自定义操作</strong><br>自定义非并行操作只需要响应<code>主任务</code>和<code>取消</code>；并行操作则需要重写更多代码。</p>\n<hr>\n<p>无论什么操作，都要在创建之后，添加到队列中之前，进行配置。<br>多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。<br><strong>优先级</strong><br>添加到队列中的操作的执行顺序，<strong>首先</strong>是根据操作的就绪状态；<strong>然后</strong>是根据优先级。<br>通过 <code>setQueuePriority:</code> 改变优先级。<br>优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。    </p>\n<p>如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。</p>\n<p><strong>执行</strong><br>通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。</p>\n<p>** 重要 **<br>不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。</p>\n<p>虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(<code>setMaxConcurrentOperationCount:</code>)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 <code>GCD</code> 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。</p>\n<p>** 手动执行 **<br>手动执行要确保操作处于就绪状态，并且调用 <code>start</code>。<code>start</code> 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。<br>如果定义了一个并发的操作，应该最开始判断 <code>isConcurrent</code>，如果返回 <code>NO</code>，确保能决定是否重开一条线程。</p>\n<h2 id=\"分发队列\"><a href=\"#分发队列\" class=\"headerlink\" title=\"分发队列\"></a>分发队列</h2><h2 id=\"分发源\"><a href=\"#分发源\" class=\"headerlink\" title=\"分发源\"></a>分发源</h2>"},{"_content":"# 归档(Archive)\n\n归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。  \n支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：`union`, `void *`, 函数指针, 长链表的指针。\t\n归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: [异常情况](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072)。  \n<!-- more -->\n\n## 编码对象\n对象要通过**编码对象**写入或读取归档。编码对象是 `NSCoder(抽象类)` 之类的实例。 `NSCoder` 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。  \n编码对象通过适当的方法编解码。归档：发送 `encodeWithCoder:` 给对象，解档：发送 `initWithCoder:`。只有遵循了 `NSCoding` 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 `OC` 值的类型的标识以及在层级结构中的位置。\t\n为了解决冗余和约束的问题，引入根对象和条件对象。\t\n\n### 根对象\n两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。  \n解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。  \n`NSCoder` 不会实现对根对象的支持；`NSCoder` 的 `encodeRootObject:` 实现，通过调用 `encodeObject:` 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。\t\n### 条件对象\n有些对象图不适合完全编码。比如某个视图引用了非常多对象（`window`, `target`），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。  \n条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 `encodeConditionalObject:forKey:` 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。  \n`NSCoder` 不实现对条件对象的支持；`NSCoder` 的 `encodeConditionalObject:forKey:` 实现，通过调用 `encodeObject:forKey:` 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。\t\n\n## 有键的归档\n有键归档是通过 `NSKeyedArchiver` 对象创建，`NSKeyedUnarchiver` 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。\t\n\n### 值命名\n对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。\t\n对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。  \n避免使用`$`。\t\n子类也要一定程度上当心前缀的使用，避免和父类冲突。\n\n### 键缺失情况下的返回值\n解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（`nil for objects`, `NO for booleans`, `0.0 for reals`, `NSZeroSize for sizes`等等）。可以用 `containsValueForKey:` 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。\n\n### 类型强制转换\n`NSKeyedUnarchiver` 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。[NSRangeException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException)。此外，浮点整形互转会抛异常[NSInvalidUnarchiveOperationException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException)。\t\n\n### 类版本控制\n### 代理\n`NSKeyedArchiver`, `NSKeyedUnarchiver`都有代理。\n### 无键的编码方法\n可以使用没有没有键的编码，但不提倡。\n\n# 创建以及提取归档\n## 创建归档对象\n被编码对象要遵循 `NSCoding` 协议，实现协议方法：\n\n```\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];\n        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];\n        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];\n    }\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];\n    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];\n    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];\n}\n```\n归档操作:\t\n\n```\nPerson* aPerson = [Person new];\naPerson.name = @\"Kai\";\naPerson.age = 24;\naPerson.gender = @\"male\";\n    \nNSMutableData* data = [[NSMutableData alloc] init];\nNSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];\n[archiver encodeObject:aPerson forKey:personKey];\n[archiver finishEncoding];\n    \nNSString* path = [self pathForArchive];\nBOOL result = [data writeToFile:path atomically:YES];\n```\n解档操作:\n\n```\nNSData* data = [NSData dataWithContentsOfFile:path];\n    \nNSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];\nid obj = [unarchiver decodeObjectForKey:personKey];\n[unarchiver finishDecoding];\n```\n# 编解码对象\n## 编码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。\n\n## 解码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。\n\n### 注意事项\n编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。  \n不需要的项不要将其写出。\t\n尽量不要使用 `containsValueForKey:` ，除非要区分空值的默认值和真实值相同的情况。  \n加速解码比加速编码更有意义。\t\n避免使用`$`。\n\n## 编码期间使用替换\n\n# 序列化属性列表\n`NSPropertyListSerialization`","source":"to-dos/归档序列化变成指南.md","raw":"# 归档(Archive)\n\n归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。  \n支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：`union`, `void *`, 函数指针, 长链表的指针。\t\n归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: [异常情况](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072)。  \n<!-- more -->\n\n## 编码对象\n对象要通过**编码对象**写入或读取归档。编码对象是 `NSCoder(抽象类)` 之类的实例。 `NSCoder` 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。  \n编码对象通过适当的方法编解码。归档：发送 `encodeWithCoder:` 给对象，解档：发送 `initWithCoder:`。只有遵循了 `NSCoding` 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 `OC` 值的类型的标识以及在层级结构中的位置。\t\n为了解决冗余和约束的问题，引入根对象和条件对象。\t\n\n### 根对象\n两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。  \n解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。  \n`NSCoder` 不会实现对根对象的支持；`NSCoder` 的 `encodeRootObject:` 实现，通过调用 `encodeObject:` 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。\t\n### 条件对象\n有些对象图不适合完全编码。比如某个视图引用了非常多对象（`window`, `target`），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。  \n条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 `encodeConditionalObject:forKey:` 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。  \n`NSCoder` 不实现对条件对象的支持；`NSCoder` 的 `encodeConditionalObject:forKey:` 实现，通过调用 `encodeObject:forKey:` 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。\t\n\n## 有键的归档\n有键归档是通过 `NSKeyedArchiver` 对象创建，`NSKeyedUnarchiver` 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。\t\n\n### 值命名\n对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。\t\n对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。  \n避免使用`$`。\t\n子类也要一定程度上当心前缀的使用，避免和父类冲突。\n\n### 键缺失情况下的返回值\n解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（`nil for objects`, `NO for booleans`, `0.0 for reals`, `NSZeroSize for sizes`等等）。可以用 `containsValueForKey:` 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。\n\n### 类型强制转换\n`NSKeyedUnarchiver` 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。[NSRangeException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException)。此外，浮点整形互转会抛异常[NSInvalidUnarchiveOperationException](xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException)。\t\n\n### 类版本控制\n### 代理\n`NSKeyedArchiver`, `NSKeyedUnarchiver`都有代理。\n### 无键的编码方法\n可以使用没有没有键的编码，但不提倡。\n\n# 创建以及提取归档\n## 创建归档对象\n被编码对象要遵循 `NSCoding` 协议，实现协议方法：\n\n```\n- (instancetype)initWithCoder:(NSCoder *)aDecoder {\n    if (self = [super init]) {\n        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];\n        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];\n        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];\n    }\n    return self;\n}\n\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];\n    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];\n    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];\n}\n```\n归档操作:\t\n\n```\nPerson* aPerson = [Person new];\naPerson.name = @\"Kai\";\naPerson.age = 24;\naPerson.gender = @\"male\";\n    \nNSMutableData* data = [[NSMutableData alloc] init];\nNSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];\n[archiver encodeObject:aPerson forKey:personKey];\n[archiver finishEncoding];\n    \nNSString* path = [self pathForArchive];\nBOOL result = [data writeToFile:path atomically:YES];\n```\n解档操作:\n\n```\nNSData* data = [NSData dataWithContentsOfFile:path];\n    \nNSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];\nid obj = [unarchiver decodeObjectForKey:personKey];\n[unarchiver finishDecoding];\n```\n# 编解码对象\n## 编码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。\n\n## 解码一个对象\n如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。\n\n### 注意事项\n编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。  \n不需要的项不要将其写出。\t\n尽量不要使用 `containsValueForKey:` ，除非要区分空值的默认值和真实值相同的情况。  \n加速解码比加速编码更有意义。\t\n避免使用`$`。\n\n## 编码期间使用替换\n\n# 序列化属性列表\n`NSPropertyListSerialization`","date":"2019-07-21T10:36:03.088Z","updated":"2019-07-21T10:36:03.088Z","path":"to-dos/归档序列化变成指南.html","title":"","comments":1,"layout":"page","_id":"cjyhu95r900049mxph0hi80ah","content":"<h1 id=\"归档-Archive\"><a href=\"#归档-Archive\" class=\"headerlink\" title=\"归档(Archive)\"></a>归档(Archive)</h1><p>归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。<br>支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：<code>union</code>, <code>void *</code>, 函数指针, 长链表的指针。<br>归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: <a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072\" target=\"_blank\" rel=\"noopener\">异常情况</a>。  </p>\n<a id=\"more\"></a>\n\n<h2 id=\"编码对象\"><a href=\"#编码对象\" class=\"headerlink\" title=\"编码对象\"></a>编码对象</h2><p>对象要通过<strong>编码对象</strong>写入或读取归档。编码对象是 <code>NSCoder(抽象类)</code> 之类的实例。 <code>NSCoder</code> 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。<br>编码对象通过适当的方法编解码。归档：发送 <code>encodeWithCoder:</code> 给对象，解档：发送 <code>initWithCoder:</code>。只有遵循了 <code>NSCoding</code> 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 <code>OC</code> 值的类型的标识以及在层级结构中的位置。<br>为了解决冗余和约束的问题，引入根对象和条件对象。    </p>\n<h3 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h3><p>两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。<br>解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。<br><code>NSCoder</code> 不会实现对根对象的支持；<code>NSCoder</code> 的 <code>encodeRootObject:</code> 实现，通过调用 <code>encodeObject:</code> 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。    </p>\n<h3 id=\"条件对象\"><a href=\"#条件对象\" class=\"headerlink\" title=\"条件对象\"></a>条件对象</h3><p>有些对象图不适合完全编码。比如某个视图引用了非常多对象（<code>window</code>, <code>target</code>），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。<br>条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 <code>encodeConditionalObject:forKey:</code> 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。<br><code>NSCoder</code> 不实现对条件对象的支持；<code>NSCoder</code> 的 <code>encodeConditionalObject:forKey:</code> 实现，通过调用 <code>encodeObject:forKey:</code> 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。    </p>\n<h2 id=\"有键的归档\"><a href=\"#有键的归档\" class=\"headerlink\" title=\"有键的归档\"></a>有键的归档</h2><p>有键归档是通过 <code>NSKeyedArchiver</code> 对象创建，<code>NSKeyedUnarchiver</code> 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。    </p>\n<h3 id=\"值命名\"><a href=\"#值命名\" class=\"headerlink\" title=\"值命名\"></a>值命名</h3><p>对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。<br>对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。<br>避免使用<code>$</code>。<br>子类也要一定程度上当心前缀的使用，避免和父类冲突。</p>\n<h3 id=\"键缺失情况下的返回值\"><a href=\"#键缺失情况下的返回值\" class=\"headerlink\" title=\"键缺失情况下的返回值\"></a>键缺失情况下的返回值</h3><p>解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（<code>nil for objects</code>, <code>NO for booleans</code>, <code>0.0 for reals</code>, <code>NSZeroSize for sizes</code>等等）。可以用 <code>containsValueForKey:</code> 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。</p>\n<h3 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h3><p><code>NSKeyedUnarchiver</code> 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException\" target=\"_blank\" rel=\"noopener\">NSRangeException</a>。此外，浮点整形互转会抛异常<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException\" target=\"_blank\" rel=\"noopener\">NSInvalidUnarchiveOperationException</a>。    </p>\n<h3 id=\"类版本控制\"><a href=\"#类版本控制\" class=\"headerlink\" title=\"类版本控制\"></a>类版本控制</h3><h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p><code>NSKeyedArchiver</code>, <code>NSKeyedUnarchiver</code>都有代理。</p>\n<h3 id=\"无键的编码方法\"><a href=\"#无键的编码方法\" class=\"headerlink\" title=\"无键的编码方法\"></a>无键的编码方法</h3><p>可以使用没有没有键的编码，但不提倡。</p>\n<h1 id=\"创建以及提取归档\"><a href=\"#创建以及提取归档\" class=\"headerlink\" title=\"创建以及提取归档\"></a>创建以及提取归档</h1><h2 id=\"创建归档对象\"><a href=\"#创建归档对象\" class=\"headerlink\" title=\"创建归档对象\"></a>创建归档对象</h2><p>被编码对象要遵循 <code>NSCoding</code> 协议，实现协议方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class=\"line\">    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>归档操作:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* aPerson = [Person new];</span><br><span class=\"line\">aPerson.name = @&quot;Kai&quot;;</span><br><span class=\"line\">aPerson.age = 24;</span><br><span class=\"line\">aPerson.gender = @&quot;male&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">NSMutableData* data = [[NSMutableData alloc] init];</span><br><span class=\"line\">NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class=\"line\">[archiver encodeObject:aPerson forKey:personKey];</span><br><span class=\"line\">[archiver finishEncoding];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSString* path = [self pathForArchive];</span><br><span class=\"line\">BOOL result = [data writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>\n\n<p>解档操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData* data = [NSData dataWithContentsOfFile:path];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class=\"line\">id obj = [unarchiver decodeObjectForKey:personKey];</span><br><span class=\"line\">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"编解码对象\"><a href=\"#编解码对象\" class=\"headerlink\" title=\"编解码对象\"></a>编解码对象</h1><h2 id=\"编码一个对象\"><a href=\"#编码一个对象\" class=\"headerlink\" title=\"编码一个对象\"></a>编码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。</p>\n<h2 id=\"解码一个对象\"><a href=\"#解码一个对象\" class=\"headerlink\" title=\"解码一个对象\"></a>解码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。<br>不需要的项不要将其写出。<br>尽量不要使用 <code>containsValueForKey:</code> ，除非要区分空值的默认值和真实值相同的情况。<br>加速解码比加速编码更有意义。<br>避免使用<code>$</code>。</p>\n<h2 id=\"编码期间使用替换\"><a href=\"#编码期间使用替换\" class=\"headerlink\" title=\"编码期间使用替换\"></a>编码期间使用替换</h2><h1 id=\"序列化属性列表\"><a href=\"#序列化属性列表\" class=\"headerlink\" title=\"序列化属性列表\"></a>序列化属性列表</h1><p><code>NSPropertyListSerialization</code></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"归档-Archive\"><a href=\"#归档-Archive\" class=\"headerlink\" title=\"归档(Archive)\"></a>归档(Archive)</h1><p>归档提供了一种将对象和值转变成独立结构的字节流的方法，这个字节流保存了关于对象和值的标识。<br>支持的数据类型：对象，纯量，数组，结构体，字符串。不支持一些跨平台的数据类型，比如：<code>union</code>, <code>void *</code>, 函数指针, 长链表的指针。<br>归档会一同保存对象的类型信息，所以解档之后的数据会和归档之前的一样。解档异常情况可参照这里: <a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Archiving/Articles/codingobjects.html#//apple_ref/doc/uid/20000948-97072\" target=\"_blank\" rel=\"noopener\">异常情况</a>。  </p>","more":"<h2 id=\"编码对象\"><a href=\"#编码对象\" class=\"headerlink\" title=\"编码对象\"></a>编码对象</h2><p>对象要通过<strong>编码对象</strong>写入或读取归档。编码对象是 <code>NSCoder(抽象类)</code> 之类的实例。 <code>NSCoder</code> 声明一个广泛的接口，用来保存信息到对象中并且放到其他适合写入到文件中的格式，在程序或者不同网络之间传递，或者执行其他数据类型的交换。也有翻转数据类型的接口。子类实现合适的接口支持特殊的归档格式。<br>编码对象通过适当的方法编解码。归档：发送 <code>encodeWithCoder:</code> 给对象，解档：发送 <code>initWithCoder:</code>。只有遵循了 <code>NSCoding</code> 协议，才能归档。编码时，编码对象纪录对象的类的标识或者 <code>OC</code> 值的类型的标识以及在层级结构中的位置。<br>为了解决冗余和约束的问题，引入根对象和条件对象。    </p>\n<h3 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h3><p>两个对象可能互相引用，造成循环引用。如果编码对象盲目编码，可能会无限循环。单个对象也可能被多个对象引用，编码对象必须区别并处理多个引用或者循环引用，保证编解码正常。<br>解决以上问题，引入根对象。根对象是对象图中的起点。调用编码方法，传入第一个对象开始编码。在这个调用环境中的每个对象都可以被追踪。如果要多次编码同一个对象，只会编码引用而不会重新对该对象编码。<br><code>NSCoder</code> 不会实现对根对象的支持；<code>NSCoder</code> 的 <code>encodeRootObject:</code> 实现，通过调用 <code>encodeObject:</code> 编码对象。他的子类有责任追踪多个引用的对象，这样来保存任何对象图的结构题。    </p>\n<h3 id=\"条件对象\"><a href=\"#条件对象\" class=\"headerlink\" title=\"条件对象\"></a>条件对象</h3><p>有些对象图不适合完全编码。比如某个视图引用了非常多对象（<code>window</code>, <code>target</code>），可能牵扯到整个应用。有些父视图就不需要归档。如果父视图也归档的话，就要对父视图引用。<br>条件对象可以解决这个问题。一个条件对象应该被编码，当且仅当，在其他地方被无条件的编码。条件对象通过 <code>encodeConditionalObject:forKey:</code> 编码。如果所有请求编码对象都是通过这些条件方法，那这个对象不能被编码，并且引用他的解码是空。如果这个对象在其他地方被编码了，所有条件引用解码到单独的编码对象。<br><code>NSCoder</code> 不实现对条件对象的支持；<code>NSCoder</code> 的 <code>encodeConditionalObject:forKey:</code> 实现，通过调用 <code>encodeObject:forKey:</code> 编码对象。子类有责任追踪条件对象，并且除非对象需要，否则不对其编码。    </p>\n<h2 id=\"有键的归档\"><a href=\"#有键的归档\" class=\"headerlink\" title=\"有键的归档\"></a>有键的归档</h2><p>有键归档是通过 <code>NSKeyedArchiver</code> 对象创建，<code>NSKeyedUnarchiver</code> 解码。有键归档在编码值方面不同于有序的归档，他是给定名字或者键。解码归档时，通过名字请求值，允许值按任意顺序或者无序请求。这种自由度给类更灵活地向前兼容或向后兼容。    </p>\n<h3 id=\"值命名\"><a href=\"#值命名\" class=\"headerlink\" title=\"值命名\"></a>值命名</h3><p>对象编码到文档中的值可以单独地用任意字符串命名。文档时分层级的，每个对象编码的值都定义了单独的命名空间，和对象的实例变量类似。因此，当前对象编码的作用域内是键是唯一的。但是不同的对象键不会冲突，即使是同一个类。单个的对象中，子类的键会和父类的键冲突。<br>对于一些公共的可以子类化的类，名字要添加一些前缀来避免以后子类可能用到。合理的前缀是类的全名。<br>避免使用<code>$</code>。<br>子类也要一定程度上当心前缀的使用，避免和父类冲突。</p>\n<h3 id=\"键缺失情况下的返回值\"><a href=\"#键缺失情况下的返回值\" class=\"headerlink\" title=\"键缺失情况下的返回值\"></a>键缺失情况下的返回值</h3><p>解码期间，如果一个键的值不存在，解档对象就会根据调用方法的返回值返回默认值（<code>nil for objects</code>, <code>NO for booleans</code>, <code>0.0 for reals</code>, <code>NSZeroSize for sizes</code>等等）。可以用 <code>containsValueForKey:</code> 方法检测是否存在这个键。但不推荐，影响性能，返回值就已经足够了。</p>\n<h3 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h3><p><code>NSKeyedUnarchiver</code> 支持限制类型强制转换。整形编码，解码后可以是任意整形。浮点类似。编码的值类型相对解码过大，会抛出异常。<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/doc/c_ref/NSRangeException\" target=\"_blank\" rel=\"noopener\">NSRangeException</a>。此外，浮点整形互转会抛异常<a href=\"xcdoc://?url=developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/index.html#//apple_ref/doc/c_ref/NSInvalidUnarchiveOperationException\" target=\"_blank\" rel=\"noopener\">NSInvalidUnarchiveOperationException</a>。    </p>\n<h3 id=\"类版本控制\"><a href=\"#类版本控制\" class=\"headerlink\" title=\"类版本控制\"></a>类版本控制</h3><h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><p><code>NSKeyedArchiver</code>, <code>NSKeyedUnarchiver</code>都有代理。</p>\n<h3 id=\"无键的编码方法\"><a href=\"#无键的编码方法\" class=\"headerlink\" title=\"无键的编码方法\"></a>无键的编码方法</h3><p>可以使用没有没有键的编码，但不提倡。</p>\n<h1 id=\"创建以及提取归档\"><a href=\"#创建以及提取归档\" class=\"headerlink\" title=\"创建以及提取归档\"></a>创建以及提取归档</h1><h2 id=\"创建归档对象\"><a href=\"#创建归档对象\" class=\"headerlink\" title=\"创建归档对象\"></a>创建归档对象</h2><p>被编码对象要遵循 <code>NSCoding</code> 协议，实现协议方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class=\"line\">    if (self = [super init]) &#123;</span><br><span class=\"line\">        _name = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">        _age = [aDecoder decodeIntegerForKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">        _gender = [aDecoder decodeObjectForKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class=\"line\">    [aCoder encodeObject:_name forKey:NSStringFromSelector(@selector(name))];</span><br><span class=\"line\">    [aCoder encodeInteger:_age forKey:NSStringFromSelector(@selector(age))];</span><br><span class=\"line\">    [aCoder encodeObject:_gender forKey:NSStringFromSelector(@selector(gender))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>归档操作:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person* aPerson = [Person new];</span><br><span class=\"line\">aPerson.name = @&quot;Kai&quot;;</span><br><span class=\"line\">aPerson.age = 24;</span><br><span class=\"line\">aPerson.gender = @&quot;male&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">NSMutableData* data = [[NSMutableData alloc] init];</span><br><span class=\"line\">NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class=\"line\">[archiver encodeObject:aPerson forKey:personKey];</span><br><span class=\"line\">[archiver finishEncoding];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSString* path = [self pathForArchive];</span><br><span class=\"line\">BOOL result = [data writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>\n\n<p>解档操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSData* data = [NSData dataWithContentsOfFile:path];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class=\"line\">id obj = [unarchiver decodeObjectForKey:personKey];</span><br><span class=\"line\">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"编解码对象\"><a href=\"#编解码对象\" class=\"headerlink\" title=\"编解码对象\"></a>编解码对象</h1><h2 id=\"编码一个对象\"><a href=\"#编码一个对象\" class=\"headerlink\" title=\"编码一个对象\"></a>编码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 encodeWithCoder: 。</p>\n<h2 id=\"解码一个对象\"><a href=\"#解码一个对象\" class=\"headerlink\" title=\"解码一个对象\"></a>解码一个对象</h2><p>如果一个对象的父类也遵循了 NSCoding 协议，需要先调用父类的 initWithCoder: 。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>编码越少，解码就越少，读写速度就会更加快。只写和类相关的项目。<br>不需要的项不要将其写出。<br>尽量不要使用 <code>containsValueForKey:</code> ，除非要区分空值的默认值和真实值相同的情况。<br>加速解码比加速编码更有意义。<br>避免使用<code>$</code>。</p>\n<h2 id=\"编码期间使用替换\"><a href=\"#编码期间使用替换\" class=\"headerlink\" title=\"编码期间使用替换\"></a>编码期间使用替换</h2><h1 id=\"序列化属性列表\"><a href=\"#序列化属性列表\" class=\"headerlink\" title=\"序列化属性列表\"></a>序列化属性列表</h1><p><code>NSPropertyListSerialization</code></p>"},{"_content":"# KIF 文档\n  \n>  **原文地址：**[https://github.com/kif-framework/KIF](https://github.com/kif-framework/KIF).  \n>  **KIF文档地址：**[http://cocoadocs.org/docsets/KIF/2.0.0/index.html](http://cocoadocs.org/docsets/KIF/2.0.0/index.html)\n<!-- more -->\n\n## 1.KIF介绍\n* 关键类： **KIFTestCase**是**XCTestCase**的子类、**KIFUITestActor**\n* 主要方法：     \n\n```  \ncase类: beforeEach, afterEach, testXXXX;\nactor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,\n在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;\nswitch: setOn: forSwitchWithAccessibilityLabel:  \n```\t\t    \n\n## 2.KIF集成（使用cocoapods）\n\n* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  \n* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  \n* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  \n* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成  \n\n```\ntarget 'Acceptance Tests', :exclusive => true do \npod 'KIF', '~> 3.0', :configurations => ['Debug']  \nend\n```  \n\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target->Build Phases->Target Dependencies，点+，选中响应target；  \n* Build Setting->Linking->Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting->Testing->Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###\t使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?\t\n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`\t\n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n\n","source":"to-dos/KIF.md","raw":"# KIF 文档\n  \n>  **原文地址：**[https://github.com/kif-framework/KIF](https://github.com/kif-framework/KIF).  \n>  **KIF文档地址：**[http://cocoadocs.org/docsets/KIF/2.0.0/index.html](http://cocoadocs.org/docsets/KIF/2.0.0/index.html)\n<!-- more -->\n\n## 1.KIF介绍\n* 关键类： **KIFTestCase**是**XCTestCase**的子类、**KIFUITestActor**\n* 主要方法：     \n\n```  \ncase类: beforeEach, afterEach, testXXXX;\nactor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,\n在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;\nswitch: setOn: forSwitchWithAccessibilityLabel:  \n```\t\t    \n\n## 2.KIF集成（使用cocoapods）\n\n* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  \n* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  \n* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  \n* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成  \n\n```\ntarget 'Acceptance Tests', :exclusive => true do \npod 'KIF', '~> 3.0', :configurations => ['Debug']  \nend\n```  \n\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target->Build Phases->Target Dependencies，点+，选中响应target；  \n* Build Setting->Linking->Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting->Testing->Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###\t使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?\t\n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`\t\n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n\n","date":"2019-07-21T10:36:03.088Z","updated":"2019-07-21T10:36:03.088Z","path":"to-dos/KIF.html","title":"","comments":1,"layout":"page","_id":"cjyhu95re00059mxpzmi28yvd","content":"<h1 id=\"KIF-文档\"><a href=\"#KIF-文档\" class=\"headerlink\" title=\"KIF 文档\"></a>KIF 文档</h1><blockquote>\n<p> <strong>原文地址：</strong><a href=\"https://github.com/kif-framework/KIF\" target=\"_blank\" rel=\"noopener\">https://github.com/kif-framework/KIF</a>.<br> <strong>KIF文档地址：</strong><a href=\"http://cocoadocs.org/docsets/KIF/2.0.0/index.html\" target=\"_blank\" rel=\"noopener\">http://cocoadocs.org/docsets/KIF/2.0.0/index.html</a></p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"1-KIF介绍\"><a href=\"#1-KIF介绍\" class=\"headerlink\" title=\"1.KIF介绍\"></a>1.KIF介绍</h2><ul>\n<li>关键类： <strong>KIFTestCase</strong>是<strong>XCTestCase</strong>的子类、<strong>KIFUITestActor</strong></li>\n<li>主要方法：     </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case类: beforeEach, afterEach, testXXXX;</span><br><span class=\"line\">actor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,</span><br><span class=\"line\">在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;</span><br><span class=\"line\">switch: setOn: forSwitchWithAccessibilityLabel:  </span><br><span class=\"line\">```\t\t    </span><br><span class=\"line\"></span><br><span class=\"line\">## 2.KIF集成（使用cocoapods）</span><br><span class=\"line\"></span><br><span class=\"line\">* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  </span><br><span class=\"line\">* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  </span><br><span class=\"line\">* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  </span><br><span class=\"line\">* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成</span><br></pre></td></tr></table></figure>\n\n<p>target ‘Acceptance Tests’, :exclusive =&gt; true do<br>pod ‘KIF’, ‘~&gt; 3.0’, :configurations =&gt; [‘Debug’]<br>end</p>\n<pre><code>\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target-&gt;Build Phases-&gt;Target Dependencies，点+，选中响应target；  \n* Build Setting-&gt;Linking-&gt;Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting-&gt;Testing-&gt;Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###    使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?    \n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`    \n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"KIF-文档\"><a href=\"#KIF-文档\" class=\"headerlink\" title=\"KIF 文档\"></a>KIF 文档</h1><blockquote>\n<p> <strong>原文地址：</strong><a href=\"https://github.com/kif-framework/KIF\" target=\"_blank\" rel=\"noopener\">https://github.com/kif-framework/KIF</a>.<br> <strong>KIF文档地址：</strong><a href=\"http://cocoadocs.org/docsets/KIF/2.0.0/index.html\" target=\"_blank\" rel=\"noopener\">http://cocoadocs.org/docsets/KIF/2.0.0/index.html</a></p>\n</blockquote>","more":"<h2 id=\"1-KIF介绍\"><a href=\"#1-KIF介绍\" class=\"headerlink\" title=\"1.KIF介绍\"></a>1.KIF介绍</h2><ul>\n<li>关键类： <strong>KIFTestCase</strong>是<strong>XCTestCase</strong>的子类、<strong>KIFUITestActor</strong></li>\n<li>主要方法：     </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case类: beforeEach, afterEach, testXXXX;</span><br><span class=\"line\">actor类: tapViewWithAccessibilityLabel:, waitForViewWithAccessibilityLabel:,</span><br><span class=\"line\">在代码中设置: setAccessibilityLabel:, setIsAccessibilityElement:;</span><br><span class=\"line\">switch: setOn: forSwitchWithAccessibilityLabel:  </span><br><span class=\"line\">```\t\t    </span><br><span class=\"line\"></span><br><span class=\"line\">## 2.KIF集成（使用cocoapods）</span><br><span class=\"line\"></span><br><span class=\"line\">* 创建项目，不勾选 `include Unit Test` 和 `include UI Test`(勾选怎么操作？)；  </span><br><span class=\"line\">* 导航目录选中项目，然后在target左下角点击加号(区别于窗口左下角的加号)，选中`unit bundle`，命名确定；  </span><br><span class=\"line\">* 导航目录下生成target，其中`.m`文件，将其删除(因为我们要使用KIF);  </span><br><span class=\"line\">* 创建podfile，内容如下，保存退出，`pod install`，编辑，完成</span><br></pre></td></tr></table></figure>\n\n<p>target ‘Acceptance Tests’, :exclusive =&gt; true do<br>pod ‘KIF’, ‘~&gt; 3.0’, :configurations =&gt; [‘Debug’]<br>end</p>\n<pre><code>\n## 3.KIF使用 \n\n* 选中项目,再选中你刚创建的target-&gt;Build Phases-&gt;Target Dependencies，点+，选中响应target；  \n* Build Setting-&gt;Linking-&gt;Bundle Loader,写入`$(BUILT_PRODUCTS_DIR)/你的项目名字.app/你的项目名字`；  \n* Build Setting-&gt;Testing-&gt;Test Host,写入`$(BUNDLE_LOADER)`，搜索`Wrapper Extension`，确认对应`xctest`\n\n###    使用方法  \n* 测试target中，创建KIFTestCase的子类，.m中实现`beforeEach`(数据初始化)，测试方法(`testXXXX`，编译器会自动检测到并执行)\n* 测试方法中，`[tester tapViewWithAccessibilityLabel:]`主要是这个方法，其他有些不同控件方法不一样,(switch,alertController,etc)\n* 切换视图控制器，要用`waitForViewWithAccessibilityLabel:`保证视图控制器已经出现\n\n## 4.常见问题\n* cocoapods头文件找不到?    \n`build setting`下`User Header Search Paths`(区别于`Header Search Paths`)，写入`${SRCROOT}`,选择`recursive`    \n* 模拟器加载但是应用没有出现，加载10秒超时  \n检查`Test Host`设置是否正确\n* 测试方法超时，view not found\n视图设置`accessibility label`。xib中设置步骤: `inspector`第三个，`accessibility`组中的`Label`\n</code></pre>"}],"Post":[{"_content":"# cell 高度自适应\n  \n参考文章：[Raywenderich](https://www.raywenderlich.com/129059/self-sizing-table-view-cells)  \n  \n*\t 通过约束布局 `cell` 的子视图，子视图对 `cell` 的四个方向都需要建立约束；\n*\t `tableview` 要设置属性 `rowHeight`, `estimateRowHeight`\n\n```\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 380;\n```\nSo Easy!!","source":"_posts/cell_高度自适应.md","raw":"# cell 高度自适应\n  \n参考文章：[Raywenderich](https://www.raywenderlich.com/129059/self-sizing-table-view-cells)  \n  \n*\t 通过约束布局 `cell` 的子视图，子视图对 `cell` 的四个方向都需要建立约束；\n*\t `tableview` 要设置属性 `rowHeight`, `estimateRowHeight`\n\n```\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 380;\n```\nSo Easy!!","slug":"cell_高度自适应","published":1,"date":"2019-07-21T10:36:03.087Z","updated":"2019-07-21T10:36:03.087Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyhu95qo00009mxprnng3pq6","content":"<h1 id=\"cell-高度自适应\"><a href=\"#cell-高度自适应\" class=\"headerlink\" title=\"cell 高度自适应\"></a>cell 高度自适应</h1><p>参考文章：<a href=\"https://www.raywenderlich.com/129059/self-sizing-table-view-cells\" target=\"_blank\" rel=\"noopener\">Raywenderich</a>  </p>\n<ul>\n<li>通过约束布局 <code>cell</code> 的子视图，子视图对 <code>cell</code> 的四个方向都需要建立约束；</li>\n<li><code>tableview</code> 要设置属性 <code>rowHeight</code>, <code>estimateRowHeight</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</span><br><span class=\"line\">self.tableView.estimatedRowHeight = 380;</span><br></pre></td></tr></table></figure>\n\n<p>So Easy!!</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"cell-高度自适应\"><a href=\"#cell-高度自适应\" class=\"headerlink\" title=\"cell 高度自适应\"></a>cell 高度自适应</h1><p>参考文章：<a href=\"https://www.raywenderlich.com/129059/self-sizing-table-view-cells\" target=\"_blank\" rel=\"noopener\">Raywenderich</a>  </p>\n<ul>\n<li>通过约束布局 <code>cell</code> 的子视图，子视图对 <code>cell</code> 的四个方向都需要建立约束；</li>\n<li><code>tableview</code> 要设置属性 <code>rowHeight</code>, <code>estimateRowHeight</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</span><br><span class=\"line\">self.tableView.estimatedRowHeight = 380;</span><br></pre></td></tr></table></figure>\n\n<p>So Easy!!</p>\n"},{"_content":"# LLDB\t\n2016年8月30日 下午5:49\n\n## 打印\n`help`  \n`p(print)`用于打印，\t\t\n`e(expression)`，修改程序运行时的值\t\t\n`p` == `e --`\t\n`po(print object)`\t\n\n`p/<fmt>`,按照格式打印\t  \n`p/x`(16进制)   \n`p/t`(2进制)\n<!-- more -->  \n\n## 变量\nLLDB可以声明变量，不过都要以`$`开头。\n\t\n```\n(lldb) e int $a = 2\n(lldb) p $a * 19\n38\n(lldb) e NSArray *$array = @[ @\"Saturday\", @\"Sunday\", @\"Monday\" ]\n(lldb) p [$array count]\n2\n(lldb) po [[$array objectAtIndex:0] uppercaseString]\nSATURDAY\n```\n返回值类型无法确定的情况，需要声明:\n\n```\n(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n'M'\n(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n77\n```\n\n## 程序流程\n*\t`c(process continue)`,继续执行\n*\t`n(next step)`,下一步\n*\t`s(step in)`,进入函数\n*\t`thread return <value>`,使用场景：刚进入一个函数，直接模拟返回。\n\n## 断点\n### 管理断点\n*\t`breakpoint(br) list`,断点列表\n*\t`breakpoint enable`,允许断点\n*\t`breakpoint disable`,禁止断点\n\n### 创建断点\n这个方法创建的断点不会显示在界面上，下次重新运行就没了。\n\n*\t`br set -f <filename> -l <line>`\t缩写：`br <filename>:<line>`，某文件的某行加断点\n*\t`br set -F <functionname>`，某个函数加断点\n\n### 断点行为\naction 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。\t\n## 更新UI\n渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。\n\n```\n(lldb) e id $myView = (id)0x7fe3ed101bd0\n(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]\n(lldb) e (void)[CATransaction flush]\n```\n\n## 寻找按钮的action\n```\n(lldb) po [$myButton allTargets]\n{(\n    <MagicEventListener: 0x7fb58bd2e240>\n)}\n(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]\n<__NSArrayM 0x7fb58bd2aa40>(\n_handleTap:\n)\n```\n\n## 寻址\n`image lookup --address <address>`\n\n## 常见问题\n*\t不明类型或者类型不匹配\t\nerror: 'NSLog' has unknown return type; cast the call to its declared return type\t\nerror: 1 errors parsing expression\t\t\n\n需要显示声明类型。\t\t\nlldb是不支持宏的。\n\n*\t找不到方法\t\t\nerror: unsupported expression with unknown type\t\t\nerror: unsupported expression with unknown type\t\t\nerror: 2 errors parsing expression\t\n\t\nLLDB无法通过点语法访问属性，尝试适当改写是否可以通过。\n\n*\tExecution was interrupted\t\nerror: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).\t\t\nThe process has been returned to the state before expression evaluation.\t\t\n\n可能需要显示声明类型。","source":"_posts/lldb.md","raw":"# LLDB\t\n2016年8月30日 下午5:49\n\n## 打印\n`help`  \n`p(print)`用于打印，\t\t\n`e(expression)`，修改程序运行时的值\t\t\n`p` == `e --`\t\n`po(print object)`\t\n\n`p/<fmt>`,按照格式打印\t  \n`p/x`(16进制)   \n`p/t`(2进制)\n<!-- more -->  \n\n## 变量\nLLDB可以声明变量，不过都要以`$`开头。\n\t\n```\n(lldb) e int $a = 2\n(lldb) p $a * 19\n38\n(lldb) e NSArray *$array = @[ @\"Saturday\", @\"Sunday\", @\"Monday\" ]\n(lldb) p [$array count]\n2\n(lldb) po [[$array objectAtIndex:0] uppercaseString]\nSATURDAY\n```\n返回值类型无法确定的情况，需要声明:\n\n```\n(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n'M'\n(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]\n77\n```\n\n## 程序流程\n*\t`c(process continue)`,继续执行\n*\t`n(next step)`,下一步\n*\t`s(step in)`,进入函数\n*\t`thread return <value>`,使用场景：刚进入一个函数，直接模拟返回。\n\n## 断点\n### 管理断点\n*\t`breakpoint(br) list`,断点列表\n*\t`breakpoint enable`,允许断点\n*\t`breakpoint disable`,禁止断点\n\n### 创建断点\n这个方法创建的断点不会显示在界面上，下次重新运行就没了。\n\n*\t`br set -f <filename> -l <line>`\t缩写：`br <filename>:<line>`，某文件的某行加断点\n*\t`br set -F <functionname>`，某个函数加断点\n\n### 断点行为\naction 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。\t\n## 更新UI\n渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。\n\n```\n(lldb) e id $myView = (id)0x7fe3ed101bd0\n(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]\n(lldb) e (void)[CATransaction flush]\n```\n\n## 寻找按钮的action\n```\n(lldb) po [$myButton allTargets]\n{(\n    <MagicEventListener: 0x7fb58bd2e240>\n)}\n(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]\n<__NSArrayM 0x7fb58bd2aa40>(\n_handleTap:\n)\n```\n\n## 寻址\n`image lookup --address <address>`\n\n## 常见问题\n*\t不明类型或者类型不匹配\t\nerror: 'NSLog' has unknown return type; cast the call to its declared return type\t\nerror: 1 errors parsing expression\t\t\n\n需要显示声明类型。\t\t\nlldb是不支持宏的。\n\n*\t找不到方法\t\t\nerror: unsupported expression with unknown type\t\t\nerror: unsupported expression with unknown type\t\t\nerror: 2 errors parsing expression\t\n\t\nLLDB无法通过点语法访问属性，尝试适当改写是否可以通过。\n\n*\tExecution was interrupted\t\nerror: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).\t\t\nThe process has been returned to the state before expression evaluation.\t\t\n\n可能需要显示声明类型。","slug":"lldb","published":1,"date":"2019-07-21T10:36:03.087Z","updated":"2019-07-21T10:36:03.087Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyhu95qs00029mxplswlnt7n","content":"<h1 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h1><p>2016年8月30日 下午5:49</p>\n<h2 id=\"打印\"><a href=\"#打印\" class=\"headerlink\" title=\"打印\"></a>打印</h2><p><code>help</code><br><code>p(print)</code>用于打印，<br><code>e(expression)</code>，修改程序运行时的值<br><code>p</code> == <code>e --</code><br><code>po(print object)</code>    </p>\n<p><code>p/&lt;fmt&gt;</code>,按照格式打印<br><code>p/x</code>(16进制)<br><code>p/t</code>(2进制)</p>\n<a id=\"more\"></a>  \n\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>LLDB可以声明变量，不过都要以<code>$</code>开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e int $a = 2</span><br><span class=\"line\">(lldb) p $a * 19</span><br><span class=\"line\">38</span><br><span class=\"line\">(lldb) e NSArray *$array = @[ @&quot;Saturday&quot;, @&quot;Sunday&quot;, @&quot;Monday&quot; ]</span><br><span class=\"line\">(lldb) p [$array count]</span><br><span class=\"line\">2</span><br><span class=\"line\">(lldb) po [[$array objectAtIndex:0] uppercaseString]</span><br><span class=\"line\">SATURDAY</span><br></pre></td></tr></table></figure>\n\n<p>返回值类型无法确定的情况，需要声明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">&apos;M&apos;</span><br><span class=\"line\">(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">77</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序流程\"><a href=\"#程序流程\" class=\"headerlink\" title=\"程序流程\"></a>程序流程</h2><ul>\n<li><code>c(process continue)</code>,继续执行</li>\n<li><code>n(next step)</code>,下一步</li>\n<li><code>s(step in)</code>,进入函数</li>\n<li><code>thread return &lt;value&gt;</code>,使用场景：刚进入一个函数，直接模拟返回。</li>\n</ul>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><h3 id=\"管理断点\"><a href=\"#管理断点\" class=\"headerlink\" title=\"管理断点\"></a>管理断点</h3><ul>\n<li><code>breakpoint(br) list</code>,断点列表</li>\n<li><code>breakpoint enable</code>,允许断点</li>\n<li><code>breakpoint disable</code>,禁止断点</li>\n</ul>\n<h3 id=\"创建断点\"><a href=\"#创建断点\" class=\"headerlink\" title=\"创建断点\"></a>创建断点</h3><p>这个方法创建的断点不会显示在界面上，下次重新运行就没了。</p>\n<ul>\n<li><code>br set -f &lt;filename&gt; -l &lt;line&gt;</code>    缩写：<code>br &lt;filename&gt;:&lt;line&gt;</code>，某文件的某行加断点</li>\n<li><code>br set -F &lt;functionname&gt;</code>，某个函数加断点</li>\n</ul>\n<h3 id=\"断点行为\"><a href=\"#断点行为\" class=\"headerlink\" title=\"断点行为\"></a>断点行为</h3><p>action 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。    </p>\n<h2 id=\"更新UI\"><a href=\"#更新UI\" class=\"headerlink\" title=\"更新UI\"></a>更新UI</h2><p>渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e id $myView = (id)0x7fe3ed101bd0</span><br><span class=\"line\">(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]</span><br><span class=\"line\">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻找按钮的action\"><a href=\"#寻找按钮的action\" class=\"headerlink\" title=\"寻找按钮的action\"></a>寻找按钮的action</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) po [$myButton allTargets]</span><br><span class=\"line\">&#123;(</span><br><span class=\"line\">    &lt;MagicEventListener: 0x7fb58bd2e240&gt;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]</span><br><span class=\"line\">&lt;__NSArrayM 0x7fb58bd2aa40&gt;(</span><br><span class=\"line\">_handleTap:</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻址\"><a href=\"#寻址\" class=\"headerlink\" title=\"寻址\"></a>寻址</h2><p><code>image lookup --address &lt;address&gt;</code></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ul>\n<li>不明类型或者类型不匹配<br>error: ‘NSLog’ has unknown return type; cast the call to its declared return type<br>error: 1 errors parsing expression        </li>\n</ul>\n<p>需要显示声明类型。<br>lldb是不支持宏的。</p>\n<ul>\n<li>找不到方法<br>error: unsupported expression with unknown type<br>error: unsupported expression with unknown type<br>error: 2 errors parsing expression    </li>\n</ul>\n<p>LLDB无法通过点语法访问属性，尝试适当改写是否可以通过。</p>\n<ul>\n<li>Execution was interrupted<br>error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).<br>The process has been returned to the state before expression evaluation.        </li>\n</ul>\n<p>可能需要显示声明类型。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LLDB\"><a href=\"#LLDB\" class=\"headerlink\" title=\"LLDB\"></a>LLDB</h1><p>2016年8月30日 下午5:49</p>\n<h2 id=\"打印\"><a href=\"#打印\" class=\"headerlink\" title=\"打印\"></a>打印</h2><p><code>help</code><br><code>p(print)</code>用于打印，<br><code>e(expression)</code>，修改程序运行时的值<br><code>p</code> == <code>e --</code><br><code>po(print object)</code>    </p>\n<p><code>p/&lt;fmt&gt;</code>,按照格式打印<br><code>p/x</code>(16进制)<br><code>p/t</code>(2进制)</p>","more":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>LLDB可以声明变量，不过都要以<code>$</code>开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e int $a = 2</span><br><span class=\"line\">(lldb) p $a * 19</span><br><span class=\"line\">38</span><br><span class=\"line\">(lldb) e NSArray *$array = @[ @&quot;Saturday&quot;, @&quot;Sunday&quot;, @&quot;Monday&quot; ]</span><br><span class=\"line\">(lldb) p [$array count]</span><br><span class=\"line\">2</span><br><span class=\"line\">(lldb) po [[$array objectAtIndex:0] uppercaseString]</span><br><span class=\"line\">SATURDAY</span><br></pre></td></tr></table></figure>\n\n<p>返回值类型无法确定的情况，需要声明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">&apos;M&apos;</span><br><span class=\"line\">(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]</span><br><span class=\"line\">77</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"程序流程\"><a href=\"#程序流程\" class=\"headerlink\" title=\"程序流程\"></a>程序流程</h2><ul>\n<li><code>c(process continue)</code>,继续执行</li>\n<li><code>n(next step)</code>,下一步</li>\n<li><code>s(step in)</code>,进入函数</li>\n<li><code>thread return &lt;value&gt;</code>,使用场景：刚进入一个函数，直接模拟返回。</li>\n</ul>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><h3 id=\"管理断点\"><a href=\"#管理断点\" class=\"headerlink\" title=\"管理断点\"></a>管理断点</h3><ul>\n<li><code>breakpoint(br) list</code>,断点列表</li>\n<li><code>breakpoint enable</code>,允许断点</li>\n<li><code>breakpoint disable</code>,禁止断点</li>\n</ul>\n<h3 id=\"创建断点\"><a href=\"#创建断点\" class=\"headerlink\" title=\"创建断点\"></a>创建断点</h3><p>这个方法创建的断点不会显示在界面上，下次重新运行就没了。</p>\n<ul>\n<li><code>br set -f &lt;filename&gt; -l &lt;line&gt;</code>    缩写：<code>br &lt;filename&gt;:&lt;line&gt;</code>，某文件的某行加断点</li>\n<li><code>br set -F &lt;functionname&gt;</code>，某个函数加断点</li>\n</ul>\n<h3 id=\"断点行为\"><a href=\"#断点行为\" class=\"headerlink\" title=\"断点行为\"></a>断点行为</h3><p>action 断点中可以执行任意命令：可以是调试器命令，shell 命令，也可以是更直接的打印。    </p>\n<h2 id=\"更新UI\"><a href=\"#更新UI\" class=\"headerlink\" title=\"更新UI\"></a>更新UI</h2><p>渲染服务（backboardd）不同于但前调试进程，所以不会被打断，不需要执行程序就可以更新UI。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) e id $myView = (id)0x7fe3ed101bd0</span><br><span class=\"line\">(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]</span><br><span class=\"line\">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻找按钮的action\"><a href=\"#寻找按钮的action\" class=\"headerlink\" title=\"寻找按钮的action\"></a>寻找按钮的action</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) po [$myButton allTargets]</span><br><span class=\"line\">&#123;(</span><br><span class=\"line\">    &lt;MagicEventListener: 0x7fb58bd2e240&gt;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]</span><br><span class=\"line\">&lt;__NSArrayM 0x7fb58bd2aa40&gt;(</span><br><span class=\"line\">_handleTap:</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"寻址\"><a href=\"#寻址\" class=\"headerlink\" title=\"寻址\"></a>寻址</h2><p><code>image lookup --address &lt;address&gt;</code></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ul>\n<li>不明类型或者类型不匹配<br>error: ‘NSLog’ has unknown return type; cast the call to its declared return type<br>error: 1 errors parsing expression        </li>\n</ul>\n<p>需要显示声明类型。<br>lldb是不支持宏的。</p>\n<ul>\n<li>找不到方法<br>error: unsupported expression with unknown type<br>error: unsupported expression with unknown type<br>error: 2 errors parsing expression    </li>\n</ul>\n<p>LLDB无法通过点语法访问属性，尝试适当改写是否可以通过。</p>\n<ul>\n<li>Execution was interrupted<br>error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=EXC_I386_GPFLT).<br>The process has been returned to the state before expression evaluation.        </li>\n</ul>\n<p>可能需要显示声明类型。</p>"},{"title":"Dart 入门 (译)","date":"2019-07-24T15:33:48.000Z","_content":"\n本文列出了 Dart 语言的每个主要功能的用法，从变量和运算符到类库。本文适用于有其他编程语言经验的开发者。\n想学习更多 Dart 核心库的，请查看此[文档](https://dart.dev/guides/libraries/library-tour)。想学习更多语言细节的，请查看此[文档](https://dart.dev/guides/language/spec)。\n<!-- more -->\n\n目录\n- [1. 一段基础的 Dart 程序](#1-%e4%b8%80%e6%ae%b5%e5%9f%ba%e7%a1%80%e7%9a%84-dart-%e7%a8%8b%e5%ba%8f)\n- [2. 重要概念](#2-%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5)\n- [3. 关键字](#3-%e5%85%b3%e9%94%ae%e5%ad%97)\n- [4. 变量](#4-%e5%8f%98%e9%87%8f)\n  - [4.1 默认值](#41-%e9%bb%98%e8%ae%a4%e5%80%bc)\n  - [4.2 Final 和 const 关键字](#42-final-%e5%92%8c-const-%e5%85%b3%e9%94%ae%e5%ad%97)\n- [5. 自带类型](#5-%e8%87%aa%e5%b8%a6%e7%b1%bb%e5%9e%8b)\n  - [5.1 数值](#51-%e6%95%b0%e5%80%bc)\n  - [5.2 字符串](#52-%e5%ad%97%e7%ac%a6%e4%b8%b2)\n  - [5.3 布尔](#53-%e5%b8%83%e5%b0%94)\n  - [5.4 数组](#54-%e6%95%b0%e7%bb%84)\n  - [5.5 集](#55-%e9%9b%86)\n  - [5.6 表](#56-%e8%a1%a8)\n  - [5.7 Runes](#57-runes)\n  - [5.8 符号](#58-%e7%ac%a6%e5%8f%b7)\n- [6. 函数](#6-%e5%87%bd%e6%95%b0)\n  - [6.1 可选参数](#61-%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0)\n  - [6.2 main() 函数](#62-main-%e5%87%bd%e6%95%b0)\n  - [6.3 一等公民函数](#63-%e4%b8%80%e7%ad%89%e5%85%ac%e6%b0%91%e5%87%bd%e6%95%b0)\n  - [6.4 匿名函数](#64-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0)\n  - [6.5 作用域](#65-%e4%bd%9c%e7%94%a8%e5%9f%9f)\n  - [6.6 词法闭包](#66-%e8%af%8d%e6%b3%95%e9%97%ad%e5%8c%85)\n  - [6.7 函数的等价性](#67-%e5%87%bd%e6%95%b0%e7%9a%84%e7%ad%89%e4%bb%b7%e6%80%a7)\n  - [6.8 返回值](#68-%e8%bf%94%e5%9b%9e%e5%80%bc)\n- [7. 运算符](#7-%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.1 算数运算符](#71-%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.2 关系运算法](#72-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e6%b3%95)\n  - [7.3 类型推断运算符](#73-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.4 赋值运算符](#74-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.5 逻辑运算符](#75-%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.6 位移运算符](#76-%e4%bd%8d%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.7 条件表达式](#77-%e6%9d%a1%e4%bb%b6%e8%a1%a8%e8%be%be%e5%bc%8f)\n  - [7.8 多级表示法](#78-%e5%a4%9a%e7%ba%a7%e8%a1%a8%e7%a4%ba%e6%b3%95)\n  - [7.9 其它](#79-%e5%85%b6%e5%ae%83)\n- [8. 控制语句](#8-%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5)\n  - [8.1 If else](#81-if-else)\n  - [8.2 For 循环](#82-for-%e5%be%aa%e7%8e%af)\n  - [8.3 While & do-while](#83-while--do-while)\n  - [8.4 Break & continue](#84-break--continue)\n  - [8.5 Switch case](#85-switch-case)\n  - [8.6 断言](#86-%e6%96%ad%e8%a8%80)\n- [9. 异常处理](#9-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86)\n  - [9.1 Throw](#91-throw)\n  - [9.2 Catch](#92-catch)\n  - [9.3 Finally](#93-finally)\n- [10. 类](#10-%e7%b1%bb)\n  - [10.1 使用类成员变量](#101-%e4%bd%bf%e7%94%a8%e7%b1%bb%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f)\n  - [10.2 使用构造函数](#102-%e4%bd%bf%e7%94%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [10.3 获取对象类型](#103-%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b)\n  - [10.4 实例变量](#104-%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f)\n  - [10.5 构造函数](#105-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [10.6 方法](#106-%e6%96%b9%e6%b3%95)\n  - [10.7 抽象类](#107-%e6%8a%bd%e8%b1%a1%e7%b1%bb)\n  - [10.8 隐式接口](#108-%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3)\n  - [10.9 扩展类](#109-%e6%89%a9%e5%b1%95%e7%b1%bb)\n  - [10.10 枚举类型](#1010-%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b)\n  - [10.11 类添加特性](#1011-%e7%b1%bb%e6%b7%bb%e5%8a%a0%e7%89%b9%e6%80%a7)\n  - [10.12 类变量和方法](#1012-%e7%b1%bb%e5%8f%98%e9%87%8f%e5%92%8c%e6%96%b9%e6%b3%95)\n- [11. 泛型](#11-%e6%b3%9b%e5%9e%8b)\n  - [11.1 为什么使用泛型](#111-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b)\n  - [11.2 使用集合字面值](#112-%e4%bd%bf%e7%94%a8%e9%9b%86%e5%90%88%e5%ad%97%e9%9d%a2%e5%80%bc)\n  - [11.3 使用带参数化类型的构造函数](#113-%e4%bd%bf%e7%94%a8%e5%b8%a6%e5%8f%82%e6%95%b0%e5%8c%96%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [11.4 泛型集合](#114-%e6%b3%9b%e5%9e%8b%e9%9b%86%e5%90%88)\n  - [11.5 泛型约束](#115-%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f)\n  - [11.6 使用泛型方法](#116-%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95)\n- [12. 库](#12-%e5%ba%93)\n  - [12.1 使用库](#121-%e4%bd%bf%e7%94%a8%e5%ba%93)\n  - [12.2 实现库](#122-%e5%ae%9e%e7%8e%b0%e5%ba%93)\n- [13. 异步](#13-%e5%bc%82%e6%ad%a5)\n  - [13.1 处理 Future](#131-%e5%a4%84%e7%90%86-future)\n  - [13.2 声明异步函数](#132-%e5%a3%b0%e6%98%8e%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0)\n  - [13.3 处理流](#133-%e5%a4%84%e7%90%86%e6%b5%81)\n- [14. 生成器](#14-%e7%94%9f%e6%88%90%e5%99%a8)\n- [15. 可调用的类](#15-%e5%8f%af%e8%b0%83%e7%94%a8%e7%9a%84%e7%b1%bb)\n- [16. 独立性](#16-%e7%8b%ac%e7%ab%8b%e6%80%a7)\n- [17. 类型定义](#17-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89)\n- [18. 元数据](#18-%e5%85%83%e6%95%b0%e6%8d%ae)\n- [19. 注释](#19-%e6%b3%a8%e9%87%8a)\n- [20. 小结](#20-%e5%b0%8f%e7%bb%93)\n\n\n## 1. 一段基础的 Dart 程序\n从以下代码片段感受下 Dart 语言的特性：\n\n```Dart\n// Define a function.\nprintIteger(int number) {\n    print('The number is $number');\n}\n\n// This is where the app starts executing.\nmain() {\n    var number = 42; // Declare and initialize a variable.\n    printInteger(number); // Call a function.\n}\n```\n这段程序使用的特性适用于其他所有 Dart 应用：\n\n// This is a comment.<br>\n一个单行注释。另外，Dart 也支持多行和文档注视。更多信息看[注释文档](https://dart.dev/guides/language/language-tour#comments)。\n\nint<br>\nDart 自带类型之一，其他的还有 *String*, *List* 和 *bool*。\n\n42<br>\n数值字面值，编译时期常量。\n\nprint()<br>\n打印输出。\n\n'...' 或者 \"...\"<br>\n字符串字面值。\n\n$variableNmae 或者 ${variableName}<br>\n字符串差值写法。更多请查看[文档](https://dart.dev/guides/language/language-tour#strings)。\n\nmain()<br>\nApp 执行入口，每个应用必须有。更多信息查看[文档](https://dart.dev/guides/language/language-tour#the-main-function)。\n\n## 2. 重要概念\n\n学习 Dart 过程中，牢记以下概念：<br>\n* 任何可以存到变量中的都是对象，每个对象都是类的实例。数值、函数和 `null` 都是对象。所有对象都继承自 [Object](https://api.dart.dev/stable/dart-core/Object-class.html) 类。\n* 虽然 Dart 是强类型的，但类型声明是可选的，因为 Dart 有类型推断。上述代码中， `number` 并没有声明类型，被自动推断成 `int`j。可以使用[特定的动态类型](https://dart.dev/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed)，来声明任意类型的变量。\n* Dart 支持泛型，比如 `List<int>` 和 `List<dynamic>`。\n* Dart 支持将函数声明在类内部（*实例方法*）和外部（*静态方法*），也支持*嵌套函数*。\n* 类似的，Dart 也支持将变量声明在类内部（*实例变量*）和外部（*静态变量*）。实例变量也叫做域(*field*)或属性(*property*)。\n* 不同于 Java，Dart 没有 `public`, `protected` 和 `private` 关键字。可以使用 `_` 开头的标识符来表示变量是库内私有的。更多信息请看[文档](https://dart.dev/guides/language/language-tour#libraries-and-visibility)。\n* 标识符以字母和下划线开头，后面可以跟字母数字下划线。\n* Dart 有表达式(*expressions*)和语句(*statements*)。\n* Dart 工具有两种报错类型：*警告*和*错误*。警告表示代码运行结果可能不同于期望，但不会使程序退出。错误分为编译期和运行时。编译器错误会导致程序无法启动，运行时错误会导致程序运行时抛出异常。\n\n## 3. 关键字\n\n|                        |                      |                        |                     |\n| :--------------------- | :------------------: | :--------------------: | ------------------: |\n| abstract<sup>2</sup>   | dynamic<sup>2</sup>  | implements<sup>2</sup> |    show<sup>1</sup> |\n| as<sup>2</sup>         |         else         |   import<sup>2</sup>   |  static<sup>2</sup> |\n| assert                 |         enum         |           in           |               super |\n| async<sup>1</sup>      |  export<sup>2</sup>  | interface<sup>2</sup>  |              switch |\n| await<sup>3</sup>      |       extends        |           is           |    sync<sup>1</sup> |\n| break                  | external<sup>2</sup> |  library<sup>2</sup>   |                this |\n| case                   | factory<sup>2</sup>  |   mixin<sup>2</sup>    |               throw |\n| catch                  |        false         |          new           |                true |\n| class                  |        final         |          null          |                 try |\n| const                  |       finally        |     on<sup>1</sup>     | typedef<sup>2</sup> |\n| continue               |         for          |  operator<sup>2</sup>  |                 var |\n| convariant<sup>2</sup> | Function<sup>2</sup> |    part<sup>2</sup>    |                void |\n| default                |   get<sup>2</sup>    |        rethrow         |               while |\n| deferred<sup>2</sup>   |   hide<sup>1</sup>   |         return         |                with |\n| do                     |          if          |    set<sup>2</sup>     |   yield<sup>3</sup> |\n\n尽量避免使用以上关键字作为标识符。如果不可避免需要使用，可以用上角标标记：\n* 角标 1 单词是上下文相关的，只有在特定位置才有意义。他们可以在任意位置使用。\n* 角标 2 单词是自带标识符。为简化 JS 代码移植到 Dart 的难度，这些关键字不能用作类或者类型的名字以及导入的前缀。\n* 角标 3 单词是少有的几个跟异步操作相关的关键字，Dart 1.0 发布后才加入。不能在任何标记 `async`, `async*` 以及 `sync*` 的函数体中使用 `await` 和 `yield` 作为标识符。\n\n剩余的关键字是保留使用的，不能作为标识符。\n\n## 4. 变量\n\n创建并初始化一个变量：\n```Dart\nvar name = 'Bob';\n```\n变量保存引用，`name` 变量保存对一个 `String` 对象的引用。\n\n`name` 变量推断成 `String` 类型，也可以通过显示声明类型修改。如果对象不是限制为单一类型，可以使用 `Object` 或 `dynamic` 修饰。\n```Dart\ndynamic name = 'Bob';\n```\n另一种方式是显示声明类型：\n```Dart\nString name = 'Bob';\n```\n\n### 4.1 默认值\n\n未主动初始化的变量默认初始化为 `null`。即使是数值类型也是如此，在 Dart 的世界里，万物皆对象。\n```Dart\nint lineCount;\nprint('${lineCount == null}'); // true\n```\n\n### 4.2 Final 和 const 关键字\n\n对于初始化后就不再修改的变量，使用 `final` 或 `const` 替代 `var` 或者类型。final 变量只能设置一次，const 变量是一个编译期常量。一个顶层(top-level)的类变量在第一次使用的时候初始化。\n\n创建并设置一个 final 变量：\n```Dart\nfinal name = 'Bab';\nfinal String nickname = 'Bobby';\n```\n不能修改 final 变量的值：\n```Dart\nname = 'Alice';\n```\n使用 `const` 创建**编译期常量**。如果是静态常量，使用 `static const` 修饰。常量必须在声明的时候用字面值或者算术表达式初始化:\n```Dart\nconst bar = 1000000;\nconst double atm = 1.01325 * bar;\n```\n`const` 关键字不仅限于声明常量，还可以用于创建常量的值，以及声明构造函数用于创建常量值。任意变量都可以有一个常量值。\n```Dart\nvar foo = const [];\nfinal bar = const [];\nconst baz = [];\n```\n当用 `const` 声明一个常量，可以省略初始化表达式中的 `const`。\n\n对于非 const 或 非 final 声明的变量，即使之前存的值是一个常量，仍然可以修改：\n```Dart\nfoo = [1, 2, 3] // 之前是 []\n```\n但是不能修改一个 const 变量：\n```Dart\nbaz = [42]; // Error\n```\n\n## 5. 自带类型\n\nDart 对以下类型做了特殊支持：\n* numbers\n* strings\n* booleans\n* lists\n* sets\n* maps\n* runes(用于在字符串中表达 Unicode 字符)\n* symbols\n\n可以用以上任意类型的字面值初始化对象。比如，`this is a string` 是一个字符串字面值，`true` 是一个布尔字面值。\n\n因为 Dart 中的变量都保存一个对象的引用，所以可用构造器（*constructors*)初始化变量。部分自带类型有自己的构造器。比如，用 `Map()` 创建一个表。\n\n### 5.1 数值\n\nDart 支持两种数值：\n\nint<br>\n整型值。\n\ndouble<br>\n64位浮点数。\n\n`int`, `float` 都是 num 子类（subtypes)。num 定义了 +, -, * 和 /，以及 `abs()`, `ceil()` 和 `floor()` 等方法（位运算符定义在 `int`）。其他方法可能定义在 `dart:math` 库中。\n\n整型值是不带小数：\n```Dart\nvar x = 1;\nvar hex = 0xDEADBEEF;\n```\n如果数值包含小数，那它就是 double。浮点数字面值：\n```Dart\nvar y = 1.1\nvar exponents = 1.42e5;\n```\n字符串和数值相互转换：\n```Dart\n// String -> int\nvar one = int.parse('1');\nassert(one == 1);\n\n// String -> double\nvar onePointOne = double.parse('1.1');\nassert(onePointOne == 1.1);\n\n// int -> String\nString oneAsString= 1.toString();\nassert(oneAsString == '1');\n\n// double -> String\nString piAsString = 3.14159.toStringAsFixed(2);\nassert(piAsString == '3.14');\n```\n\n整型的位操作：\n```Dart\nassert((3 >> 1) == 1);\nassert((3 << 1) == 6);\nassert((3 | 4) == 7);\n```\n\n数值字面值是编译期常量。算术表达式包含的操作数都是编译期常量，那么该表达式也是编译期常量。\n```Dart\nconst msPerSecond = 1000;\nconst secondsUntilRetry = 5;\nconst msUntilRetry = secondsUntilRetry * msPerSecond;\n```\n\n### 5.2 字符串\n\nDart 字符串是 UTF-16 单元码的序列。可以用单引号或双引号创建字符串。\n```Dart\nvar s1 = 'Single quotes work well for string literals';\nvar s2 = \"Double quotes work just as well\";\nvar s3 = 'It\\'s easy to escape the string delimeter';\nvar s4 = \"It's even easier to use the other delimeter\";\n```\n\n字符串包含表达式的方式，用 `${expression}`。如果表达式是个标识符，可以省略 {}。\n```Dart\nvar s = 'string interpolation';\n\nassert('Dart has $s, which is very handy.' ==\n    'Dart has string interpolation, ' +\n        'which is very handy.');\nassert('That deserves all caps. ' +\n        '${s.toUpperCase()} is very handy!' ==\n    'That deserves all caps. ' +\n        'STRING INTERPOLATION is very handy!');\n```\n\n拼接字符串可以用 `+` 运算符：\n```Dart\nvar s1 = 'String '\n    'concatenation'\n    \" works even over line breaks.\";\nassert(s1 ==\n    'String concatenation works even over '\n        'line breaks.');\n\nvar s2 = 'The + operator ' + 'works, as well.';\nassert(s2 == 'The + operator works, as well.');\n```\n\n创建多行字符串的方式：使用 `'''` 或 `\"\"\"`：\n```Dart\nvar s1 = '''\nYou can create\nmulti-line strings like this one.\n''';\n\nvar s2 = \"\"\"This is also a\nmulti-line string.\"\"\";\n```\n\n创建原始的字符串方式：使用 `r`：\n```Dart\nvar s = r'In a raw string, not even \\n gets special treatment.';\n```\n\n字符串字面值是编译期常量：\n```Dart\n// These work in a const string.\nconst aConstNum = 0;\nconst aConstBool = true;\nconst aConstString = 'a constant string';\n\n// These do NOT work in a const string.\nvar aNum = 0;\nvar aBool = true;\nvar aString = 'a string';\nconst aConstList = [1, 2, 3];\n\nconst validConstString = '$aConstNum $aConstBool $aConstString';\n// const invalidConstString = '$aNum $aBool $aString $aConstList';\n```\n\n### 5.3 布尔\n\nDart 用 `bool` 表示布尔值。只有两个对象有布尔类型：布尔字面值 `true` 和 `false`，两者都是编译期常量。\n\nDart 是类型安全的，意味着 `if (nonbooleanValue)` 或者 `assert (nonbooleanValue)` 是不合法的。应该用显式的值校验：\n```Dart\n// Check for an empty string.\nvar fullName = '';\nassert(fullName.isEmpty);\n\n// Check for zero.\nvar hitPoints = 0;\nassert(hitPoints <= 0);\n\n// Check for null.\nvar unicorn;\nassert(unicorn == null);\n\n// Check for NaN.\nvar iMeantToDoThis = 0 / 0;\nassert(iMeantToDoThis.isNaN);\n```\n\n### 5.4 数组\n\n几乎在所有编程语言中，最通用的集合(collection)是*数组*或者说是对象组。Dart 中，数组是 *List* 对象。\n\nDart 数组字面值类似 JS。例子：\n```Dart\nvar list = [1, 2, 3];\n```\n\n数组索引范围[0, list.length-1]：\n```Dart\nvar list = [1, 2, 3];\nassert(list.length == 3);\nassert(list[1] == 2);\n\nlist[1] = 1;\nassert(list[1] == 1);\n```\n\n创建编译期常量的数组方法，在数组字面值前加 `const`：\n```Dart\nvar constantList = const [1, 2, 3];\nconstantList[1] = 1; // Uncommenting this causes an error.\n```\n\nDart 2.3 中引入了 **展开操作符(spread operator(...))** 和 **可空的(null-aware)展开操作符(...?)**，两者都提供了将多个元素插入集合的便捷方法。\n\n如下：\n```Dart\nvar list = [1, 2, 3];\nvar list2 = [0, ...list];\nassert(list2.length == 4);\n```\n\n如果展开操作符右边表达式可能为空，可用 `...?` 来避免异常：\n```Dart\nvar list:\nvar list2 = [0, ...?list];\nassert(list2.length == 1);\n```\n\n另外，Dart 2.3 还引入了 **collection if** 和 **collection for**，用来构造集合。\n\n**Collection if** 例子：\n```Dart\nvar nav = [\n    'Home',\n    'Furniture',\n    'Plants',\n    if (promoActive) 'Outlet'\n];\n```\n\n**Collection for** 例子：\n```Dart\nvar list1 = [1, 2, 3];\nvar list2 = [\n    '#0',\n    for (var i in list1) '#$i'\n];\nassert(list2[1] == '#1');\n```\n\n### 5.5 集\n\nDart 集无序且元素唯一。Dart 通过两方面支持集，一个是字面值，另一个是 `Set` 类型。\n\n字面值创建集对象：\n```Dart\nvar halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};\n```\n\n创建空集：\n```Dart\nvar set1 = <String>{};\nSet<String> set2 = {};\nvar map = {}; // Create a map, not a set.\n```\n\n集添加元素，`add()` 或者 `addAll()`：\n```Dart\nvar set1 = <String>{};\nset1.add('fluorine');\nset1.addAll(halogens);\n```\n\n使用 `.length` 获取集的大小：\n```Dart\nvar set1 = <String>{};\nset1.add('fluorine');\nset1.addAll(halogens);\nassert(set1.length == 5);\n```\n\n创建集的编译期字面值，集字面值前加 `const` 关键字：\n```Dart\nfinal constantSet = const {\n    'fluorine',\n  'chlorine',\n  'bromine',\n  'iodine',\n  'astatine',\n}\n// constantSet.add('helium'); // Uncommenting this causes an error.\n```\n\nDart 2.3 后，集也同数组一样，支持展开操作符和 collection fors 以及 ifs。\n\n### 5.6 表\n\n表包含键值对，键值可以是任意类型的对象。Key 在表中唯一，value 可以重复。Dart 通过两方面支持表，一个是字面值，另一个是 Map 类型。\n\nDart 表的字面值例子：\n```Dart\nvar gifts = {\n  // Key:    Value\n  'first': 'partridge',\n  'second': 'turtledoves',\n  'fifth': 'golden rings'\n};\n\nvar nobleGases = {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n```\n\n也可以用构造函数创建的表对象：\n```Dart\nvar gifts = Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\ngifts['fifth'] = 'golden rings';\n\nvar nobleGases = Map();\nnobleGases[2] = 'helium';\nnobleGases[10] = 'neon';\nnobleGases[18] = 'argon';\n```\n\n对已有表中增加键值对：\n```Dart\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds'; // Add a key-value pair\n```\n\n从表中获取值：\n```Dart\nvar gifts = {'first': 'partridge'};\nassert(gifts['first'] == 'partridge');\n```\n\n从表中查不到对应的 key：\n```Dart\nvar gifts = {'first': 'partridge'};\nassert(gifts['fifth'] == null);\n```\n\n用 `.length` 获取表中键值对数量：\n```Dart\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds';\nassert(gifts.length == 2);\n```\n\n创建表的编译期常量，表字面值前加 `const` 关键字：\n```Dart\nfinal constantMap = const {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n```\n\nDart 2.3 后，表也同数组一样，支持展开操作符和 collection fors 以及 ifs。\n\n### 5.7 Runes\n\nDart runes 是字符串的 UTF-32 码点。\n\nUnicode 为全世界所有字母，数字和符号定义了唯一的数值。由于 Dart 字符串是 UTF-16 单元码的序列，因此在字符串中药表示 32位 Unicode 值需要特殊语法。\n\n通常表达一个 Unicode 码点的形式是 `\\uXXXX`，XXXX 是一个4位的16进制数。比如，爱心字符(♥)是 `\\u2665`。当指定多于或少于4位数字时，将值放在花括号中。\n\nString 类有一些相关属性获取 rune 信息。比如，`codeUnitAt` 和 `codeUnit` 属性返回16位的单元码，用 `runes` 属性获取字符串中的 runes。\n\n16位和32位转换：\n```Dart\nmain() {\n  var clapping = '\\u{1f44f}';\n  print(clapping);\n  print(clapping.codeUnits);\n  print(clapping.runes.toList());\n\n  Runes input = new Runes(\n      '\\u2665  \\u{1f605}  \\u{1f60e}  \\u{1f47b}  \\u{1f596}  \\u{1f44d}');\n  print(new String.fromCharCodes(input));\n}\n```\n\n### 5.8 符号\n\n*符号* 对象代表 Dart 程序中的运算符或者标识符。你可能从不会用符号，但它们对于按名称引用标识符的 API 非常有用，因为缩小会更改标识符名称而不会更改标识符符号。\n\n获取符号的方法，`#` 号后面跟着标识符：\n```Dart\n#radix\n#bar\n```\n\n符号字面值是编译期常量。\n\n## 6. 函数\n\nDart 是真正的面向对象语言，即使是函数也有类型，*Funtion*。这意味着函数可以赋值给变量或者作为参数传递。还可以调用类的实例，就好像它是一个函数。更多信息查看[文档](https://dart.dev/guides/language/language-tour#callable-classes)。\n\n函数的实现如下：\n```Dart\nbool isNoble(int atomicNumber) {\n    return _nobleGases[atomicNumber] != null;\n}\n```\n\n虽然类型标注更为高效，但是省略类型的函数依然可用：\n```Dart\nisNoble(atomicNumber) {\n  return _nobleGases[atomicNumber] != null;\n}\n```\n\n对于只有一个表达式的函数，可以简写为：\n```Dart\nbool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;\n```\n\n`=> expr` 语法是 `{ return expr; } 的简写。`=>` 标注通常推断为*箭头*语法。\n\n函数参数支持两种类型：必需(required)和可选(optional)。必需参数在前，可选参数在后。命名为可选的参数仍然可以标记为 `@required`。\n\n### 6.1 可选参数\n\n通过位置或命名中的一种来标记可选参数，但不能两者同时使用。\n\n#### 可选命名参数 <!-- omit in toc -->\n\n调用一个函数，可通过 `paramName: value` 指定命名的参数，比如：\n```Dart\nenableFlags(bold: true, hidde: false);\n```\n\n在定义函数的时候，使用 `{param1, param2, ...}` 指定命名参数：\n```Dart\n/// Sets the [bold] and [hidden] flags ...\nvoid enableFlags({bool bold, bool hidden}) {...}\n```\n\n*Flutter* 实例创建表达式较为复杂，所以 widget 构造函数只使用命名的参数。这能让实例创建表达式可读性更高。\n\n你可以在任意的 Dart 代码中使用 `@required` 来标记命名的参数，从而指定该参数为*必需*参数。举例：\n```Dart\nconst Scrollbar({Key key, @required Widget child});\n```\n\n当构造一个 `Scrollbar` 时，如果 `child` 参数缺省，编译器会报错。\n\n*Required* 定义在 *meta* 包中。两种方式导入：import `package:meta/meta.dart` 或导入其它导出 `meta` 的包。\n\n#### 可选位置参数 <!-- omit in toc -->\n\n函数参数列表中，将后面的参数用 `[]` 标记：\n```Dart\nString say(String from, String msg, [String device]) {\n    var result = '$from says $msg';\n    if (device != null) {\n        result = '$result with a $device';\n    }\n    return result;\n}\n```\n\n不带可选参数的调用：\n```Dart\nassert(say('Bob', 'Howdy') == 'Bob says Howdy');\n```\n\n携带可选参数的调用：\n```Dart\nassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');\n```\n\n#### 默认参数值 <!-- omit in toc -->\n\n函数参数支持给定默认值，包括命名和位置参数。默认值是编译期常量。如果没有主动提供默认值，默认值为 `null`。\n\n默认值例子：\n```Dart\n/// Sets the [bold] and [hidden] flags ...\nvoid enableFlags({bool bold = false, bool hidden = false}) {...}\n\n// bold will be true; hidden will be false.\nenableFlags(bold: true);\n```\n\n为位置参数提供默认值：\n```Dart\nString say(String from, String msg,\n    [String device = 'carrier pigeon', String mood]) {\n  var result = '$from says $msg';\n  if (device != null) {\n    result = '$result with a $device';\n  }\n  if (mood != null) {\n    result = '$result (in a $mood mood)';\n  }\n  return result;\n}\n\nassert(say('Bob', 'Howdy') ==\n    'Bob says Howdy with a carrier pigeon');\n```\n\n函数参数类型为数组或表类型，也支持默认值：\n```Dart\nvoid doStuff(\n    {List<int> list = const [1, 2, 3],\n    Map<String, String> gifts = const {\n      'first': 'paper',\n      'second': 'cotton',\n      'third': 'leather'\n    }}) {\n  print('list:  $list');\n  print('gifts: $gifts');\n}\n```\n\n### 6.2 main() 函数\n\n每个应用都有一个顶层的 `main()` 函数作为程序入口。该函数返回值为 `void` 并且有一个可选参数，类型为 `List<String>`。\n\nWeb 程序的 `main()` 函数例子：\n```Dart\nvoid main() {\n  querySelector('#sample_text_id');\n    ..text = 'Click me!';\n    ..onClick.listen(reverseText);\n}\n```\n\n命令行程序的 `main()` 函数例子：\n```Dart\n// Run the app like this: dart args.dart 1 test\nvoid main(List<String> arguments) {\n  print(arguments);\n\n  assert(arguments.length == 2);\n  assert(int.parse(arguments[0]) == 1);\n  assert(arguments[1] == 'test');\n}\n```\n\n用 *args library* 库定义并解析命令行参数。\n\n### 6.3 一等公民函数\n\n函数可以作为其它函数的参数，比如：\n```Dart\nvoid printElement(int element) {\n  print(element);\n}\n\nvar list = [1, 2, 3];\n\n// Pass printElement as aparameter.\nlist.forEach(printElement);\n```\n\n函数也可以存到变量中，比如：\n```Dart\nvar loudify = (msg) => '!!! ${msg.toUpperCase()}!!!';\nassert(loudify('hello') == '!!!HELLO!!!');\n```\n上面使用了匿名函数。\n\n### 6.4 匿名函数\n\n大多函数都有名字，比如 `main()` 和 `printElement()`，一些没有名字的函数叫做 *匿名函数(Anonymous funstions)*、*lambda* 或 *闭包(closure)*。函数存到变量中，可以被添加到集合中或者被移除。\n\n匿名函数和一般函数类似，0个或多个参数，参数间用逗号隔开，支持可选类型标注，参数用 `()` 包含。\n\n匿名函数如下：\n```Dart\n([Type] param1[, ...]) {\n  codeBlock;\n}\n```\n\n以下例子定义一个匿名函数，函数携带一个未定义类型的参数 `item`。每遍历一个 list 中元素，函数都会被调用一次，并打印对应元素的信息。\n```Dart\nvar list = ['apples', 'bananas', 'oranges'];\nlist.forEach((item) {\n  print('${list.indexOf(item)}: $item');\n});\n```\n\n匿名函数也可以简写成箭头函数。\n```Dart\nlist.forEach((item) => print('${list.indexOf(item)}: $item'));\n```\n\n### 6.5 作用域 \n\nDart 是一种 *lexically scoped language*。代码的布局决定了变量的作用域。\n\n以下例子展示了嵌套函数的变量作用域：\n```Dart\nbool topLevel = true;\n\nvoid main() {\n  var insideMain = true;\n\n  void myFunction() {\n    var insideFunction = true;\n\n    void nestedFunction() {\n      var insideNestedFunction = true;\n\n      assert(topLevel);\n      assert(insideMain);\n      assert(insideFunction);\n      assert(insideNestedFunction);\n    }\n  }\n}\n```\n\n### 6.6 词法闭包\n\n*闭包* 是函数，能访问作用域内的变量，即使该闭包在原来作用域外部被使用。\n\n函数能延长变量的生命周期。以下例子中，`makeAdder()` 捕获变量 `addBy`。当函数执行结束，`addBy` 被保存到函数中。\n```Dart\n/// Returns a function that adds [addBy] to the\n/// function's argument.\nFunction makeAdder(num addBy) {\n  return (num i) => addBy + i;\n}\n\nvoid main() {\n  // Create a function that adds 2.\n  var add2 = makeAdder(2);\n\n  // Create a function that adds 4.\n  var add4 = makeAdder(4);\n\n  assert(add2(3) == 5);\n  assert(add4(3) == 7);\n}\n```\n\n### 6.7 函数的等价性\n\n以下例子中，比较了顶层函数，静态方法和实例方法的等价性:\n```Dart\nvoid foo() {}\n\nclass A {\n  static void bar() {}\n  void baz() {}\n}\n\nvoid main() {\n  var x;\n\n  // Comparing top-level functions.\n  x = foo;\n  print(foo == x);\n\n  // Comparing static methods.\n  x = A.bar;\n  print(A.bar == x);\n\n  // Comparing instance methods.\n  var v = A();\n  var w = A();\n  var y = w;\n  x = w.baz;\n\n  print(y.baz == x);\n\n  print(v.baz != w.baz);\n}\n```Dart\n\n### 6.8 返回值\n\n所有函数都有返回值。如果没有显示指定，会默认在函数体最后加上 `return null`。\n```Dart\nfoo() {}\nprint(foo() == null);\n```\n\n## 7. 运算符\n\n|          描述          |                    运算符                     |\n| :--------------------: | :-------------------------------------------: |\n|     一元后缀运算符     |      `expr++`, `expr--`, `()`, `.`, `?.`      |\n|     一元前缀运算符     | `-expr`, `!expr`, `~expr`, `++expr`, `--expr` |\n| 乘法（multiplicative） |              `*`, `/`, `%`, `~/`              |\n|          加法          |                   `+`, `-`                    |\n|          位移          |               `<<`, `>>`, `>>>`               |\n|          位与          |                      `&`                      |\n|         位异或         |                      `^`                      |\n|          位或          |                      `|`                      |\n|   关系运算和类型推断   |    `>=`, `<=`, `>`, `<`, `as`, `is`, `is!`    |\n|          等价          |                  `==`, `!=`                   |\n|         逻辑与         |                     `&&`                      |\n|         逻辑或         |                     `||`                      |\n|        可选判断        |                     `??`                      |\n|          条件          |            `expr1 ? expr2 : expr3`            |\n|          多级          |                     `..`                      |\n|          赋值          | `=`, `*=`, `/=`, `+=`, `-=`, `&=`, `^=`, etc  |\n\n运算符使用例子：\n```Dart\na++\na + b\na = b\na == b\nc ? a : b\na is T\n```\n\n上述表中的运算符优先从高到底排列。运算符优先级的作用：\n```Dart\nif ((n % i == 0) && (d % i ) == 0) ...\nif (n % i == 0 && d % i == 0) ...\n```\n\n### 7.1 算数运算符\n\nDart 支持的算术运算符：\n|  运算符 | 意义 |\n| ------: | :--- |\n|     `+` | 加   |\n|     `-` | 减   |\n| `-expr` | 负号 |\n|     `*` | 乘   |\n|     `/` | 除   |\n|    `~/` | 取商 |\n|     `%` | 取模 |\n\nDart 支持的递增/递减运算符：\n| 运算符  |                  意义                   |\n| :-----: | :-------------------------------------: |\n| `++var` |  `var = var + 1`(表达式的值是加后的值)  |\n| `var++` | `var = var + 1`（表达式的值是加前的值） |\n| `--var` | `var = var - 1`（表达式的值是减后的值） |\n| `var--` | `var = var - 1`（表达式的值是减前的值） |\n\n### 7.2 关系运算法\n\n| 运算符 |   意义   |\n| :----: | :------: |\n|  `==`  |   相等   |\n|  `!=`  |   不等   |\n|  `>`   |   大于   |\n|  `<`   |   小于   |\n|  `>=`  | 大于等于 |\n|  `<=`  | 小于等于 |\n\n### 7.3 类型推断运算符\n\n运行时用于类型校验：\n| 运算符 |               意义               |\n| :----: | :------------------------------: |\n|  `as`  | 类型推断(类型推断错误会抛出异常) |\n|  `is`  |    对象是指定类型时返回 true     |\n| `is!`  |   对象不是指定类型时返回 true    |\n\n### 7.4 赋值运算符\n\n|      |      |       |       |       |      |\n| ---- | ---- | ----- | ----- | ----- | ---- |\n| `=`  | `-=` | `/=`  | `%\\`  | `>>=` | `^=` |\n| `+=` | `*=` | `~/=` | `<<=` | `&=`  | `|=` |\n\n|       | 联合赋值  | 等价表达式  |\n| :---: | :-------: | :---------: |\n|  op   | `a op= b` | `a= a op b` |\n| 例子  | `a += b`  | `a = a + b` |\n\n### 7.5 逻辑运算符\n\n| 运算符  |  意义  |\n| :-----: | :----: |\n| `!expr` | 逻辑非 |\n|  `||`   | 逻辑或 |\n|  `&&`   | 逻辑与 |\n\n### 7.6 位移运算符\n\n| 运算符  |            意义            |\n| :-----: | :------------------------: |\n|   `&`   |            位与            |\n|   `|`   |            位或            |\n|   `^`   | 位异或（相同为0，不同为1） |\n| `~expr` |    位取反（0->1, 1->0）    |\n|  `<<`   |          左移一位          |\n|  `>>`   |          右移一位          |\n\n### 7.7 条件表达式\n\nDart 支持两个条件表达式：\n\n`condition ? expr1 : expr2`<br>\n如果条件为真，执行表达式1并返回结果；否则，执行表达式2并返回结果。\n\n`expr1 ?? expr2`<br>\n如果表达式1非空，返回其值；否则，执行表达式2并返回结果。\n\n### 7.8 多级表示法\n\n连续调用相同对象，使用 `..` 可以简化写法，减少使用临时变量。\n```Dart\nquerySelector('#confirm')\n  ..text = 'Confirm'\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirm!'));\n\n// 等价于以下写法\nvar button = querySelector('#confirm');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n```\n\n嵌套写法：\n```Dart\nfinal addressBook = (\n  AddressBookBuilder()\n    ..name = 'jenny'\n    ..email = 'jenny@example.com'\n    ..phone = (\n      PhoneNumberBuilder()\n        ..number = 'xxx-xxx-xxxx'\n        ..label = 'home'\n      .build();\n    )\n  .build();\n)\n```\n\n### 7.9 其它\n\n其他运算符：\n| 运算符 |         名字         |                  意义                   |\n| :----: | :------------------: | :-------------------------------------: |\n|  `()`  | Function application |              表示调用函数               |\n|  `[]`  |       访问数组       |      引用数组指定索引位置上的元素       |\n|  `.`   |     访问成员变量     |             表达式访问属性              |\n|  `?.`  |   条件访问成员变量   | 类似 `.`，支持空对象(类似 Swift 可选链) |\n\n## 8. 控制语句\n\nDart 控制流：\n* `if else`\n* `switch case`\n* `while` & `do-while`\n* `break` & `continue`\n* `for` 循环\n* `assert`\n\n另外，还有 `try-catch` 和 `throw`。\n\n### 8.1 If else\n\n```Dart\nif (isRaining()) {\n  you.bringRainCoat();\n} else if (isSnowing()) {\n  you.wearJacket();\n} else {\n  car.putTopDown();\n}\n```\n\n不同于 JS 的地方， Dart 条件必须是布尔值。\n\n### 8.2 For 循环\n\n```Dart\nvar msg = StringBuffer('Dart is fun');\nfor (var i = 0; i < 5; i++) {\n  msg.write('!');\n}\n```\n\n闭包捕获变量，并在内部拷贝，即使 `i` 改变也不会影响之前的值： \n```Dart\nvar callbacks = [];\nfor (var i = 0; i< 2; i++) {\n  callbacks.append(() => print(i));\n}\ncallbacks.forEach((c) => c()); // Dart 输出 0, 1； JS 输出 2, 2\n```\n\n### 8.3 While & do-while\n\n`while` 在进入循环体之前判断条件：\n```Dart\nwhile (!isDone()) {\n  doSomething();\n}\n```\n\n`do-while` 先执行循环体再判断条件：\n```Dart\ndo {\n  printLine();\n} while(!atEndOfPage())\n```\n\n### 8.4 Break & continue\n\n* `break` 跳出循环\n* `continue` 跳过当前循环\n\n### 8.5 Switch case\n\nDart switch 支持整型，字符串和编译期常量。对象必须是相同类型且该类没有重载 `==`。\n\n每个非空的 `case` 从句，必须要有 `break`。其他结束 `case` 的语句：`continue`, `return` 和 `throw`。\n\n非空的 `case` 中省略 `break` 会报编译错误：\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n  executeOpen();\n  // Error: Missing break\n  case 'CLOSE':\n  executeClose();\n  break;\n}\n```\n\n`case` 可以为空：\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n  case 'NOW_CLOSED':\n  executeNowClosed();\n  break;\n}\n```\n\nDart 支持 `continue` 加标签的方式控制代码执行：\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    continue nowClosed;\n  // Continues executing at the nowClosed label.\n\n  nowClosed:\n  case 'NOW_CLOSED':\n    // Runs for both CLOSED and NOW_CLOSED.\n    executeNowClosed();\n    break;\n}\n```\n`case` 内部可以定义局部变量，变量作用域仅限此代码块。\n\n### 8.6 断言\n\n开发者模式下，支持 `assert(condition, optionalMessage)` 终止程序。\n\n## 9. 异常处理\n\nDart 支持异常捕获机制。异常是程序运行过程中不可知的错误。如果程序没有捕获异常，抛出异常的[**isolate**](https://zhuanlan.zhihu.com/p/40069285) 会被挂起，通常情况下，isolate 和程序都会被终止。\n\n不同于 Java， Dart 的异常都是未经检查的。方法不会声明可能的异常，并且不需要去处理。\n\nDart 提供了 *Exception*，*Error* 以及其他的子类。开发者可以自定义异常。另外，Dart 程序可以把所有非空对象作为异常抛出。\n\n### 9.1 Throw\n\n抛出异常的例子：\n```Dart\nthrow FormatException('Expected at least 1 section');\n```\n\n抛出任意非空对象作为异常：\n```Dart\nthrow 'Out of llamas';\n```\n\n因为抛出异常是一个表达式，所以可以出现在任何需要表达式的位置：\n```Dart\nvoid distanceTo(Point point) => throw UnimplementedError();\n```\n\n### 9.2 Catch\n\n捕获异常能停止异常的传递，给程序处理异常的能力：\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlammas();\n}\n```\n\n对于能抛出多种异常类型的代码，可以使用多个 catch 从句。\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  // A specific exception\n  buyMoreLlamas();\n} on Exception catch (e) {\n  // Anything else that is an exception\n  print('Unknown exception: $e');\n} catch (e) {\n  // No specified type, handles all\n  print('Something really unknown: $e');\n  }\n```\n\n`catch()` 可以指定两个参数，第一个是抛出的异常，第二个是栈回溯([StackTrace](https://api.dart.dev/stable/dart-core/StackTrace-class.html))。\n```Dart\ntry {\n  // ···\n} on Exception catch (e) {\n  print('Exception details:\\n $e');\n} catch (e, s) {\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```\n\n在当前位置处理异常并继续传递，使用 `rethrow` 关键字：\n```Dart\nvoid misbehave() {\n  try {\n    dynamic foo = true;\n    print(foo++); // Runtime error\n  } catch (e) {\n    print('misbehave() partially handled ${e.runtimeType}.');\n    rethrow; // Allow callers to see the exception.\n  }\n}\n\nvoid main() {\n  try {\n    misbehave();\n  } catch (e) {\n    print('main() finished handling ${e.runtimeType}.');\n  }\n}\n```\n\n### 9.3 Finally\n\n无论是否抛出异常，使用finally子句，确保代码运行。如果 `catch` 没有匹配到异常，该异常会在 `finally` 后继续传播：\n```Dart\ntry {\n  breedMoreLlamas();\n} finally {\n  // Always clean up, even if an exception is thrown.\n  cleanLlamaStalls();\n}\n```\n\n`catch` 匹配到异常后，也会执行 `finally` 从句：\n```Dart\ntry {\n  breedMoreLlamas();\n} catch (e) {\n  print('Error: $e'); // Handle the exception first.\n} finally {\n  cleanLlamaStalls(); // Then clean up.\n}\n```\n\n## 10. 类\n\nDart 是面向对象语言，具有类和基于 mixin 的继承。每个对象都是类的实例，每个类继承自 *Object*。基于 *mixin* 的继承意味着类只有一个超类，但是类的成员可被多个类结构重用。\n\n### 10.1 使用类成员变量\n\n对象的成员由函数和数据组成。当一个方法被调用时，也就是调用对象的某个方法：通过对象的函数和数据获取方法。\n\n使用 `.` 引用实例变量或方法：\n```Dart\nvar p = Point(2, 2);\n\n// Set the value of the instance variable y.\np.y = 3;\n\n// Get the value of y.\nassert(p.y == 3);\n\n// Invoke distanceTo() on p.\nnum distance = p.distanceTo(Point(4, 4));\n```\n\n使用 `?.` 避免调用链为 null 时产生异常：\n```Dart\n// If p is non-null, set its y value to 4.\np?.y = 4;\n```\n\n### 10.2 使用构造函数\n\n使用构造器构造对象。构造器命名可以是 `ClassName` 或 `ClassName.identifier`。比如：\n```Dart\nvar p1 = Point(2, 2);\nvar p2 = Point.fromJson({'x': 1, 'y': 2});\n```\n\n以下代码效果相同，构造器前面多一个可选的 `new` 关键字：\n```Dart\nvar p1 = new Point(2, 2);\nvar p2 = new Point.fromJson({'x': 1, 'y': 2});\n```\n\n部分类提供了[常量构造器](https://dart.dev/guides/language/language-tour#constant-constructors)。构造器前加 `const` 修饰，以创建编译期常量：\n```Dart\nvar p = const ImmutablePoint(2, 2);\n```\n\n构造两个等价的编译期常量：\n```Dart\nvar a = const ImmutablePoint(1, 1);\nvar b = const ImmutablePoint(1, 1);\n\nassert(identical(a, b)); // They are the same instance!\n```\n\n如果能通过上下文推断出是常量，则可省略 `const`：\n```Dart\n// Lots of const keywords here.\nconst pointAndLine = const {\n  'point': const [const ImmutablePoint(0, 0)],\n  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],\n};\n\n// 可以简写为：\n// Only one const, which establishes the constant context.\nconst pointAndLine = {\n  'point': [ImmutablePoint(0, 0)],\n  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],\n};\n```\n\n如果一个常量构造器超出常量上下文，并且没用 `const` 修饰，则创建一个非常量对象：\n```Dart\nvar a = const ImmutablePoint(1, 1); // Creates a constant\nvar b = ImmutablePoint(1, 1); // Does NOT create a constant\n\nassert(!identical(a, b)); // NOT the same instance!\n```\n\n### 10.3 获取对象类型\n\n使用 Object `runtimeType` 属性，在运行时获取对象类型，返回 `Type` 对象：\n```Dart\nprint('The type of a is ${a.runtimeType}');\n```\n以上内容介绍了如何*使用*类，下面介绍如何实现类。\n\n### 10.4 实例变量\n\n如何声明一个实例变量：\n```Dart\nclass Point {\n  num x; // Declare instance variable x, initially null.\n  num y; // Declare y, initially null.\n  num z = 0; // Declare z, initially 0.\n}\n```\n未初始化的实例变量默认为 `null`。\n\n所以实例变量隐式生成 *getter* 方法。所有实例变量（除了 final）隐式生成 *setter* 方法。\n```Dart\nclass Point {\n  num x;\n  num y;\n}\n\nvoid main() {\n  var point = Point();\n  point.x = 4; // Use the setter method for x.\n  assert(point.x == 4); // Use the getter method for x.\n  assert(point.y == null); // Values default to null.\n}\n```\n关于实例变量的生命周期，实例变量在构造器和初始化器执行之前就已创建，如果声明实例变量的时候手动初始化了，那么初始化也在此时完成。\n\n### 10.5 构造函数\n\n构造器写法：声明一个函数，函数名和类名相同。最常见的构造器形式就是生成构造器，会创建类的一个新实例：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(num x, num y) {\n    // There's a better way to do this, stay tuned.\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n`this` 关键字引用当前实例。\n\n构造器的一个语法糖写法：\n```Dart\nclass Point {\n  num x, y;\n\n  // Syntactic sugar for setting x and y\n  // before the constructor body runs.\n  Point(this.x, this.y);\n}\n```\n\n#### 默认构造器 <!-- omit in toc -->\n\n如果没有生命构造器，Dart 会默认生成一个构造器。此构造器没有参数，并调用父类的不带参构造器。\n\n#### 构造器不继承 <!-- omit in toc -->\n\n构造器不支持继承。\n\n#### 带名字的构造器 <!-- omit in toc -->\n\n如果需要创建多个构造器，使用带名字的构造器：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  // Named constructor\n  Point.origin() {\n    x = 0;\n    y = 0;\n  }\n}\n```\n\n#### 调用非默认的父类构造器 <!-- omit in toc -->\n\n默认情况下，子类的构造器调用父类不带名字和参数的构造器，且在子类构造器的头部调用。如果使用了[初始化列表](https://dart.dev/guides/language/language-tour#initializer-list)，此操作会在父类调用前执行。三者顺序：\n1. 初始化列表\n2. 父类无参构造器\n3. 当前类无参构造器\n\n\n如果父类没有无名无参的构造器，必须手动调用父类的一个构造器。在 `:` 和函数体之间指定父类的构造器。比如：\n```Dart\nclass Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print('in Person');\n  }\n}\n\nclass Employee extends Person {\n  // Person does not have a default constructor;\n  // you must call super.fromJson(data).\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print('in Employee');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // Prints:\n  // in Person\n  // in Employee\n  if (emp is Person) {\n    // Type check\n    emp.firstName = 'Bob';\n  }\n  (emp as Person).firstName = 'Bob';\n}\n```\n\n#### 初始化列表 <!-- omit in toc -->\n\n除了调用父类构造器外，还可以在构造器函数体之前初始化实例变量。多个初始化之间用逗号分隔：\n```Dart\nPoint.fromJson(Map<String, num> json) : x = json['x'], y = json['y'] {\n  print('In Point.fromJson(): ($x, $y)');\n}\n```\n\n开发模式下，初始化列表中可使用断言：\n```Dart\nPoint.withAssert(this.x, this.y) : assert(x >= 0) {\n  print('In Point.withAssert(): ($x, $y)');\n}\n```\n\n设置 final 字段时，初始化列表较为便利。比如：\n```Dart\nimport 'dart:math';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);\n}\n```\n\n#### 重定向构造器 <!-- omit in toc -->\n\n部分构造器的作用只是调用当前类的其它构造器。重定向构造器写法：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  Point.alongzXAxis(num x) : this(x, 0);\n}\n```\n\n#### 常量构造器 <!-- omit in toc -->\n\n常量构造器用来表示类生成的实例不会改变。用 `const` 修饰构造器且全部实例变量使用 `final`。\n```Dart\nclass ImmutablePoint {\n  static final ImmutablePoint origin = const ImmutablePoint(0, 0);\n\n  final num x, y;\n\n  const ImmutablePoint(this.x, this.y);\n}\n```\n常量构造器不一定总是创建常量。更多信息查看[文档](https://dart.dev/guides/language/language-tour#using-constructors)。\n\n#### 工厂构造器 <!-- omit in toc -->\n\n关键字 `factory` 修饰的构造器表示，此构造器不会每次都创建新的实例。比如，工厂构造器可能返回一个缓存中的实例或者子类的实例。\n\n工厂构造器写法：\n```Dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n```\n\n调用工厂构造器同其他构造器方法一样：\n```Dart\nvar logger = Logger('UI');\nlogger.log('Button clicked');\n```\n\n### 10.6 方法\n\n方法是定义在类内部的函数。\n\n#### 实例方法 <!-- omit in toc -->\n\n对象的实例方法内部可访问实例变量和 `this`。例子如下：\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  num distanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n```\n\n#### Getters & setters <!-- omit in toc -->\n\nGetters 和 setters 是特殊的方法，能读写对象属性。实例变量默认都有 getter，通常也有 setter。也可用 `get` 和 `set` 自己实现：\n```Dart\nclass Rectangle {\n  num left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // Define two calculated properties: right and bottom.\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n  assert(rect.left == 3);\n  rect.right = 12;\n  assert(rect.left == -8);\n}\n```\n\n#### 抽象方法 <!-- omit in toc -->\n\n实例方法，getter 和 setter 都能定义为抽象方法，当前类只定义接口，实现交由其它类。抽象方法只能定义在[抽象类](https://dart.dev/guides/language/language-tour#abstract-classes)中。\n\n定义抽象方法，用分号替代函数体：\n```Dart\nabstract class Doer {\n  void soSomething();\n}\n\nclass EffectiveDoer extends Doer {\n  void soSomething() {\n\n  }\n}\n```\n\n### 10.7 抽象类\n\n关键字 `abstract` 定义*抽象类*（不能被实例化）。抽象类多用于接口定义，实现较多的情况。定义[工厂构造器](https://dart.dev/guides/language/language-tour#factory-constructors)可实例化抽象类。\n\n抽象类通常都有抽象方法，例子如下：\n```Dart\n// This class is declared abstract and thus\n// can't be instantiated.\nabstract class AbstractContainer {\n  // Define constructors, fields, methods...\n\n  void updateChildren(); // Abstract method.\n}\n```\n\n### 10.8 隐式接口\n\n类隐式定义了一个接口列表，包括当前类实现的所有成员变量。类 A 在不继承类 B 的情况下，实现类 B 的接口，从而调用类 B 的成员。\n\n声明类的时候用 `implements` 并提供所需的 APIs，从而实现一个或多个接口：\n```Dart\nclass Person {\n  final _name;\n\n  Person(this._name);\n\n  String greet(String who) => 'Hello, $who. I am $_name';\n}\n\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy'))); // 'Hello, Bob. I am $Kathy'\n  print(geetBob(Impostor())); // 'Hi Bob. Do you know who I am?'\n}\n```\n\n一个类实现多个接口：\n```Dart\nclass Point implements Comparable, Location {...}\n```\n\n### 10.9 扩展类\n\n使用 `extends` 创建子类，`super` 指向父类：\n```Dart\nclass Television {\n  void turnOn() {\n    _illuminateDisplay();\n    _activateIrSensor();\n  }\n  // ···\n}\n\nclass SmartTelevision extends Television {\n  void turnOn() {\n    super.turnOn();\n    _bootNetworkInterface();\n    _initializeMemory();\n    _upgradeApps();\n  }\n  // ···\n}\n```\n\n#### 重写成员 <!-- omit in toc -->\n\n子类可重载实例方法、getters 和 setters。`@override` 关键字表示成员被重载：\n```Dart\nclass SmartTelevision extends Television {\n  @override\n  void turnOn() {...}\n  // ···\n}\n```\n\n#### 可重载运算符 <!-- omit in toc -->\n\n下表中运算符支持重载：\n|       |       |       |       |\n| :---: | :---: | :---: | :---: |\n|  `<`  |  `+`  |  `|`  | `[]`  |\n|  `>`  |  `/`  |  `^`  | `[]=` |\n| `<=`  | `~/`  |  `&`  |  `~`  |\n| `>=`  |  `*`  | `<<`  | `==`  |\n|  `-`  |  `%`  | `>>`  |       |\n\n重载 `+`, `-` 运算符：\n```Dart\nclass Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}\n```\n\n#### noSuchMethod() <!-- omit in toc -->\n\n重载 `noSuchMethod()` 方法，及时处理调用对象不存在的实例变量和方法：\n```Dart\nclass A {\n  // Unless you override noSuchMethod, using a\n  // non-existent member results in a NoSuchMethodError.\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print('You tried to use a non-existent member: ' +\n        '${invocation.memberName}');\n  }\n}\n```\n\n不可调用对象未实现的方法，除非实现以下任意情况：\n* 消息接受者有静态类型 `dynamic`\n* 接收器有一个定义未实现方法的静态类型（包括抽象类型），接收器的动态类型有一个noSuchMethod（）实现，它与Object类中的实现不同。\n\n### 10.10 枚举类型\n\n枚举表示固定数量的常量值。\n\n#### 用法 <!-- omit in toc -->\n\n使用 `enum` 关键字声明枚举类型：\n```Dart\nenum Color { red, green, blue }\n```\n\n枚举值有个 `index` getter，返回该值在枚举声明中的位置，从 0 开始。第一个值为 0，第二个值为 1...\n\n使用 `values` 在运行时获取所有枚举值：\n```Dart\nList<Color> colors = Color.values;\nassert(colors[2] == Color.blue);\n```\n\n枚举在 switch case 中使用：\n```Dart\nvar aColor = Color.red;\nswitch (aColor) {\n  case Color.red:\n  print('red');\n  break;\n  case Color.green:\n  print('green');\n  break\n  default:\n  print(aColor);\n}\n```\n\n枚举类型的局限性：\n* 不可子类化，*mix in*，或实现\n* 不能显示实例一个枚举类型\n\n### 10.11 类添加特性\n\nMixins 是一种将类代码共享给其他类的功能。\n\n`with` 关键字*使用* mixin 功能。例子如下：\n```Dart\nclass Musician extends Performer with Musical {\n\n}\n\nclass Maestro extends Person with Musical, Aggressive, Demented {\n  Maestro(String maestroname) {\n    name = maestroName;\n    canConduct = true;\n  }\n}\n```\n\n*实现* mixin：创建一个 Object 子类，并且不声明构造器。另外，如果不想该类被当作普通的类，用 `mixin` 关键字代替 `class`。比如：\n```Dart\nmixin Musical {\n  bool canPlayPiano = false;\n  bool canCompose = false;\n  bool canConduct = false;\n\n  void entertainMe() {\n    if (canPlayPiano) {\n      print('Playing piano');\n    } else if (canConduct) {\n      print('Waving hands');\n    } else {\n      print('Humming to self');\n    }\n  }\n}\n```\n\n要指定只有某些类型可以使用mixin，使用 `on` 指定所需的超类：\n```Dart\nmixin MusicalPerformer on Musician {\n  // ... \n}\n```\n\n### 10.12 类变量和方法\n\n使用 `static` 关键字创建静态变量和方法。静态方法和变量都是面向类型的，实例无法访问。\n\n#### 静态方法 <!-- omit in toc -->\n\n```Dart\nclass Queue {\n  static const initialCapacity = 16;\n}\n\nvoid main() {\n  assert(Queue.initialCapacity == 16);\n}\n```\n\n静态变量只有在使用时才会被初始化。\n\n#### 静态方法 <!-- omit in toc -->\n\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 < distance && distance < 2.9);\n  print(distance);\n}\n```\n\n## 11. 泛型\n\n数组类型声明：`List<E>`，其中 <...> 将类型标记为*泛型*，即，类型内部有个形式上的参数。通常的命名规范，泛型参数名字为单字符，如 E, T, S, K 和 V。\n\n### 11.1 为什么使用泛型\n\n泛型要求代码是类型安全的，但是使用泛型有很多好处：\n* 正确使用泛型使代码结构更好\n* 减少重复代码\n\n声明一个只含字符串的数组：`List<String>`。\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nnames.add(42);//编译报错\n```\n\n受益于静态分析的前提下，泛型能为多个类型共享一个接口。比如：\n```Dart\n// 缓存 Object\nabstract class ObjectCache {\n  Object getByKey(String key);\n  void setByKey(String key, Object value);\n}\n\n// 缓存 String\nabstract class StringCache {\n  String getByKey(String key);\n  void setByKey(String key, String value);\n}\n\n// 使用泛型\nabstract class Cache<T> {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n```\n\n### 11.2 使用集合字面值\n\n```Dart\nvar names = <String>['Seth', 'Kathy', 'Lars'];\nvar uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};\nvar pages = <String, String>{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n};\n```\n\n### 11.3 使用带参数化类型的构造函数\n\n使用构造器时，指定一个或多个类型，类型放在 `<>` 中间。比如：\n```Dart\nvar nameSet = Set<String>.from(names);\n```\n\n### 11.4 泛型集合\n\nDart 泛型类型是*具体化的*，这意味着泛型变量在运行时携带类型信息。例子如下：\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nprint(names is List<String>); // true\n```\n\n### 11.5 泛型约束\n\n当定义泛型，可使用 `extends` 约束泛型：\n```Dart\nclass Foo<T extends SomeBaseClass> {\n  String toString() => \"Instance of 'Foo<$T>'\";\n}\nclass Extender extends SomeBaseClass {}\n\nvar someBaseClassFoo = Foo<SomeBaseClass>();\nvar extenderFoo = Foo<Extender>();\n```\n\n不指定泛型参数：\n```Dart\nvar foo = Foo();\nprint(foo); // Instance of 'Foo<SomeBaseClass>'\n```\n\n### 11.6 使用泛型方法\n\nDart 支持泛型方法或函数：\n```Dart\nT first<T>(List<T> ts) {\n  T tmp = ts[0];\n  return tmp;\n}\n```\n上述代码展示了函数泛型参数可使用的位置：\n* 函数返回值\n* 函数参数\n* 内部布局变量\n\n## 12. 库\n\n使用 `import` 和 `library` 指令创建模块化和可共享的代码。库不仅提供 APIs，还是私有的作用域块：下划线开头的标识符仅在库内部可见。每个 Dart 应用都是一个库，即使并不使用 `library` 指令。\n\n库可作为包(package)发布。\n\n### 12.1 使用库\n\n使用 `import`，在一个库中指定另一个库的命名空间。\n\n举个例子，Dart 网页应用通常使用 `dart:html` 库，可以如下导入：\n```Dart\nimport 'dart:html';\n```\n\n`import` 指令后面的参数是指向目标库的 URI。对于 Dart 自带的库，使用 `dart:` 作为 sheme。其他库，使用文件路径或 `package:` scheme。包管理工具提供的库使用 `package:` scheme。比如：\n```Dart\nimport 'package:test/test.dart';\n```\n\n#### 指定库前缀 <!-- omit in toc -->\n\n当引入的两个库有冲突的标识符，可以为两个库指定前缀，从而避免冲突。例子如下：\n```Dart\nimport 'package:lib1/lib1.dart';\nimport 'package:lib2/lib2.dart' as lib2;\n\nElement element1 = Element();\n\nlib2.Element element2 = lib2.Element();\n```\n\n#### 导入库的部分接口 <!-- omit in toc -->\n\nDart 支持导入库的部分功能，比如：\n```Dart\nimport 'package:lib1/lib1.dart' show foo;\n\nimport 'package:lib2/lib2.dart' hide foo;\n```\n\n#### 库懒加载 <!-- omit in toc -->\n\n库的按需加载。以下场景可以使用库按需加载：\n* 加快应用启动时间\n* A/B test\n* 加载较少使用的库\n\n实现懒加载，首先要用 `deferred as` 导入：\n```Dart\nimport 'package:greetings/hello.dart' deferred as hello;\n```\n\n需要使用的地方，用库的标识调用 `loadLibrary()`：\n```Dart\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n```\n上述代码中，`await` 关键字会阻塞代码直到库加载完成。更多信息查看[异步操作](https://dart.dev/guides/language/language-tour#asynchrony-support)。\n\n多次调用 `loadLibrary()` 加载同一个库不会出错，且库只会被加载一次。\n\n使用库的懒加载时，记住以下几点：\n* 懒加载的库中的常量，只有在懒加载完成后才能作为常量使用\n* 不能使用懒加载库中的类型。而应该将接口类型放到第三方库中，让目标库和当前文件共同导入第三方库\n* 开发者用 `deferred as namespace` 定义懒加载库的命名空间，Dart 在命名空间后面隐式插入 `loadLibrary()`。`loadLibrary()` 返回 *Future*。\n\n### 12.2 实现库\n\n实现一个库，请查看 [Create Library Package](https://dart.dev/guides/libraries/create-library-packages)：\n* 如何组织库的源码\n* 如何使用 `export` 指令\n* 何时使用 `part` 指令\n* 何时使用 `library` 指令\n\n## 13. 异步\n\nDart 库中有很多返回值为 `Future` 和 `Stream` 的函数。这些函数是异步函数：派发一个耗时任务后直接返回，并不等待任务完成。\n\n`async` 和 `await` 关键字实现异步编程，让异步任务像同步的代码顺序执行。\n\n### 13.1 处理 Future\n\n两种方式处理 Future：\n* 使用 `async` 和 `await`\n* 使用 Future API，查看 [the library tour](https://dart.dev/guides/libraries/library-tour#future)\n\n`async` 和 `await` 使用：\n```Dart\nawait lookUpVersion();\n```\n\n使用 `await` 的代码，必须要写在 *async* 函数内：\n```Dart\nFuture checkVersion() async {\n  var version = await lookUpVersion();\n}\n```\n\n`try`, `catch` 和 `finally` 用于处理 `await` 代码中的错误并执行清理代码：\n```Dart\ntry {\n  version = await lookUpVersion();\n} catch (e) {\n}\n```\n\n一个异步函数中，可使用多个 `await`，下述代码中，使用了三个 await 处理任务：\n```Dart\nvar entrypoint = await findEntrypoint();\nvar exitCode = await runExecutable(entrypoint, args);\nawait flushThenExit(exitCode);\n```\n\n在 `await expr` 中，`expr` 的值通常是 Future，如果不是，系统会自动用 Future 包装。该 Future 对象表示一个会返回对象的 promise。`await expr` 的值就是最终返回的对象。Await 表达式会阻塞代码直到返回最终的对象。\n\n**使用 `await` 的时候报了编译错误，确保 `await` 实在异步函数中。** 比如，想在 `main()` 函数中使用 `await`，那么函数体必须标记为 `async`：\n```Dart\nFuture main() async {\n  checkVersion();\n  print('In main: version is ${await lookUpVersion()}');\n}\n```\n\n### 13.2 声明异步函数\n\n异步函数的函数体用 `async` 标记。\n\n为函数添加 `async` 关键字，使得函数返回 Future。如下例子：\n```Dart\nString lookUpVersion() => '1.0.0';\n\nFuture<String> lookUpVersion() async => '1.0.0';\n```\n从上述代码可知，Dart 自动用 Future 包装返回值。\n\n如果函数没有实际返回值，就返回 `Future<void>`。\n\n### 13.3 处理流\n\n两种方式从流(Stream)中获取值：\n* 用 `async` 和 *asynchronous for loop*(`await for`)\n* 使用 [Stream API](https://dart.dev/guides/libraries/library-tour#stream)\n\n异步循环格式：\n```Dart\nawait for (varOrType identifier in expression) {\n\n}\n```\n上述代码中，`expression` 必须是 Stream 类型。代码执行顺序：\n1. 等待流释放一个值\n2. 变量被赋值为 (1) 释放的值，并执行循环体\n3. 重复步骤(1), (2)，直到流被关闭\n\n使用 `break` 或 `return` 停止监听流，执行命令后会跳出循环并对流取消订阅\n\n**当实现一个异步循环的时候，报编译错误，确保 `await for` 代码实在异步函数中。** 比如，在 `main()` 函数中使用异步循环，将 `main()` 函数体标记为 `async`：\n```Dart\nFuture main() async {\n  await for (var request in requestServer) {\n    handleRequest(request);\n  }\n}\n```\n\n更多异步编程信息，查看 [*dart:async*](https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming)。\n\n## 14. 生成器\n\n用 *生成器函数* 惰性生成一些列值。Dart 自带两种生成器：\n* **Synchronous** 生成器：返回一个 [*Iterable*](https://api.dart.dev/stable/dart-core/Iterable-class.html) 对象\n* **Asynchronous** 生成器：返回一个 [*Stream*](https://api.dart.dev/stable/dart-async/Stream-class.html) 对象\n\n实现 **synchronous** 生成器函数方法：用 `sync*` 标记函数体，并用 `yield` 语句发送值：\n```Dart\nIterable<Int> naturalTo(int n) sync* {\n  int k = 0;\n  while (k < n) {\n    yield k++;\n  }\n}\n```\n\n实现 **asynchronous** 生成器函数方法：用 `async*` 标记函数体，并用 `yield` 发送值：\n```Dart\nStream<Int> asynchronousNaturalTo(int n) async* {\n  int k = 0;\n  while (k < n) {\n    yield k++;\n  }\n}\n```\n\n递归生成器，用 `yield*` 改进性能：\n```Dart\nIterable<Int> naturalsDownFrom(int n) sync* {\n  if (n > 0) {\n    yield n;\n    yield* naturalsDownFrom(n - 1);\n  }\n}\n```\n\n## 15. 可调用的类\n\n类实现 `call()` 方法后，该类的实例可以像函数一样被调用。\n\n如下例子，`WannabeFunction` 类实现了 call() 函数：\n```Dart\nclass WannabeFunction {\n  call(String a, String b, String c) {\n    return '$a $b $c!';\n  }\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf('Hi', 'there', 'gang');\n  print(out);\n}\n```\n\n## 16. 独立性\n\n多数计算机包括手机都有多核 CPU。开发者通常用共享内存的线程并发执行程序，以提高 CPU 利用率。然而，共享状态的并发执行更易出错，也使得代码更加复杂。\n\nDart 用 *isolate* 替代线程。每个 isolate 有自己的堆内存，以确保 isolates 之间不会共享状态。\n\n更多信息查看 [dart:isolate library document](https://api.dart.dev/stable/dart-isolate)。\n\n## 17. 类型定义\n\nDart 中，函数同字符串和数值一样都是对象。*Typedef* 或者说 *funtion-type alias* 给函数定义个名字，在其它地方使用。类型定义会保留类型信息。\n\n```Dart\nclass SortedCollection {\n  Function compare;\n\n  SortedCollection(Function f) {\n    compare = f;\n  }\n}\n\nint sort(Object a, Object b) => 0;\n\nvoid main {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function);\n}\n```\n\n使用类型定义后：\n```Dart\ntypedef Compare = int Function(Object a, Object b);\n\nclass SortedCollection {\n  Compare compare;\n\n  SortedCollection(this.compare);\n}\n\nint sort(Object a, Object b) => 0;\n\nmain {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function); // true\n  print(coll.compare is Compare); // true\n}\n```\n\n类型定义结合泛型：\n```Dart\ntypedef Compare<T> = int Function(T a, Tb);\n\nint sort(int a, int b) => a - b;\n\nmain {\n  print(sort is Compare<Int>);\n}\n```\n\n## 18. 元数据\n\n元数据标注写法：`@` 开头，后跟着编译期常量或者常量构造器。\n\nDart 中两种标注对所有代码使用: `@deprecated` 和 `override`。\n```Dart\nclass Television {\n  @deprecated\n  void activate {\n\n  }\n}\n```\n\n自定义元数据标注：\n```Dart\nlibrary todo;\n\nclass Todo {\n  final String who;\n  final String what;\n\n  const Todo(this.who, this.what);\n}\n```\n使用自定义的元数据：\n```Dart\nimport 'todo.dart';\n\n@Todo('seth', 'make this do something')\nvoid doSomething() {\n\n}\n```\n元数据可以出现在以下指令前：库，类，类型定义，类型参数，构造器，工厂方法，字段，参数，变量声明，导入导出。运行时可通过 reflection 获取元数据。\n\n## 19. 注释\n\nDart 支持单行、多行和文档注释。\n\n## 20. 小结\n\n此文档摘录了 Dart 中较为通用的特性。此外，更多新特性正在开发，尽量兼容当前代码。下一步：[language specification](https://dart.dev/guides/language/spec) 和 [Effective Dart](https://dart.dev/guides/language/effective-dart)。\n\n了解更多关于 Dart 核心库，查看 [A Tour of the Dart Libraries](https://dart.dev/guides/libraries/library-tour)。\n\n","source":"_posts/A-tour-of-the-dart-language.md","raw":"---\ntitle: Dart 入门 (译)\ntags: \n- dart\n- flutter\ndate: 2019-07-24 23:33:48\n---\n\n本文列出了 Dart 语言的每个主要功能的用法，从变量和运算符到类库。本文适用于有其他编程语言经验的开发者。\n想学习更多 Dart 核心库的，请查看此[文档](https://dart.dev/guides/libraries/library-tour)。想学习更多语言细节的，请查看此[文档](https://dart.dev/guides/language/spec)。\n<!-- more -->\n\n目录\n- [1. 一段基础的 Dart 程序](#1-%e4%b8%80%e6%ae%b5%e5%9f%ba%e7%a1%80%e7%9a%84-dart-%e7%a8%8b%e5%ba%8f)\n- [2. 重要概念](#2-%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5)\n- [3. 关键字](#3-%e5%85%b3%e9%94%ae%e5%ad%97)\n- [4. 变量](#4-%e5%8f%98%e9%87%8f)\n  - [4.1 默认值](#41-%e9%bb%98%e8%ae%a4%e5%80%bc)\n  - [4.2 Final 和 const 关键字](#42-final-%e5%92%8c-const-%e5%85%b3%e9%94%ae%e5%ad%97)\n- [5. 自带类型](#5-%e8%87%aa%e5%b8%a6%e7%b1%bb%e5%9e%8b)\n  - [5.1 数值](#51-%e6%95%b0%e5%80%bc)\n  - [5.2 字符串](#52-%e5%ad%97%e7%ac%a6%e4%b8%b2)\n  - [5.3 布尔](#53-%e5%b8%83%e5%b0%94)\n  - [5.4 数组](#54-%e6%95%b0%e7%bb%84)\n  - [5.5 集](#55-%e9%9b%86)\n  - [5.6 表](#56-%e8%a1%a8)\n  - [5.7 Runes](#57-runes)\n  - [5.8 符号](#58-%e7%ac%a6%e5%8f%b7)\n- [6. 函数](#6-%e5%87%bd%e6%95%b0)\n  - [6.1 可选参数](#61-%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0)\n  - [6.2 main() 函数](#62-main-%e5%87%bd%e6%95%b0)\n  - [6.3 一等公民函数](#63-%e4%b8%80%e7%ad%89%e5%85%ac%e6%b0%91%e5%87%bd%e6%95%b0)\n  - [6.4 匿名函数](#64-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0)\n  - [6.5 作用域](#65-%e4%bd%9c%e7%94%a8%e5%9f%9f)\n  - [6.6 词法闭包](#66-%e8%af%8d%e6%b3%95%e9%97%ad%e5%8c%85)\n  - [6.7 函数的等价性](#67-%e5%87%bd%e6%95%b0%e7%9a%84%e7%ad%89%e4%bb%b7%e6%80%a7)\n  - [6.8 返回值](#68-%e8%bf%94%e5%9b%9e%e5%80%bc)\n- [7. 运算符](#7-%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.1 算数运算符](#71-%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.2 关系运算法](#72-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e6%b3%95)\n  - [7.3 类型推断运算符](#73-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.4 赋值运算符](#74-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.5 逻辑运算符](#75-%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.6 位移运算符](#76-%e4%bd%8d%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6)\n  - [7.7 条件表达式](#77-%e6%9d%a1%e4%bb%b6%e8%a1%a8%e8%be%be%e5%bc%8f)\n  - [7.8 多级表示法](#78-%e5%a4%9a%e7%ba%a7%e8%a1%a8%e7%a4%ba%e6%b3%95)\n  - [7.9 其它](#79-%e5%85%b6%e5%ae%83)\n- [8. 控制语句](#8-%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5)\n  - [8.1 If else](#81-if-else)\n  - [8.2 For 循环](#82-for-%e5%be%aa%e7%8e%af)\n  - [8.3 While & do-while](#83-while--do-while)\n  - [8.4 Break & continue](#84-break--continue)\n  - [8.5 Switch case](#85-switch-case)\n  - [8.6 断言](#86-%e6%96%ad%e8%a8%80)\n- [9. 异常处理](#9-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86)\n  - [9.1 Throw](#91-throw)\n  - [9.2 Catch](#92-catch)\n  - [9.3 Finally](#93-finally)\n- [10. 类](#10-%e7%b1%bb)\n  - [10.1 使用类成员变量](#101-%e4%bd%bf%e7%94%a8%e7%b1%bb%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f)\n  - [10.2 使用构造函数](#102-%e4%bd%bf%e7%94%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [10.3 获取对象类型](#103-%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b)\n  - [10.4 实例变量](#104-%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f)\n  - [10.5 构造函数](#105-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [10.6 方法](#106-%e6%96%b9%e6%b3%95)\n  - [10.7 抽象类](#107-%e6%8a%bd%e8%b1%a1%e7%b1%bb)\n  - [10.8 隐式接口](#108-%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3)\n  - [10.9 扩展类](#109-%e6%89%a9%e5%b1%95%e7%b1%bb)\n  - [10.10 枚举类型](#1010-%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b)\n  - [10.11 类添加特性](#1011-%e7%b1%bb%e6%b7%bb%e5%8a%a0%e7%89%b9%e6%80%a7)\n  - [10.12 类变量和方法](#1012-%e7%b1%bb%e5%8f%98%e9%87%8f%e5%92%8c%e6%96%b9%e6%b3%95)\n- [11. 泛型](#11-%e6%b3%9b%e5%9e%8b)\n  - [11.1 为什么使用泛型](#111-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b)\n  - [11.2 使用集合字面值](#112-%e4%bd%bf%e7%94%a8%e9%9b%86%e5%90%88%e5%ad%97%e9%9d%a2%e5%80%bc)\n  - [11.3 使用带参数化类型的构造函数](#113-%e4%bd%bf%e7%94%a8%e5%b8%a6%e5%8f%82%e6%95%b0%e5%8c%96%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)\n  - [11.4 泛型集合](#114-%e6%b3%9b%e5%9e%8b%e9%9b%86%e5%90%88)\n  - [11.5 泛型约束](#115-%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f)\n  - [11.6 使用泛型方法](#116-%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95)\n- [12. 库](#12-%e5%ba%93)\n  - [12.1 使用库](#121-%e4%bd%bf%e7%94%a8%e5%ba%93)\n  - [12.2 实现库](#122-%e5%ae%9e%e7%8e%b0%e5%ba%93)\n- [13. 异步](#13-%e5%bc%82%e6%ad%a5)\n  - [13.1 处理 Future](#131-%e5%a4%84%e7%90%86-future)\n  - [13.2 声明异步函数](#132-%e5%a3%b0%e6%98%8e%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0)\n  - [13.3 处理流](#133-%e5%a4%84%e7%90%86%e6%b5%81)\n- [14. 生成器](#14-%e7%94%9f%e6%88%90%e5%99%a8)\n- [15. 可调用的类](#15-%e5%8f%af%e8%b0%83%e7%94%a8%e7%9a%84%e7%b1%bb)\n- [16. 独立性](#16-%e7%8b%ac%e7%ab%8b%e6%80%a7)\n- [17. 类型定义](#17-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89)\n- [18. 元数据](#18-%e5%85%83%e6%95%b0%e6%8d%ae)\n- [19. 注释](#19-%e6%b3%a8%e9%87%8a)\n- [20. 小结](#20-%e5%b0%8f%e7%bb%93)\n\n\n## 1. 一段基础的 Dart 程序\n从以下代码片段感受下 Dart 语言的特性：\n\n```Dart\n// Define a function.\nprintIteger(int number) {\n    print('The number is $number');\n}\n\n// This is where the app starts executing.\nmain() {\n    var number = 42; // Declare and initialize a variable.\n    printInteger(number); // Call a function.\n}\n```\n这段程序使用的特性适用于其他所有 Dart 应用：\n\n// This is a comment.<br>\n一个单行注释。另外，Dart 也支持多行和文档注视。更多信息看[注释文档](https://dart.dev/guides/language/language-tour#comments)。\n\nint<br>\nDart 自带类型之一，其他的还有 *String*, *List* 和 *bool*。\n\n42<br>\n数值字面值，编译时期常量。\n\nprint()<br>\n打印输出。\n\n'...' 或者 \"...\"<br>\n字符串字面值。\n\n$variableNmae 或者 ${variableName}<br>\n字符串差值写法。更多请查看[文档](https://dart.dev/guides/language/language-tour#strings)。\n\nmain()<br>\nApp 执行入口，每个应用必须有。更多信息查看[文档](https://dart.dev/guides/language/language-tour#the-main-function)。\n\n## 2. 重要概念\n\n学习 Dart 过程中，牢记以下概念：<br>\n* 任何可以存到变量中的都是对象，每个对象都是类的实例。数值、函数和 `null` 都是对象。所有对象都继承自 [Object](https://api.dart.dev/stable/dart-core/Object-class.html) 类。\n* 虽然 Dart 是强类型的，但类型声明是可选的，因为 Dart 有类型推断。上述代码中， `number` 并没有声明类型，被自动推断成 `int`j。可以使用[特定的动态类型](https://dart.dev/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed)，来声明任意类型的变量。\n* Dart 支持泛型，比如 `List<int>` 和 `List<dynamic>`。\n* Dart 支持将函数声明在类内部（*实例方法*）和外部（*静态方法*），也支持*嵌套函数*。\n* 类似的，Dart 也支持将变量声明在类内部（*实例变量*）和外部（*静态变量*）。实例变量也叫做域(*field*)或属性(*property*)。\n* 不同于 Java，Dart 没有 `public`, `protected` 和 `private` 关键字。可以使用 `_` 开头的标识符来表示变量是库内私有的。更多信息请看[文档](https://dart.dev/guides/language/language-tour#libraries-and-visibility)。\n* 标识符以字母和下划线开头，后面可以跟字母数字下划线。\n* Dart 有表达式(*expressions*)和语句(*statements*)。\n* Dart 工具有两种报错类型：*警告*和*错误*。警告表示代码运行结果可能不同于期望，但不会使程序退出。错误分为编译期和运行时。编译器错误会导致程序无法启动，运行时错误会导致程序运行时抛出异常。\n\n## 3. 关键字\n\n|                        |                      |                        |                     |\n| :--------------------- | :------------------: | :--------------------: | ------------------: |\n| abstract<sup>2</sup>   | dynamic<sup>2</sup>  | implements<sup>2</sup> |    show<sup>1</sup> |\n| as<sup>2</sup>         |         else         |   import<sup>2</sup>   |  static<sup>2</sup> |\n| assert                 |         enum         |           in           |               super |\n| async<sup>1</sup>      |  export<sup>2</sup>  | interface<sup>2</sup>  |              switch |\n| await<sup>3</sup>      |       extends        |           is           |    sync<sup>1</sup> |\n| break                  | external<sup>2</sup> |  library<sup>2</sup>   |                this |\n| case                   | factory<sup>2</sup>  |   mixin<sup>2</sup>    |               throw |\n| catch                  |        false         |          new           |                true |\n| class                  |        final         |          null          |                 try |\n| const                  |       finally        |     on<sup>1</sup>     | typedef<sup>2</sup> |\n| continue               |         for          |  operator<sup>2</sup>  |                 var |\n| convariant<sup>2</sup> | Function<sup>2</sup> |    part<sup>2</sup>    |                void |\n| default                |   get<sup>2</sup>    |        rethrow         |               while |\n| deferred<sup>2</sup>   |   hide<sup>1</sup>   |         return         |                with |\n| do                     |          if          |    set<sup>2</sup>     |   yield<sup>3</sup> |\n\n尽量避免使用以上关键字作为标识符。如果不可避免需要使用，可以用上角标标记：\n* 角标 1 单词是上下文相关的，只有在特定位置才有意义。他们可以在任意位置使用。\n* 角标 2 单词是自带标识符。为简化 JS 代码移植到 Dart 的难度，这些关键字不能用作类或者类型的名字以及导入的前缀。\n* 角标 3 单词是少有的几个跟异步操作相关的关键字，Dart 1.0 发布后才加入。不能在任何标记 `async`, `async*` 以及 `sync*` 的函数体中使用 `await` 和 `yield` 作为标识符。\n\n剩余的关键字是保留使用的，不能作为标识符。\n\n## 4. 变量\n\n创建并初始化一个变量：\n```Dart\nvar name = 'Bob';\n```\n变量保存引用，`name` 变量保存对一个 `String` 对象的引用。\n\n`name` 变量推断成 `String` 类型，也可以通过显示声明类型修改。如果对象不是限制为单一类型，可以使用 `Object` 或 `dynamic` 修饰。\n```Dart\ndynamic name = 'Bob';\n```\n另一种方式是显示声明类型：\n```Dart\nString name = 'Bob';\n```\n\n### 4.1 默认值\n\n未主动初始化的变量默认初始化为 `null`。即使是数值类型也是如此，在 Dart 的世界里，万物皆对象。\n```Dart\nint lineCount;\nprint('${lineCount == null}'); // true\n```\n\n### 4.2 Final 和 const 关键字\n\n对于初始化后就不再修改的变量，使用 `final` 或 `const` 替代 `var` 或者类型。final 变量只能设置一次，const 变量是一个编译期常量。一个顶层(top-level)的类变量在第一次使用的时候初始化。\n\n创建并设置一个 final 变量：\n```Dart\nfinal name = 'Bab';\nfinal String nickname = 'Bobby';\n```\n不能修改 final 变量的值：\n```Dart\nname = 'Alice';\n```\n使用 `const` 创建**编译期常量**。如果是静态常量，使用 `static const` 修饰。常量必须在声明的时候用字面值或者算术表达式初始化:\n```Dart\nconst bar = 1000000;\nconst double atm = 1.01325 * bar;\n```\n`const` 关键字不仅限于声明常量，还可以用于创建常量的值，以及声明构造函数用于创建常量值。任意变量都可以有一个常量值。\n```Dart\nvar foo = const [];\nfinal bar = const [];\nconst baz = [];\n```\n当用 `const` 声明一个常量，可以省略初始化表达式中的 `const`。\n\n对于非 const 或 非 final 声明的变量，即使之前存的值是一个常量，仍然可以修改：\n```Dart\nfoo = [1, 2, 3] // 之前是 []\n```\n但是不能修改一个 const 变量：\n```Dart\nbaz = [42]; // Error\n```\n\n## 5. 自带类型\n\nDart 对以下类型做了特殊支持：\n* numbers\n* strings\n* booleans\n* lists\n* sets\n* maps\n* runes(用于在字符串中表达 Unicode 字符)\n* symbols\n\n可以用以上任意类型的字面值初始化对象。比如，`this is a string` 是一个字符串字面值，`true` 是一个布尔字面值。\n\n因为 Dart 中的变量都保存一个对象的引用，所以可用构造器（*constructors*)初始化变量。部分自带类型有自己的构造器。比如，用 `Map()` 创建一个表。\n\n### 5.1 数值\n\nDart 支持两种数值：\n\nint<br>\n整型值。\n\ndouble<br>\n64位浮点数。\n\n`int`, `float` 都是 num 子类（subtypes)。num 定义了 +, -, * 和 /，以及 `abs()`, `ceil()` 和 `floor()` 等方法（位运算符定义在 `int`）。其他方法可能定义在 `dart:math` 库中。\n\n整型值是不带小数：\n```Dart\nvar x = 1;\nvar hex = 0xDEADBEEF;\n```\n如果数值包含小数，那它就是 double。浮点数字面值：\n```Dart\nvar y = 1.1\nvar exponents = 1.42e5;\n```\n字符串和数值相互转换：\n```Dart\n// String -> int\nvar one = int.parse('1');\nassert(one == 1);\n\n// String -> double\nvar onePointOne = double.parse('1.1');\nassert(onePointOne == 1.1);\n\n// int -> String\nString oneAsString= 1.toString();\nassert(oneAsString == '1');\n\n// double -> String\nString piAsString = 3.14159.toStringAsFixed(2);\nassert(piAsString == '3.14');\n```\n\n整型的位操作：\n```Dart\nassert((3 >> 1) == 1);\nassert((3 << 1) == 6);\nassert((3 | 4) == 7);\n```\n\n数值字面值是编译期常量。算术表达式包含的操作数都是编译期常量，那么该表达式也是编译期常量。\n```Dart\nconst msPerSecond = 1000;\nconst secondsUntilRetry = 5;\nconst msUntilRetry = secondsUntilRetry * msPerSecond;\n```\n\n### 5.2 字符串\n\nDart 字符串是 UTF-16 单元码的序列。可以用单引号或双引号创建字符串。\n```Dart\nvar s1 = 'Single quotes work well for string literals';\nvar s2 = \"Double quotes work just as well\";\nvar s3 = 'It\\'s easy to escape the string delimeter';\nvar s4 = \"It's even easier to use the other delimeter\";\n```\n\n字符串包含表达式的方式，用 `${expression}`。如果表达式是个标识符，可以省略 {}。\n```Dart\nvar s = 'string interpolation';\n\nassert('Dart has $s, which is very handy.' ==\n    'Dart has string interpolation, ' +\n        'which is very handy.');\nassert('That deserves all caps. ' +\n        '${s.toUpperCase()} is very handy!' ==\n    'That deserves all caps. ' +\n        'STRING INTERPOLATION is very handy!');\n```\n\n拼接字符串可以用 `+` 运算符：\n```Dart\nvar s1 = 'String '\n    'concatenation'\n    \" works even over line breaks.\";\nassert(s1 ==\n    'String concatenation works even over '\n        'line breaks.');\n\nvar s2 = 'The + operator ' + 'works, as well.';\nassert(s2 == 'The + operator works, as well.');\n```\n\n创建多行字符串的方式：使用 `'''` 或 `\"\"\"`：\n```Dart\nvar s1 = '''\nYou can create\nmulti-line strings like this one.\n''';\n\nvar s2 = \"\"\"This is also a\nmulti-line string.\"\"\";\n```\n\n创建原始的字符串方式：使用 `r`：\n```Dart\nvar s = r'In a raw string, not even \\n gets special treatment.';\n```\n\n字符串字面值是编译期常量：\n```Dart\n// These work in a const string.\nconst aConstNum = 0;\nconst aConstBool = true;\nconst aConstString = 'a constant string';\n\n// These do NOT work in a const string.\nvar aNum = 0;\nvar aBool = true;\nvar aString = 'a string';\nconst aConstList = [1, 2, 3];\n\nconst validConstString = '$aConstNum $aConstBool $aConstString';\n// const invalidConstString = '$aNum $aBool $aString $aConstList';\n```\n\n### 5.3 布尔\n\nDart 用 `bool` 表示布尔值。只有两个对象有布尔类型：布尔字面值 `true` 和 `false`，两者都是编译期常量。\n\nDart 是类型安全的，意味着 `if (nonbooleanValue)` 或者 `assert (nonbooleanValue)` 是不合法的。应该用显式的值校验：\n```Dart\n// Check for an empty string.\nvar fullName = '';\nassert(fullName.isEmpty);\n\n// Check for zero.\nvar hitPoints = 0;\nassert(hitPoints <= 0);\n\n// Check for null.\nvar unicorn;\nassert(unicorn == null);\n\n// Check for NaN.\nvar iMeantToDoThis = 0 / 0;\nassert(iMeantToDoThis.isNaN);\n```\n\n### 5.4 数组\n\n几乎在所有编程语言中，最通用的集合(collection)是*数组*或者说是对象组。Dart 中，数组是 *List* 对象。\n\nDart 数组字面值类似 JS。例子：\n```Dart\nvar list = [1, 2, 3];\n```\n\n数组索引范围[0, list.length-1]：\n```Dart\nvar list = [1, 2, 3];\nassert(list.length == 3);\nassert(list[1] == 2);\n\nlist[1] = 1;\nassert(list[1] == 1);\n```\n\n创建编译期常量的数组方法，在数组字面值前加 `const`：\n```Dart\nvar constantList = const [1, 2, 3];\nconstantList[1] = 1; // Uncommenting this causes an error.\n```\n\nDart 2.3 中引入了 **展开操作符(spread operator(...))** 和 **可空的(null-aware)展开操作符(...?)**，两者都提供了将多个元素插入集合的便捷方法。\n\n如下：\n```Dart\nvar list = [1, 2, 3];\nvar list2 = [0, ...list];\nassert(list2.length == 4);\n```\n\n如果展开操作符右边表达式可能为空，可用 `...?` 来避免异常：\n```Dart\nvar list:\nvar list2 = [0, ...?list];\nassert(list2.length == 1);\n```\n\n另外，Dart 2.3 还引入了 **collection if** 和 **collection for**，用来构造集合。\n\n**Collection if** 例子：\n```Dart\nvar nav = [\n    'Home',\n    'Furniture',\n    'Plants',\n    if (promoActive) 'Outlet'\n];\n```\n\n**Collection for** 例子：\n```Dart\nvar list1 = [1, 2, 3];\nvar list2 = [\n    '#0',\n    for (var i in list1) '#$i'\n];\nassert(list2[1] == '#1');\n```\n\n### 5.5 集\n\nDart 集无序且元素唯一。Dart 通过两方面支持集，一个是字面值，另一个是 `Set` 类型。\n\n字面值创建集对象：\n```Dart\nvar halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};\n```\n\n创建空集：\n```Dart\nvar set1 = <String>{};\nSet<String> set2 = {};\nvar map = {}; // Create a map, not a set.\n```\n\n集添加元素，`add()` 或者 `addAll()`：\n```Dart\nvar set1 = <String>{};\nset1.add('fluorine');\nset1.addAll(halogens);\n```\n\n使用 `.length` 获取集的大小：\n```Dart\nvar set1 = <String>{};\nset1.add('fluorine');\nset1.addAll(halogens);\nassert(set1.length == 5);\n```\n\n创建集的编译期字面值，集字面值前加 `const` 关键字：\n```Dart\nfinal constantSet = const {\n    'fluorine',\n  'chlorine',\n  'bromine',\n  'iodine',\n  'astatine',\n}\n// constantSet.add('helium'); // Uncommenting this causes an error.\n```\n\nDart 2.3 后，集也同数组一样，支持展开操作符和 collection fors 以及 ifs。\n\n### 5.6 表\n\n表包含键值对，键值可以是任意类型的对象。Key 在表中唯一，value 可以重复。Dart 通过两方面支持表，一个是字面值，另一个是 Map 类型。\n\nDart 表的字面值例子：\n```Dart\nvar gifts = {\n  // Key:    Value\n  'first': 'partridge',\n  'second': 'turtledoves',\n  'fifth': 'golden rings'\n};\n\nvar nobleGases = {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n```\n\n也可以用构造函数创建的表对象：\n```Dart\nvar gifts = Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\ngifts['fifth'] = 'golden rings';\n\nvar nobleGases = Map();\nnobleGases[2] = 'helium';\nnobleGases[10] = 'neon';\nnobleGases[18] = 'argon';\n```\n\n对已有表中增加键值对：\n```Dart\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds'; // Add a key-value pair\n```\n\n从表中获取值：\n```Dart\nvar gifts = {'first': 'partridge'};\nassert(gifts['first'] == 'partridge');\n```\n\n从表中查不到对应的 key：\n```Dart\nvar gifts = {'first': 'partridge'};\nassert(gifts['fifth'] == null);\n```\n\n用 `.length` 获取表中键值对数量：\n```Dart\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds';\nassert(gifts.length == 2);\n```\n\n创建表的编译期常量，表字面值前加 `const` 关键字：\n```Dart\nfinal constantMap = const {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n```\n\nDart 2.3 后，表也同数组一样，支持展开操作符和 collection fors 以及 ifs。\n\n### 5.7 Runes\n\nDart runes 是字符串的 UTF-32 码点。\n\nUnicode 为全世界所有字母，数字和符号定义了唯一的数值。由于 Dart 字符串是 UTF-16 单元码的序列，因此在字符串中药表示 32位 Unicode 值需要特殊语法。\n\n通常表达一个 Unicode 码点的形式是 `\\uXXXX`，XXXX 是一个4位的16进制数。比如，爱心字符(♥)是 `\\u2665`。当指定多于或少于4位数字时，将值放在花括号中。\n\nString 类有一些相关属性获取 rune 信息。比如，`codeUnitAt` 和 `codeUnit` 属性返回16位的单元码，用 `runes` 属性获取字符串中的 runes。\n\n16位和32位转换：\n```Dart\nmain() {\n  var clapping = '\\u{1f44f}';\n  print(clapping);\n  print(clapping.codeUnits);\n  print(clapping.runes.toList());\n\n  Runes input = new Runes(\n      '\\u2665  \\u{1f605}  \\u{1f60e}  \\u{1f47b}  \\u{1f596}  \\u{1f44d}');\n  print(new String.fromCharCodes(input));\n}\n```\n\n### 5.8 符号\n\n*符号* 对象代表 Dart 程序中的运算符或者标识符。你可能从不会用符号，但它们对于按名称引用标识符的 API 非常有用，因为缩小会更改标识符名称而不会更改标识符符号。\n\n获取符号的方法，`#` 号后面跟着标识符：\n```Dart\n#radix\n#bar\n```\n\n符号字面值是编译期常量。\n\n## 6. 函数\n\nDart 是真正的面向对象语言，即使是函数也有类型，*Funtion*。这意味着函数可以赋值给变量或者作为参数传递。还可以调用类的实例，就好像它是一个函数。更多信息查看[文档](https://dart.dev/guides/language/language-tour#callable-classes)。\n\n函数的实现如下：\n```Dart\nbool isNoble(int atomicNumber) {\n    return _nobleGases[atomicNumber] != null;\n}\n```\n\n虽然类型标注更为高效，但是省略类型的函数依然可用：\n```Dart\nisNoble(atomicNumber) {\n  return _nobleGases[atomicNumber] != null;\n}\n```\n\n对于只有一个表达式的函数，可以简写为：\n```Dart\nbool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;\n```\n\n`=> expr` 语法是 `{ return expr; } 的简写。`=>` 标注通常推断为*箭头*语法。\n\n函数参数支持两种类型：必需(required)和可选(optional)。必需参数在前，可选参数在后。命名为可选的参数仍然可以标记为 `@required`。\n\n### 6.1 可选参数\n\n通过位置或命名中的一种来标记可选参数，但不能两者同时使用。\n\n#### 可选命名参数 <!-- omit in toc -->\n\n调用一个函数，可通过 `paramName: value` 指定命名的参数，比如：\n```Dart\nenableFlags(bold: true, hidde: false);\n```\n\n在定义函数的时候，使用 `{param1, param2, ...}` 指定命名参数：\n```Dart\n/// Sets the [bold] and [hidden] flags ...\nvoid enableFlags({bool bold, bool hidden}) {...}\n```\n\n*Flutter* 实例创建表达式较为复杂，所以 widget 构造函数只使用命名的参数。这能让实例创建表达式可读性更高。\n\n你可以在任意的 Dart 代码中使用 `@required` 来标记命名的参数，从而指定该参数为*必需*参数。举例：\n```Dart\nconst Scrollbar({Key key, @required Widget child});\n```\n\n当构造一个 `Scrollbar` 时，如果 `child` 参数缺省，编译器会报错。\n\n*Required* 定义在 *meta* 包中。两种方式导入：import `package:meta/meta.dart` 或导入其它导出 `meta` 的包。\n\n#### 可选位置参数 <!-- omit in toc -->\n\n函数参数列表中，将后面的参数用 `[]` 标记：\n```Dart\nString say(String from, String msg, [String device]) {\n    var result = '$from says $msg';\n    if (device != null) {\n        result = '$result with a $device';\n    }\n    return result;\n}\n```\n\n不带可选参数的调用：\n```Dart\nassert(say('Bob', 'Howdy') == 'Bob says Howdy');\n```\n\n携带可选参数的调用：\n```Dart\nassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');\n```\n\n#### 默认参数值 <!-- omit in toc -->\n\n函数参数支持给定默认值，包括命名和位置参数。默认值是编译期常量。如果没有主动提供默认值，默认值为 `null`。\n\n默认值例子：\n```Dart\n/// Sets the [bold] and [hidden] flags ...\nvoid enableFlags({bool bold = false, bool hidden = false}) {...}\n\n// bold will be true; hidden will be false.\nenableFlags(bold: true);\n```\n\n为位置参数提供默认值：\n```Dart\nString say(String from, String msg,\n    [String device = 'carrier pigeon', String mood]) {\n  var result = '$from says $msg';\n  if (device != null) {\n    result = '$result with a $device';\n  }\n  if (mood != null) {\n    result = '$result (in a $mood mood)';\n  }\n  return result;\n}\n\nassert(say('Bob', 'Howdy') ==\n    'Bob says Howdy with a carrier pigeon');\n```\n\n函数参数类型为数组或表类型，也支持默认值：\n```Dart\nvoid doStuff(\n    {List<int> list = const [1, 2, 3],\n    Map<String, String> gifts = const {\n      'first': 'paper',\n      'second': 'cotton',\n      'third': 'leather'\n    }}) {\n  print('list:  $list');\n  print('gifts: $gifts');\n}\n```\n\n### 6.2 main() 函数\n\n每个应用都有一个顶层的 `main()` 函数作为程序入口。该函数返回值为 `void` 并且有一个可选参数，类型为 `List<String>`。\n\nWeb 程序的 `main()` 函数例子：\n```Dart\nvoid main() {\n  querySelector('#sample_text_id');\n    ..text = 'Click me!';\n    ..onClick.listen(reverseText);\n}\n```\n\n命令行程序的 `main()` 函数例子：\n```Dart\n// Run the app like this: dart args.dart 1 test\nvoid main(List<String> arguments) {\n  print(arguments);\n\n  assert(arguments.length == 2);\n  assert(int.parse(arguments[0]) == 1);\n  assert(arguments[1] == 'test');\n}\n```\n\n用 *args library* 库定义并解析命令行参数。\n\n### 6.3 一等公民函数\n\n函数可以作为其它函数的参数，比如：\n```Dart\nvoid printElement(int element) {\n  print(element);\n}\n\nvar list = [1, 2, 3];\n\n// Pass printElement as aparameter.\nlist.forEach(printElement);\n```\n\n函数也可以存到变量中，比如：\n```Dart\nvar loudify = (msg) => '!!! ${msg.toUpperCase()}!!!';\nassert(loudify('hello') == '!!!HELLO!!!');\n```\n上面使用了匿名函数。\n\n### 6.4 匿名函数\n\n大多函数都有名字，比如 `main()` 和 `printElement()`，一些没有名字的函数叫做 *匿名函数(Anonymous funstions)*、*lambda* 或 *闭包(closure)*。函数存到变量中，可以被添加到集合中或者被移除。\n\n匿名函数和一般函数类似，0个或多个参数，参数间用逗号隔开，支持可选类型标注，参数用 `()` 包含。\n\n匿名函数如下：\n```Dart\n([Type] param1[, ...]) {\n  codeBlock;\n}\n```\n\n以下例子定义一个匿名函数，函数携带一个未定义类型的参数 `item`。每遍历一个 list 中元素，函数都会被调用一次，并打印对应元素的信息。\n```Dart\nvar list = ['apples', 'bananas', 'oranges'];\nlist.forEach((item) {\n  print('${list.indexOf(item)}: $item');\n});\n```\n\n匿名函数也可以简写成箭头函数。\n```Dart\nlist.forEach((item) => print('${list.indexOf(item)}: $item'));\n```\n\n### 6.5 作用域 \n\nDart 是一种 *lexically scoped language*。代码的布局决定了变量的作用域。\n\n以下例子展示了嵌套函数的变量作用域：\n```Dart\nbool topLevel = true;\n\nvoid main() {\n  var insideMain = true;\n\n  void myFunction() {\n    var insideFunction = true;\n\n    void nestedFunction() {\n      var insideNestedFunction = true;\n\n      assert(topLevel);\n      assert(insideMain);\n      assert(insideFunction);\n      assert(insideNestedFunction);\n    }\n  }\n}\n```\n\n### 6.6 词法闭包\n\n*闭包* 是函数，能访问作用域内的变量，即使该闭包在原来作用域外部被使用。\n\n函数能延长变量的生命周期。以下例子中，`makeAdder()` 捕获变量 `addBy`。当函数执行结束，`addBy` 被保存到函数中。\n```Dart\n/// Returns a function that adds [addBy] to the\n/// function's argument.\nFunction makeAdder(num addBy) {\n  return (num i) => addBy + i;\n}\n\nvoid main() {\n  // Create a function that adds 2.\n  var add2 = makeAdder(2);\n\n  // Create a function that adds 4.\n  var add4 = makeAdder(4);\n\n  assert(add2(3) == 5);\n  assert(add4(3) == 7);\n}\n```\n\n### 6.7 函数的等价性\n\n以下例子中，比较了顶层函数，静态方法和实例方法的等价性:\n```Dart\nvoid foo() {}\n\nclass A {\n  static void bar() {}\n  void baz() {}\n}\n\nvoid main() {\n  var x;\n\n  // Comparing top-level functions.\n  x = foo;\n  print(foo == x);\n\n  // Comparing static methods.\n  x = A.bar;\n  print(A.bar == x);\n\n  // Comparing instance methods.\n  var v = A();\n  var w = A();\n  var y = w;\n  x = w.baz;\n\n  print(y.baz == x);\n\n  print(v.baz != w.baz);\n}\n```Dart\n\n### 6.8 返回值\n\n所有函数都有返回值。如果没有显示指定，会默认在函数体最后加上 `return null`。\n```Dart\nfoo() {}\nprint(foo() == null);\n```\n\n## 7. 运算符\n\n|          描述          |                    运算符                     |\n| :--------------------: | :-------------------------------------------: |\n|     一元后缀运算符     |      `expr++`, `expr--`, `()`, `.`, `?.`      |\n|     一元前缀运算符     | `-expr`, `!expr`, `~expr`, `++expr`, `--expr` |\n| 乘法（multiplicative） |              `*`, `/`, `%`, `~/`              |\n|          加法          |                   `+`, `-`                    |\n|          位移          |               `<<`, `>>`, `>>>`               |\n|          位与          |                      `&`                      |\n|         位异或         |                      `^`                      |\n|          位或          |                      `|`                      |\n|   关系运算和类型推断   |    `>=`, `<=`, `>`, `<`, `as`, `is`, `is!`    |\n|          等价          |                  `==`, `!=`                   |\n|         逻辑与         |                     `&&`                      |\n|         逻辑或         |                     `||`                      |\n|        可选判断        |                     `??`                      |\n|          条件          |            `expr1 ? expr2 : expr3`            |\n|          多级          |                     `..`                      |\n|          赋值          | `=`, `*=`, `/=`, `+=`, `-=`, `&=`, `^=`, etc  |\n\n运算符使用例子：\n```Dart\na++\na + b\na = b\na == b\nc ? a : b\na is T\n```\n\n上述表中的运算符优先从高到底排列。运算符优先级的作用：\n```Dart\nif ((n % i == 0) && (d % i ) == 0) ...\nif (n % i == 0 && d % i == 0) ...\n```\n\n### 7.1 算数运算符\n\nDart 支持的算术运算符：\n|  运算符 | 意义 |\n| ------: | :--- |\n|     `+` | 加   |\n|     `-` | 减   |\n| `-expr` | 负号 |\n|     `*` | 乘   |\n|     `/` | 除   |\n|    `~/` | 取商 |\n|     `%` | 取模 |\n\nDart 支持的递增/递减运算符：\n| 运算符  |                  意义                   |\n| :-----: | :-------------------------------------: |\n| `++var` |  `var = var + 1`(表达式的值是加后的值)  |\n| `var++` | `var = var + 1`（表达式的值是加前的值） |\n| `--var` | `var = var - 1`（表达式的值是减后的值） |\n| `var--` | `var = var - 1`（表达式的值是减前的值） |\n\n### 7.2 关系运算法\n\n| 运算符 |   意义   |\n| :----: | :------: |\n|  `==`  |   相等   |\n|  `!=`  |   不等   |\n|  `>`   |   大于   |\n|  `<`   |   小于   |\n|  `>=`  | 大于等于 |\n|  `<=`  | 小于等于 |\n\n### 7.3 类型推断运算符\n\n运行时用于类型校验：\n| 运算符 |               意义               |\n| :----: | :------------------------------: |\n|  `as`  | 类型推断(类型推断错误会抛出异常) |\n|  `is`  |    对象是指定类型时返回 true     |\n| `is!`  |   对象不是指定类型时返回 true    |\n\n### 7.4 赋值运算符\n\n|      |      |       |       |       |      |\n| ---- | ---- | ----- | ----- | ----- | ---- |\n| `=`  | `-=` | `/=`  | `%\\`  | `>>=` | `^=` |\n| `+=` | `*=` | `~/=` | `<<=` | `&=`  | `|=` |\n\n|       | 联合赋值  | 等价表达式  |\n| :---: | :-------: | :---------: |\n|  op   | `a op= b` | `a= a op b` |\n| 例子  | `a += b`  | `a = a + b` |\n\n### 7.5 逻辑运算符\n\n| 运算符  |  意义  |\n| :-----: | :----: |\n| `!expr` | 逻辑非 |\n|  `||`   | 逻辑或 |\n|  `&&`   | 逻辑与 |\n\n### 7.6 位移运算符\n\n| 运算符  |            意义            |\n| :-----: | :------------------------: |\n|   `&`   |            位与            |\n|   `|`   |            位或            |\n|   `^`   | 位异或（相同为0，不同为1） |\n| `~expr` |    位取反（0->1, 1->0）    |\n|  `<<`   |          左移一位          |\n|  `>>`   |          右移一位          |\n\n### 7.7 条件表达式\n\nDart 支持两个条件表达式：\n\n`condition ? expr1 : expr2`<br>\n如果条件为真，执行表达式1并返回结果；否则，执行表达式2并返回结果。\n\n`expr1 ?? expr2`<br>\n如果表达式1非空，返回其值；否则，执行表达式2并返回结果。\n\n### 7.8 多级表示法\n\n连续调用相同对象，使用 `..` 可以简化写法，减少使用临时变量。\n```Dart\nquerySelector('#confirm')\n  ..text = 'Confirm'\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirm!'));\n\n// 等价于以下写法\nvar button = querySelector('#confirm');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n```\n\n嵌套写法：\n```Dart\nfinal addressBook = (\n  AddressBookBuilder()\n    ..name = 'jenny'\n    ..email = 'jenny@example.com'\n    ..phone = (\n      PhoneNumberBuilder()\n        ..number = 'xxx-xxx-xxxx'\n        ..label = 'home'\n      .build();\n    )\n  .build();\n)\n```\n\n### 7.9 其它\n\n其他运算符：\n| 运算符 |         名字         |                  意义                   |\n| :----: | :------------------: | :-------------------------------------: |\n|  `()`  | Function application |              表示调用函数               |\n|  `[]`  |       访问数组       |      引用数组指定索引位置上的元素       |\n|  `.`   |     访问成员变量     |             表达式访问属性              |\n|  `?.`  |   条件访问成员变量   | 类似 `.`，支持空对象(类似 Swift 可选链) |\n\n## 8. 控制语句\n\nDart 控制流：\n* `if else`\n* `switch case`\n* `while` & `do-while`\n* `break` & `continue`\n* `for` 循环\n* `assert`\n\n另外，还有 `try-catch` 和 `throw`。\n\n### 8.1 If else\n\n```Dart\nif (isRaining()) {\n  you.bringRainCoat();\n} else if (isSnowing()) {\n  you.wearJacket();\n} else {\n  car.putTopDown();\n}\n```\n\n不同于 JS 的地方， Dart 条件必须是布尔值。\n\n### 8.2 For 循环\n\n```Dart\nvar msg = StringBuffer('Dart is fun');\nfor (var i = 0; i < 5; i++) {\n  msg.write('!');\n}\n```\n\n闭包捕获变量，并在内部拷贝，即使 `i` 改变也不会影响之前的值： \n```Dart\nvar callbacks = [];\nfor (var i = 0; i< 2; i++) {\n  callbacks.append(() => print(i));\n}\ncallbacks.forEach((c) => c()); // Dart 输出 0, 1； JS 输出 2, 2\n```\n\n### 8.3 While & do-while\n\n`while` 在进入循环体之前判断条件：\n```Dart\nwhile (!isDone()) {\n  doSomething();\n}\n```\n\n`do-while` 先执行循环体再判断条件：\n```Dart\ndo {\n  printLine();\n} while(!atEndOfPage())\n```\n\n### 8.4 Break & continue\n\n* `break` 跳出循环\n* `continue` 跳过当前循环\n\n### 8.5 Switch case\n\nDart switch 支持整型，字符串和编译期常量。对象必须是相同类型且该类没有重载 `==`。\n\n每个非空的 `case` 从句，必须要有 `break`。其他结束 `case` 的语句：`continue`, `return` 和 `throw`。\n\n非空的 `case` 中省略 `break` 会报编译错误：\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n  executeOpen();\n  // Error: Missing break\n  case 'CLOSE':\n  executeClose();\n  break;\n}\n```\n\n`case` 可以为空：\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n  case 'NOW_CLOSED':\n  executeNowClosed();\n  break;\n}\n```\n\nDart 支持 `continue` 加标签的方式控制代码执行：\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    continue nowClosed;\n  // Continues executing at the nowClosed label.\n\n  nowClosed:\n  case 'NOW_CLOSED':\n    // Runs for both CLOSED and NOW_CLOSED.\n    executeNowClosed();\n    break;\n}\n```\n`case` 内部可以定义局部变量，变量作用域仅限此代码块。\n\n### 8.6 断言\n\n开发者模式下，支持 `assert(condition, optionalMessage)` 终止程序。\n\n## 9. 异常处理\n\nDart 支持异常捕获机制。异常是程序运行过程中不可知的错误。如果程序没有捕获异常，抛出异常的[**isolate**](https://zhuanlan.zhihu.com/p/40069285) 会被挂起，通常情况下，isolate 和程序都会被终止。\n\n不同于 Java， Dart 的异常都是未经检查的。方法不会声明可能的异常，并且不需要去处理。\n\nDart 提供了 *Exception*，*Error* 以及其他的子类。开发者可以自定义异常。另外，Dart 程序可以把所有非空对象作为异常抛出。\n\n### 9.1 Throw\n\n抛出异常的例子：\n```Dart\nthrow FormatException('Expected at least 1 section');\n```\n\n抛出任意非空对象作为异常：\n```Dart\nthrow 'Out of llamas';\n```\n\n因为抛出异常是一个表达式，所以可以出现在任何需要表达式的位置：\n```Dart\nvoid distanceTo(Point point) => throw UnimplementedError();\n```\n\n### 9.2 Catch\n\n捕获异常能停止异常的传递，给程序处理异常的能力：\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlammas();\n}\n```\n\n对于能抛出多种异常类型的代码，可以使用多个 catch 从句。\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  // A specific exception\n  buyMoreLlamas();\n} on Exception catch (e) {\n  // Anything else that is an exception\n  print('Unknown exception: $e');\n} catch (e) {\n  // No specified type, handles all\n  print('Something really unknown: $e');\n  }\n```\n\n`catch()` 可以指定两个参数，第一个是抛出的异常，第二个是栈回溯([StackTrace](https://api.dart.dev/stable/dart-core/StackTrace-class.html))。\n```Dart\ntry {\n  // ···\n} on Exception catch (e) {\n  print('Exception details:\\n $e');\n} catch (e, s) {\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```\n\n在当前位置处理异常并继续传递，使用 `rethrow` 关键字：\n```Dart\nvoid misbehave() {\n  try {\n    dynamic foo = true;\n    print(foo++); // Runtime error\n  } catch (e) {\n    print('misbehave() partially handled ${e.runtimeType}.');\n    rethrow; // Allow callers to see the exception.\n  }\n}\n\nvoid main() {\n  try {\n    misbehave();\n  } catch (e) {\n    print('main() finished handling ${e.runtimeType}.');\n  }\n}\n```\n\n### 9.3 Finally\n\n无论是否抛出异常，使用finally子句，确保代码运行。如果 `catch` 没有匹配到异常，该异常会在 `finally` 后继续传播：\n```Dart\ntry {\n  breedMoreLlamas();\n} finally {\n  // Always clean up, even if an exception is thrown.\n  cleanLlamaStalls();\n}\n```\n\n`catch` 匹配到异常后，也会执行 `finally` 从句：\n```Dart\ntry {\n  breedMoreLlamas();\n} catch (e) {\n  print('Error: $e'); // Handle the exception first.\n} finally {\n  cleanLlamaStalls(); // Then clean up.\n}\n```\n\n## 10. 类\n\nDart 是面向对象语言，具有类和基于 mixin 的继承。每个对象都是类的实例，每个类继承自 *Object*。基于 *mixin* 的继承意味着类只有一个超类，但是类的成员可被多个类结构重用。\n\n### 10.1 使用类成员变量\n\n对象的成员由函数和数据组成。当一个方法被调用时，也就是调用对象的某个方法：通过对象的函数和数据获取方法。\n\n使用 `.` 引用实例变量或方法：\n```Dart\nvar p = Point(2, 2);\n\n// Set the value of the instance variable y.\np.y = 3;\n\n// Get the value of y.\nassert(p.y == 3);\n\n// Invoke distanceTo() on p.\nnum distance = p.distanceTo(Point(4, 4));\n```\n\n使用 `?.` 避免调用链为 null 时产生异常：\n```Dart\n// If p is non-null, set its y value to 4.\np?.y = 4;\n```\n\n### 10.2 使用构造函数\n\n使用构造器构造对象。构造器命名可以是 `ClassName` 或 `ClassName.identifier`。比如：\n```Dart\nvar p1 = Point(2, 2);\nvar p2 = Point.fromJson({'x': 1, 'y': 2});\n```\n\n以下代码效果相同，构造器前面多一个可选的 `new` 关键字：\n```Dart\nvar p1 = new Point(2, 2);\nvar p2 = new Point.fromJson({'x': 1, 'y': 2});\n```\n\n部分类提供了[常量构造器](https://dart.dev/guides/language/language-tour#constant-constructors)。构造器前加 `const` 修饰，以创建编译期常量：\n```Dart\nvar p = const ImmutablePoint(2, 2);\n```\n\n构造两个等价的编译期常量：\n```Dart\nvar a = const ImmutablePoint(1, 1);\nvar b = const ImmutablePoint(1, 1);\n\nassert(identical(a, b)); // They are the same instance!\n```\n\n如果能通过上下文推断出是常量，则可省略 `const`：\n```Dart\n// Lots of const keywords here.\nconst pointAndLine = const {\n  'point': const [const ImmutablePoint(0, 0)],\n  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],\n};\n\n// 可以简写为：\n// Only one const, which establishes the constant context.\nconst pointAndLine = {\n  'point': [ImmutablePoint(0, 0)],\n  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],\n};\n```\n\n如果一个常量构造器超出常量上下文，并且没用 `const` 修饰，则创建一个非常量对象：\n```Dart\nvar a = const ImmutablePoint(1, 1); // Creates a constant\nvar b = ImmutablePoint(1, 1); // Does NOT create a constant\n\nassert(!identical(a, b)); // NOT the same instance!\n```\n\n### 10.3 获取对象类型\n\n使用 Object `runtimeType` 属性，在运行时获取对象类型，返回 `Type` 对象：\n```Dart\nprint('The type of a is ${a.runtimeType}');\n```\n以上内容介绍了如何*使用*类，下面介绍如何实现类。\n\n### 10.4 实例变量\n\n如何声明一个实例变量：\n```Dart\nclass Point {\n  num x; // Declare instance variable x, initially null.\n  num y; // Declare y, initially null.\n  num z = 0; // Declare z, initially 0.\n}\n```\n未初始化的实例变量默认为 `null`。\n\n所以实例变量隐式生成 *getter* 方法。所有实例变量（除了 final）隐式生成 *setter* 方法。\n```Dart\nclass Point {\n  num x;\n  num y;\n}\n\nvoid main() {\n  var point = Point();\n  point.x = 4; // Use the setter method for x.\n  assert(point.x == 4); // Use the getter method for x.\n  assert(point.y == null); // Values default to null.\n}\n```\n关于实例变量的生命周期，实例变量在构造器和初始化器执行之前就已创建，如果声明实例变量的时候手动初始化了，那么初始化也在此时完成。\n\n### 10.5 构造函数\n\n构造器写法：声明一个函数，函数名和类名相同。最常见的构造器形式就是生成构造器，会创建类的一个新实例：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(num x, num y) {\n    // There's a better way to do this, stay tuned.\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n`this` 关键字引用当前实例。\n\n构造器的一个语法糖写法：\n```Dart\nclass Point {\n  num x, y;\n\n  // Syntactic sugar for setting x and y\n  // before the constructor body runs.\n  Point(this.x, this.y);\n}\n```\n\n#### 默认构造器 <!-- omit in toc -->\n\n如果没有生命构造器，Dart 会默认生成一个构造器。此构造器没有参数，并调用父类的不带参构造器。\n\n#### 构造器不继承 <!-- omit in toc -->\n\n构造器不支持继承。\n\n#### 带名字的构造器 <!-- omit in toc -->\n\n如果需要创建多个构造器，使用带名字的构造器：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  // Named constructor\n  Point.origin() {\n    x = 0;\n    y = 0;\n  }\n}\n```\n\n#### 调用非默认的父类构造器 <!-- omit in toc -->\n\n默认情况下，子类的构造器调用父类不带名字和参数的构造器，且在子类构造器的头部调用。如果使用了[初始化列表](https://dart.dev/guides/language/language-tour#initializer-list)，此操作会在父类调用前执行。三者顺序：\n1. 初始化列表\n2. 父类无参构造器\n3. 当前类无参构造器\n\n\n如果父类没有无名无参的构造器，必须手动调用父类的一个构造器。在 `:` 和函数体之间指定父类的构造器。比如：\n```Dart\nclass Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print('in Person');\n  }\n}\n\nclass Employee extends Person {\n  // Person does not have a default constructor;\n  // you must call super.fromJson(data).\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print('in Employee');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // Prints:\n  // in Person\n  // in Employee\n  if (emp is Person) {\n    // Type check\n    emp.firstName = 'Bob';\n  }\n  (emp as Person).firstName = 'Bob';\n}\n```\n\n#### 初始化列表 <!-- omit in toc -->\n\n除了调用父类构造器外，还可以在构造器函数体之前初始化实例变量。多个初始化之间用逗号分隔：\n```Dart\nPoint.fromJson(Map<String, num> json) : x = json['x'], y = json['y'] {\n  print('In Point.fromJson(): ($x, $y)');\n}\n```\n\n开发模式下，初始化列表中可使用断言：\n```Dart\nPoint.withAssert(this.x, this.y) : assert(x >= 0) {\n  print('In Point.withAssert(): ($x, $y)');\n}\n```\n\n设置 final 字段时，初始化列表较为便利。比如：\n```Dart\nimport 'dart:math';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);\n}\n```\n\n#### 重定向构造器 <!-- omit in toc -->\n\n部分构造器的作用只是调用当前类的其它构造器。重定向构造器写法：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  Point.alongzXAxis(num x) : this(x, 0);\n}\n```\n\n#### 常量构造器 <!-- omit in toc -->\n\n常量构造器用来表示类生成的实例不会改变。用 `const` 修饰构造器且全部实例变量使用 `final`。\n```Dart\nclass ImmutablePoint {\n  static final ImmutablePoint origin = const ImmutablePoint(0, 0);\n\n  final num x, y;\n\n  const ImmutablePoint(this.x, this.y);\n}\n```\n常量构造器不一定总是创建常量。更多信息查看[文档](https://dart.dev/guides/language/language-tour#using-constructors)。\n\n#### 工厂构造器 <!-- omit in toc -->\n\n关键字 `factory` 修饰的构造器表示，此构造器不会每次都创建新的实例。比如，工厂构造器可能返回一个缓存中的实例或者子类的实例。\n\n工厂构造器写法：\n```Dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n```\n\n调用工厂构造器同其他构造器方法一样：\n```Dart\nvar logger = Logger('UI');\nlogger.log('Button clicked');\n```\n\n### 10.6 方法\n\n方法是定义在类内部的函数。\n\n#### 实例方法 <!-- omit in toc -->\n\n对象的实例方法内部可访问实例变量和 `this`。例子如下：\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  num distanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n```\n\n#### Getters & setters <!-- omit in toc -->\n\nGetters 和 setters 是特殊的方法，能读写对象属性。实例变量默认都有 getter，通常也有 setter。也可用 `get` 和 `set` 自己实现：\n```Dart\nclass Rectangle {\n  num left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // Define two calculated properties: right and bottom.\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n  assert(rect.left == 3);\n  rect.right = 12;\n  assert(rect.left == -8);\n}\n```\n\n#### 抽象方法 <!-- omit in toc -->\n\n实例方法，getter 和 setter 都能定义为抽象方法，当前类只定义接口，实现交由其它类。抽象方法只能定义在[抽象类](https://dart.dev/guides/language/language-tour#abstract-classes)中。\n\n定义抽象方法，用分号替代函数体：\n```Dart\nabstract class Doer {\n  void soSomething();\n}\n\nclass EffectiveDoer extends Doer {\n  void soSomething() {\n\n  }\n}\n```\n\n### 10.7 抽象类\n\n关键字 `abstract` 定义*抽象类*（不能被实例化）。抽象类多用于接口定义，实现较多的情况。定义[工厂构造器](https://dart.dev/guides/language/language-tour#factory-constructors)可实例化抽象类。\n\n抽象类通常都有抽象方法，例子如下：\n```Dart\n// This class is declared abstract and thus\n// can't be instantiated.\nabstract class AbstractContainer {\n  // Define constructors, fields, methods...\n\n  void updateChildren(); // Abstract method.\n}\n```\n\n### 10.8 隐式接口\n\n类隐式定义了一个接口列表，包括当前类实现的所有成员变量。类 A 在不继承类 B 的情况下，实现类 B 的接口，从而调用类 B 的成员。\n\n声明类的时候用 `implements` 并提供所需的 APIs，从而实现一个或多个接口：\n```Dart\nclass Person {\n  final _name;\n\n  Person(this._name);\n\n  String greet(String who) => 'Hello, $who. I am $_name';\n}\n\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy'))); // 'Hello, Bob. I am $Kathy'\n  print(geetBob(Impostor())); // 'Hi Bob. Do you know who I am?'\n}\n```\n\n一个类实现多个接口：\n```Dart\nclass Point implements Comparable, Location {...}\n```\n\n### 10.9 扩展类\n\n使用 `extends` 创建子类，`super` 指向父类：\n```Dart\nclass Television {\n  void turnOn() {\n    _illuminateDisplay();\n    _activateIrSensor();\n  }\n  // ···\n}\n\nclass SmartTelevision extends Television {\n  void turnOn() {\n    super.turnOn();\n    _bootNetworkInterface();\n    _initializeMemory();\n    _upgradeApps();\n  }\n  // ···\n}\n```\n\n#### 重写成员 <!-- omit in toc -->\n\n子类可重载实例方法、getters 和 setters。`@override` 关键字表示成员被重载：\n```Dart\nclass SmartTelevision extends Television {\n  @override\n  void turnOn() {...}\n  // ···\n}\n```\n\n#### 可重载运算符 <!-- omit in toc -->\n\n下表中运算符支持重载：\n|       |       |       |       |\n| :---: | :---: | :---: | :---: |\n|  `<`  |  `+`  |  `|`  | `[]`  |\n|  `>`  |  `/`  |  `^`  | `[]=` |\n| `<=`  | `~/`  |  `&`  |  `~`  |\n| `>=`  |  `*`  | `<<`  | `==`  |\n|  `-`  |  `%`  | `>>`  |       |\n\n重载 `+`, `-` 运算符：\n```Dart\nclass Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}\n```\n\n#### noSuchMethod() <!-- omit in toc -->\n\n重载 `noSuchMethod()` 方法，及时处理调用对象不存在的实例变量和方法：\n```Dart\nclass A {\n  // Unless you override noSuchMethod, using a\n  // non-existent member results in a NoSuchMethodError.\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print('You tried to use a non-existent member: ' +\n        '${invocation.memberName}');\n  }\n}\n```\n\n不可调用对象未实现的方法，除非实现以下任意情况：\n* 消息接受者有静态类型 `dynamic`\n* 接收器有一个定义未实现方法的静态类型（包括抽象类型），接收器的动态类型有一个noSuchMethod（）实现，它与Object类中的实现不同。\n\n### 10.10 枚举类型\n\n枚举表示固定数量的常量值。\n\n#### 用法 <!-- omit in toc -->\n\n使用 `enum` 关键字声明枚举类型：\n```Dart\nenum Color { red, green, blue }\n```\n\n枚举值有个 `index` getter，返回该值在枚举声明中的位置，从 0 开始。第一个值为 0，第二个值为 1...\n\n使用 `values` 在运行时获取所有枚举值：\n```Dart\nList<Color> colors = Color.values;\nassert(colors[2] == Color.blue);\n```\n\n枚举在 switch case 中使用：\n```Dart\nvar aColor = Color.red;\nswitch (aColor) {\n  case Color.red:\n  print('red');\n  break;\n  case Color.green:\n  print('green');\n  break\n  default:\n  print(aColor);\n}\n```\n\n枚举类型的局限性：\n* 不可子类化，*mix in*，或实现\n* 不能显示实例一个枚举类型\n\n### 10.11 类添加特性\n\nMixins 是一种将类代码共享给其他类的功能。\n\n`with` 关键字*使用* mixin 功能。例子如下：\n```Dart\nclass Musician extends Performer with Musical {\n\n}\n\nclass Maestro extends Person with Musical, Aggressive, Demented {\n  Maestro(String maestroname) {\n    name = maestroName;\n    canConduct = true;\n  }\n}\n```\n\n*实现* mixin：创建一个 Object 子类，并且不声明构造器。另外，如果不想该类被当作普通的类，用 `mixin` 关键字代替 `class`。比如：\n```Dart\nmixin Musical {\n  bool canPlayPiano = false;\n  bool canCompose = false;\n  bool canConduct = false;\n\n  void entertainMe() {\n    if (canPlayPiano) {\n      print('Playing piano');\n    } else if (canConduct) {\n      print('Waving hands');\n    } else {\n      print('Humming to self');\n    }\n  }\n}\n```\n\n要指定只有某些类型可以使用mixin，使用 `on` 指定所需的超类：\n```Dart\nmixin MusicalPerformer on Musician {\n  // ... \n}\n```\n\n### 10.12 类变量和方法\n\n使用 `static` 关键字创建静态变量和方法。静态方法和变量都是面向类型的，实例无法访问。\n\n#### 静态方法 <!-- omit in toc -->\n\n```Dart\nclass Queue {\n  static const initialCapacity = 16;\n}\n\nvoid main() {\n  assert(Queue.initialCapacity == 16);\n}\n```\n\n静态变量只有在使用时才会被初始化。\n\n#### 静态方法 <!-- omit in toc -->\n\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 < distance && distance < 2.9);\n  print(distance);\n}\n```\n\n## 11. 泛型\n\n数组类型声明：`List<E>`，其中 <...> 将类型标记为*泛型*，即，类型内部有个形式上的参数。通常的命名规范，泛型参数名字为单字符，如 E, T, S, K 和 V。\n\n### 11.1 为什么使用泛型\n\n泛型要求代码是类型安全的，但是使用泛型有很多好处：\n* 正确使用泛型使代码结构更好\n* 减少重复代码\n\n声明一个只含字符串的数组：`List<String>`。\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nnames.add(42);//编译报错\n```\n\n受益于静态分析的前提下，泛型能为多个类型共享一个接口。比如：\n```Dart\n// 缓存 Object\nabstract class ObjectCache {\n  Object getByKey(String key);\n  void setByKey(String key, Object value);\n}\n\n// 缓存 String\nabstract class StringCache {\n  String getByKey(String key);\n  void setByKey(String key, String value);\n}\n\n// 使用泛型\nabstract class Cache<T> {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n```\n\n### 11.2 使用集合字面值\n\n```Dart\nvar names = <String>['Seth', 'Kathy', 'Lars'];\nvar uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};\nvar pages = <String, String>{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n};\n```\n\n### 11.3 使用带参数化类型的构造函数\n\n使用构造器时，指定一个或多个类型，类型放在 `<>` 中间。比如：\n```Dart\nvar nameSet = Set<String>.from(names);\n```\n\n### 11.4 泛型集合\n\nDart 泛型类型是*具体化的*，这意味着泛型变量在运行时携带类型信息。例子如下：\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nprint(names is List<String>); // true\n```\n\n### 11.5 泛型约束\n\n当定义泛型，可使用 `extends` 约束泛型：\n```Dart\nclass Foo<T extends SomeBaseClass> {\n  String toString() => \"Instance of 'Foo<$T>'\";\n}\nclass Extender extends SomeBaseClass {}\n\nvar someBaseClassFoo = Foo<SomeBaseClass>();\nvar extenderFoo = Foo<Extender>();\n```\n\n不指定泛型参数：\n```Dart\nvar foo = Foo();\nprint(foo); // Instance of 'Foo<SomeBaseClass>'\n```\n\n### 11.6 使用泛型方法\n\nDart 支持泛型方法或函数：\n```Dart\nT first<T>(List<T> ts) {\n  T tmp = ts[0];\n  return tmp;\n}\n```\n上述代码展示了函数泛型参数可使用的位置：\n* 函数返回值\n* 函数参数\n* 内部布局变量\n\n## 12. 库\n\n使用 `import` 和 `library` 指令创建模块化和可共享的代码。库不仅提供 APIs，还是私有的作用域块：下划线开头的标识符仅在库内部可见。每个 Dart 应用都是一个库，即使并不使用 `library` 指令。\n\n库可作为包(package)发布。\n\n### 12.1 使用库\n\n使用 `import`，在一个库中指定另一个库的命名空间。\n\n举个例子，Dart 网页应用通常使用 `dart:html` 库，可以如下导入：\n```Dart\nimport 'dart:html';\n```\n\n`import` 指令后面的参数是指向目标库的 URI。对于 Dart 自带的库，使用 `dart:` 作为 sheme。其他库，使用文件路径或 `package:` scheme。包管理工具提供的库使用 `package:` scheme。比如：\n```Dart\nimport 'package:test/test.dart';\n```\n\n#### 指定库前缀 <!-- omit in toc -->\n\n当引入的两个库有冲突的标识符，可以为两个库指定前缀，从而避免冲突。例子如下：\n```Dart\nimport 'package:lib1/lib1.dart';\nimport 'package:lib2/lib2.dart' as lib2;\n\nElement element1 = Element();\n\nlib2.Element element2 = lib2.Element();\n```\n\n#### 导入库的部分接口 <!-- omit in toc -->\n\nDart 支持导入库的部分功能，比如：\n```Dart\nimport 'package:lib1/lib1.dart' show foo;\n\nimport 'package:lib2/lib2.dart' hide foo;\n```\n\n#### 库懒加载 <!-- omit in toc -->\n\n库的按需加载。以下场景可以使用库按需加载：\n* 加快应用启动时间\n* A/B test\n* 加载较少使用的库\n\n实现懒加载，首先要用 `deferred as` 导入：\n```Dart\nimport 'package:greetings/hello.dart' deferred as hello;\n```\n\n需要使用的地方，用库的标识调用 `loadLibrary()`：\n```Dart\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n```\n上述代码中，`await` 关键字会阻塞代码直到库加载完成。更多信息查看[异步操作](https://dart.dev/guides/language/language-tour#asynchrony-support)。\n\n多次调用 `loadLibrary()` 加载同一个库不会出错，且库只会被加载一次。\n\n使用库的懒加载时，记住以下几点：\n* 懒加载的库中的常量，只有在懒加载完成后才能作为常量使用\n* 不能使用懒加载库中的类型。而应该将接口类型放到第三方库中，让目标库和当前文件共同导入第三方库\n* 开发者用 `deferred as namespace` 定义懒加载库的命名空间，Dart 在命名空间后面隐式插入 `loadLibrary()`。`loadLibrary()` 返回 *Future*。\n\n### 12.2 实现库\n\n实现一个库，请查看 [Create Library Package](https://dart.dev/guides/libraries/create-library-packages)：\n* 如何组织库的源码\n* 如何使用 `export` 指令\n* 何时使用 `part` 指令\n* 何时使用 `library` 指令\n\n## 13. 异步\n\nDart 库中有很多返回值为 `Future` 和 `Stream` 的函数。这些函数是异步函数：派发一个耗时任务后直接返回，并不等待任务完成。\n\n`async` 和 `await` 关键字实现异步编程，让异步任务像同步的代码顺序执行。\n\n### 13.1 处理 Future\n\n两种方式处理 Future：\n* 使用 `async` 和 `await`\n* 使用 Future API，查看 [the library tour](https://dart.dev/guides/libraries/library-tour#future)\n\n`async` 和 `await` 使用：\n```Dart\nawait lookUpVersion();\n```\n\n使用 `await` 的代码，必须要写在 *async* 函数内：\n```Dart\nFuture checkVersion() async {\n  var version = await lookUpVersion();\n}\n```\n\n`try`, `catch` 和 `finally` 用于处理 `await` 代码中的错误并执行清理代码：\n```Dart\ntry {\n  version = await lookUpVersion();\n} catch (e) {\n}\n```\n\n一个异步函数中，可使用多个 `await`，下述代码中，使用了三个 await 处理任务：\n```Dart\nvar entrypoint = await findEntrypoint();\nvar exitCode = await runExecutable(entrypoint, args);\nawait flushThenExit(exitCode);\n```\n\n在 `await expr` 中，`expr` 的值通常是 Future，如果不是，系统会自动用 Future 包装。该 Future 对象表示一个会返回对象的 promise。`await expr` 的值就是最终返回的对象。Await 表达式会阻塞代码直到返回最终的对象。\n\n**使用 `await` 的时候报了编译错误，确保 `await` 实在异步函数中。** 比如，想在 `main()` 函数中使用 `await`，那么函数体必须标记为 `async`：\n```Dart\nFuture main() async {\n  checkVersion();\n  print('In main: version is ${await lookUpVersion()}');\n}\n```\n\n### 13.2 声明异步函数\n\n异步函数的函数体用 `async` 标记。\n\n为函数添加 `async` 关键字，使得函数返回 Future。如下例子：\n```Dart\nString lookUpVersion() => '1.0.0';\n\nFuture<String> lookUpVersion() async => '1.0.0';\n```\n从上述代码可知，Dart 自动用 Future 包装返回值。\n\n如果函数没有实际返回值，就返回 `Future<void>`。\n\n### 13.3 处理流\n\n两种方式从流(Stream)中获取值：\n* 用 `async` 和 *asynchronous for loop*(`await for`)\n* 使用 [Stream API](https://dart.dev/guides/libraries/library-tour#stream)\n\n异步循环格式：\n```Dart\nawait for (varOrType identifier in expression) {\n\n}\n```\n上述代码中，`expression` 必须是 Stream 类型。代码执行顺序：\n1. 等待流释放一个值\n2. 变量被赋值为 (1) 释放的值，并执行循环体\n3. 重复步骤(1), (2)，直到流被关闭\n\n使用 `break` 或 `return` 停止监听流，执行命令后会跳出循环并对流取消订阅\n\n**当实现一个异步循环的时候，报编译错误，确保 `await for` 代码实在异步函数中。** 比如，在 `main()` 函数中使用异步循环，将 `main()` 函数体标记为 `async`：\n```Dart\nFuture main() async {\n  await for (var request in requestServer) {\n    handleRequest(request);\n  }\n}\n```\n\n更多异步编程信息，查看 [*dart:async*](https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming)。\n\n## 14. 生成器\n\n用 *生成器函数* 惰性生成一些列值。Dart 自带两种生成器：\n* **Synchronous** 生成器：返回一个 [*Iterable*](https://api.dart.dev/stable/dart-core/Iterable-class.html) 对象\n* **Asynchronous** 生成器：返回一个 [*Stream*](https://api.dart.dev/stable/dart-async/Stream-class.html) 对象\n\n实现 **synchronous** 生成器函数方法：用 `sync*` 标记函数体，并用 `yield` 语句发送值：\n```Dart\nIterable<Int> naturalTo(int n) sync* {\n  int k = 0;\n  while (k < n) {\n    yield k++;\n  }\n}\n```\n\n实现 **asynchronous** 生成器函数方法：用 `async*` 标记函数体，并用 `yield` 发送值：\n```Dart\nStream<Int> asynchronousNaturalTo(int n) async* {\n  int k = 0;\n  while (k < n) {\n    yield k++;\n  }\n}\n```\n\n递归生成器，用 `yield*` 改进性能：\n```Dart\nIterable<Int> naturalsDownFrom(int n) sync* {\n  if (n > 0) {\n    yield n;\n    yield* naturalsDownFrom(n - 1);\n  }\n}\n```\n\n## 15. 可调用的类\n\n类实现 `call()` 方法后，该类的实例可以像函数一样被调用。\n\n如下例子，`WannabeFunction` 类实现了 call() 函数：\n```Dart\nclass WannabeFunction {\n  call(String a, String b, String c) {\n    return '$a $b $c!';\n  }\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf('Hi', 'there', 'gang');\n  print(out);\n}\n```\n\n## 16. 独立性\n\n多数计算机包括手机都有多核 CPU。开发者通常用共享内存的线程并发执行程序，以提高 CPU 利用率。然而，共享状态的并发执行更易出错，也使得代码更加复杂。\n\nDart 用 *isolate* 替代线程。每个 isolate 有自己的堆内存，以确保 isolates 之间不会共享状态。\n\n更多信息查看 [dart:isolate library document](https://api.dart.dev/stable/dart-isolate)。\n\n## 17. 类型定义\n\nDart 中，函数同字符串和数值一样都是对象。*Typedef* 或者说 *funtion-type alias* 给函数定义个名字，在其它地方使用。类型定义会保留类型信息。\n\n```Dart\nclass SortedCollection {\n  Function compare;\n\n  SortedCollection(Function f) {\n    compare = f;\n  }\n}\n\nint sort(Object a, Object b) => 0;\n\nvoid main {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function);\n}\n```\n\n使用类型定义后：\n```Dart\ntypedef Compare = int Function(Object a, Object b);\n\nclass SortedCollection {\n  Compare compare;\n\n  SortedCollection(this.compare);\n}\n\nint sort(Object a, Object b) => 0;\n\nmain {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function); // true\n  print(coll.compare is Compare); // true\n}\n```\n\n类型定义结合泛型：\n```Dart\ntypedef Compare<T> = int Function(T a, Tb);\n\nint sort(int a, int b) => a - b;\n\nmain {\n  print(sort is Compare<Int>);\n}\n```\n\n## 18. 元数据\n\n元数据标注写法：`@` 开头，后跟着编译期常量或者常量构造器。\n\nDart 中两种标注对所有代码使用: `@deprecated` 和 `override`。\n```Dart\nclass Television {\n  @deprecated\n  void activate {\n\n  }\n}\n```\n\n自定义元数据标注：\n```Dart\nlibrary todo;\n\nclass Todo {\n  final String who;\n  final String what;\n\n  const Todo(this.who, this.what);\n}\n```\n使用自定义的元数据：\n```Dart\nimport 'todo.dart';\n\n@Todo('seth', 'make this do something')\nvoid doSomething() {\n\n}\n```\n元数据可以出现在以下指令前：库，类，类型定义，类型参数，构造器，工厂方法，字段，参数，变量声明，导入导出。运行时可通过 reflection 获取元数据。\n\n## 19. 注释\n\nDart 支持单行、多行和文档注释。\n\n## 20. 小结\n\n此文档摘录了 Dart 中较为通用的特性。此外，更多新特性正在开发，尽量兼容当前代码。下一步：[language specification](https://dart.dev/guides/language/spec) 和 [Effective Dart](https://dart.dev/guides/language/effective-dart)。\n\n了解更多关于 Dart 核心库，查看 [A Tour of the Dart Libraries](https://dart.dev/guides/libraries/library-tour)。\n\n","slug":"A-tour-of-the-dart-language","published":1,"updated":"2019-07-24T22:49:21.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyhubj9k0000g4xpv25we6zx","content":"<p>本文列出了 Dart 语言的每个主要功能的用法，从变量和运算符到类库。本文适用于有其他编程语言经验的开发者。<br>想学习更多 Dart 核心库的，请查看此<a href=\"https://dart.dev/guides/libraries/library-tour\" target=\"_blank\" rel=\"noopener\">文档</a>。想学习更多语言细节的，请查看此<a href=\"https://dart.dev/guides/language/spec\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<a id=\"more\"></a>\n\n<p>目录</p>\n<ul>\n<li><a href=\"#1-%e4%b8%80%e6%ae%b5%e5%9f%ba%e7%a1%80%e7%9a%84-dart-%e7%a8%8b%e5%ba%8f\">1. 一段基础的 Dart 程序</a></li>\n<li><a href=\"#2-%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5\">2. 重要概念</a></li>\n<li><a href=\"#3-%e5%85%b3%e9%94%ae%e5%ad%97\">3. 关键字</a></li>\n<li><a href=\"#4-%e5%8f%98%e9%87%8f\">4. 变量</a><ul>\n<li><a href=\"#41-%e9%bb%98%e8%ae%a4%e5%80%bc\">4.1 默认值</a></li>\n<li><a href=\"#42-final-%e5%92%8c-const-%e5%85%b3%e9%94%ae%e5%ad%97\">4.2 Final 和 const 关键字</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%e8%87%aa%e5%b8%a6%e7%b1%bb%e5%9e%8b\">5. 自带类型</a><ul>\n<li><a href=\"#51-%e6%95%b0%e5%80%bc\">5.1 数值</a></li>\n<li><a href=\"#52-%e5%ad%97%e7%ac%a6%e4%b8%b2\">5.2 字符串</a></li>\n<li><a href=\"#53-%e5%b8%83%e5%b0%94\">5.3 布尔</a></li>\n<li><a href=\"#54-%e6%95%b0%e7%bb%84\">5.4 数组</a></li>\n<li><a href=\"#55-%e9%9b%86\">5.5 集</a></li>\n<li><a href=\"#56-%e8%a1%a8\">5.6 表</a></li>\n<li><a href=\"#57-runes\">5.7 Runes</a></li>\n<li><a href=\"#58-%e7%ac%a6%e5%8f%b7\">5.8 符号</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%e5%87%bd%e6%95%b0\">6. 函数</a><ul>\n<li><a href=\"#61-%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0\">6.1 可选参数</a></li>\n<li><a href=\"#62-main-%e5%87%bd%e6%95%b0\">6.2 main() 函数</a></li>\n<li><a href=\"#63-%e4%b8%80%e7%ad%89%e5%85%ac%e6%b0%91%e5%87%bd%e6%95%b0\">6.3 一等公民函数</a></li>\n<li><a href=\"#64-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0\">6.4 匿名函数</a></li>\n<li><a href=\"#65-%e4%bd%9c%e7%94%a8%e5%9f%9f\">6.5 作用域</a></li>\n<li><a href=\"#66-%e8%af%8d%e6%b3%95%e9%97%ad%e5%8c%85\">6.6 词法闭包</a></li>\n<li><a href=\"#67-%e5%87%bd%e6%95%b0%e7%9a%84%e7%ad%89%e4%bb%b7%e6%80%a7\">6.7 函数的等价性</a></li>\n<li><a href=\"#68-%e8%bf%94%e5%9b%9e%e5%80%bc\">6.8 返回值</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%e8%bf%90%e7%ae%97%e7%ac%a6\">7. 运算符</a><ul>\n<li><a href=\"#71-%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6\">7.1 算数运算符</a></li>\n<li><a href=\"#72-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e6%b3%95\">7.2 关系运算法</a></li>\n<li><a href=\"#73-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e8%bf%90%e7%ae%97%e7%ac%a6\">7.3 类型推断运算符</a></li>\n<li><a href=\"#74-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6\">7.4 赋值运算符</a></li>\n<li><a href=\"#75-%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6\">7.5 逻辑运算符</a></li>\n<li><a href=\"#76-%e4%bd%8d%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6\">7.6 位移运算符</a></li>\n<li><a href=\"#77-%e6%9d%a1%e4%bb%b6%e8%a1%a8%e8%be%be%e5%bc%8f\">7.7 条件表达式</a></li>\n<li><a href=\"#78-%e5%a4%9a%e7%ba%a7%e8%a1%a8%e7%a4%ba%e6%b3%95\">7.8 多级表示法</a></li>\n<li><a href=\"#79-%e5%85%b6%e5%ae%83\">7.9 其它</a></li>\n</ul>\n</li>\n<li><a href=\"#8-%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5\">8. 控制语句</a><ul>\n<li><a href=\"#81-if-else\">8.1 If else</a></li>\n<li><a href=\"#82-for-%e5%be%aa%e7%8e%af\">8.2 For 循环</a></li>\n<li><a href=\"#83-while--do-while\">8.3 While &amp; do-while</a></li>\n<li><a href=\"#84-break--continue\">8.4 Break &amp; continue</a></li>\n<li><a href=\"#85-switch-case\">8.5 Switch case</a></li>\n<li><a href=\"#86-%e6%96%ad%e8%a8%80\">8.6 断言</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86\">9. 异常处理</a><ul>\n<li><a href=\"#91-throw\">9.1 Throw</a></li>\n<li><a href=\"#92-catch\">9.2 Catch</a></li>\n<li><a href=\"#93-finally\">9.3 Finally</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%e7%b1%bb\">10. 类</a><ul>\n<li><a href=\"#101-%e4%bd%bf%e7%94%a8%e7%b1%bb%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f\">10.1 使用类成员变量</a></li>\n<li><a href=\"#102-%e4%bd%bf%e7%94%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">10.2 使用构造函数</a></li>\n<li><a href=\"#103-%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b\">10.3 获取对象类型</a></li>\n<li><a href=\"#104-%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f\">10.4 实例变量</a></li>\n<li><a href=\"#105-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">10.5 构造函数</a></li>\n<li><a href=\"#106-%e6%96%b9%e6%b3%95\">10.6 方法</a></li>\n<li><a href=\"#107-%e6%8a%bd%e8%b1%a1%e7%b1%bb\">10.7 抽象类</a></li>\n<li><a href=\"#108-%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3\">10.8 隐式接口</a></li>\n<li><a href=\"#109-%e6%89%a9%e5%b1%95%e7%b1%bb\">10.9 扩展类</a></li>\n<li><a href=\"#1010-%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b\">10.10 枚举类型</a></li>\n<li><a href=\"#1011-%e7%b1%bb%e6%b7%bb%e5%8a%a0%e7%89%b9%e6%80%a7\">10.11 类添加特性</a></li>\n<li><a href=\"#1012-%e7%b1%bb%e5%8f%98%e9%87%8f%e5%92%8c%e6%96%b9%e6%b3%95\">10.12 类变量和方法</a></li>\n</ul>\n</li>\n<li><a href=\"#11-%e6%b3%9b%e5%9e%8b\">11. 泛型</a><ul>\n<li><a href=\"#111-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b\">11.1 为什么使用泛型</a></li>\n<li><a href=\"#112-%e4%bd%bf%e7%94%a8%e9%9b%86%e5%90%88%e5%ad%97%e9%9d%a2%e5%80%bc\">11.2 使用集合字面值</a></li>\n<li><a href=\"#113-%e4%bd%bf%e7%94%a8%e5%b8%a6%e5%8f%82%e6%95%b0%e5%8c%96%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">11.3 使用带参数化类型的构造函数</a></li>\n<li><a href=\"#114-%e6%b3%9b%e5%9e%8b%e9%9b%86%e5%90%88\">11.4 泛型集合</a></li>\n<li><a href=\"#115-%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f\">11.5 泛型约束</a></li>\n<li><a href=\"#116-%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95\">11.6 使用泛型方法</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%e5%ba%93\">12. 库</a><ul>\n<li><a href=\"#121-%e4%bd%bf%e7%94%a8%e5%ba%93\">12.1 使用库</a></li>\n<li><a href=\"#122-%e5%ae%9e%e7%8e%b0%e5%ba%93\">12.2 实现库</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%e5%bc%82%e6%ad%a5\">13. 异步</a><ul>\n<li><a href=\"#131-%e5%a4%84%e7%90%86-future\">13.1 处理 Future</a></li>\n<li><a href=\"#132-%e5%a3%b0%e6%98%8e%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0\">13.2 声明异步函数</a></li>\n<li><a href=\"#133-%e5%a4%84%e7%90%86%e6%b5%81\">13.3 处理流</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%e7%94%9f%e6%88%90%e5%99%a8\">14. 生成器</a></li>\n<li><a href=\"#15-%e5%8f%af%e8%b0%83%e7%94%a8%e7%9a%84%e7%b1%bb\">15. 可调用的类</a></li>\n<li><a href=\"#16-%e7%8b%ac%e7%ab%8b%e6%80%a7\">16. 独立性</a></li>\n<li><a href=\"#17-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89\">17. 类型定义</a></li>\n<li><a href=\"#18-%e5%85%83%e6%95%b0%e6%8d%ae\">18. 元数据</a></li>\n<li><a href=\"#19-%e6%b3%a8%e9%87%8a\">19. 注释</a></li>\n<li><a href=\"#20-%e5%b0%8f%e7%bb%93\">20. 小结</a></li>\n</ul>\n<h2 id=\"1-一段基础的-Dart-程序\"><a href=\"#1-一段基础的-Dart-程序\" class=\"headerlink\" title=\"1. 一段基础的 Dart 程序\"></a>1. 一段基础的 Dart 程序</h2><p>从以下代码片段感受下 Dart 语言的特性：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Define a function.</span></span><br><span class=\"line\">printIteger(<span class=\"built_in\">int</span> number) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'The number is $number'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This is where the app starts executing.</span></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"number\">42</span>; <span class=\"comment\">// Declare and initialize a variable.</span></span><br><span class=\"line\">    printInteger(number); <span class=\"comment\">// Call a function.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段程序使用的特性适用于其他所有 Dart 应用：</p>\n<p>// This is a comment.<br><br>一个单行注释。另外，Dart 也支持多行和文档注视。更多信息看<a href=\"https://dart.dev/guides/language/language-tour#comments\" target=\"_blank\" rel=\"noopener\">注释文档</a>。</p>\n<p>int<br><br>Dart 自带类型之一，其他的还有 <em>String</em>, <em>List</em> 和 <em>bool</em>。</p>\n<p>42<br><br>数值字面值，编译时期常量。</p>\n<p>print()<br><br>打印输出。</p>\n<p>‘…’ 或者 “…”<br><br>字符串字面值。</p>\n<p>$variableNmae 或者 ${variableName}<br><br>字符串差值写法。更多请查看<a href=\"https://dart.dev/guides/language/language-tour#strings\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>main()<br><br>App 执行入口，每个应用必须有。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#the-main-function\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"2-重要概念\"><a href=\"#2-重要概念\" class=\"headerlink\" title=\"2. 重要概念\"></a>2. 重要概念</h2><p>学习 Dart 过程中，牢记以下概念：<br></p>\n<ul>\n<li>任何可以存到变量中的都是对象，每个对象都是类的实例。数值、函数和 <code>null</code> 都是对象。所有对象都继承自 <a href=\"https://api.dart.dev/stable/dart-core/Object-class.html\" target=\"_blank\" rel=\"noopener\">Object</a> 类。</li>\n<li>虽然 Dart 是强类型的，但类型声明是可选的，因为 Dart 有类型推断。上述代码中， <code>number</code> 并没有声明类型，被自动推断成 <code>int</code>j。可以使用<a href=\"https://dart.dev/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed\" target=\"_blank\" rel=\"noopener\">特定的动态类型</a>，来声明任意类型的变量。</li>\n<li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code> 和 <code>List&lt;dynamic&gt;</code>。</li>\n<li>Dart 支持将函数声明在类内部（<em>实例方法</em>）和外部（<em>静态方法</em>），也支持<em>嵌套函数</em>。</li>\n<li>类似的，Dart 也支持将变量声明在类内部（<em>实例变量<em>）和外部（</em>静态变量<em>）。实例变量也叫做域(</em>field</em>)或属性(<em>property</em>)。</li>\n<li>不同于 Java，Dart 没有 <code>public</code>, <code>protected</code> 和 <code>private</code> 关键字。可以使用 <code>_</code> 开头的标识符来表示变量是库内私有的。更多信息请看<a href=\"https://dart.dev/guides/language/language-tour#libraries-and-visibility\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n<li>标识符以字母和下划线开头，后面可以跟字母数字下划线。</li>\n<li>Dart 有表达式(<em>expressions</em>)和语句(<em>statements</em>)。</li>\n<li>Dart 工具有两种报错类型：<em>警告</em>和<em>错误</em>。警告表示代码运行结果可能不同于期望，但不会使程序退出。错误分为编译期和运行时。编译器错误会导致程序无法启动，运行时错误会导致程序运行时抛出异常。</li>\n</ul>\n<h2 id=\"3-关键字\"><a href=\"#3-关键字\" class=\"headerlink\" title=\"3. 关键字\"></a>3. 关键字</h2><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"right\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">abstract<sup>2</sup></td>\n<td align=\"center\">dynamic<sup>2</sup></td>\n<td align=\"center\">implements<sup>2</sup></td>\n<td align=\"right\">show<sup>1</sup></td>\n</tr>\n<tr>\n<td align=\"left\">as<sup>2</sup></td>\n<td align=\"center\">else</td>\n<td align=\"center\">import<sup>2</sup></td>\n<td align=\"right\">static<sup>2</sup></td>\n</tr>\n<tr>\n<td align=\"left\">assert</td>\n<td align=\"center\">enum</td>\n<td align=\"center\">in</td>\n<td align=\"right\">super</td>\n</tr>\n<tr>\n<td align=\"left\">async<sup>1</sup></td>\n<td align=\"center\">export<sup>2</sup></td>\n<td align=\"center\">interface<sup>2</sup></td>\n<td align=\"right\">switch</td>\n</tr>\n<tr>\n<td align=\"left\">await<sup>3</sup></td>\n<td align=\"center\">extends</td>\n<td align=\"center\">is</td>\n<td align=\"right\">sync<sup>1</sup></td>\n</tr>\n<tr>\n<td align=\"left\">break</td>\n<td align=\"center\">external<sup>2</sup></td>\n<td align=\"center\">library<sup>2</sup></td>\n<td align=\"right\">this</td>\n</tr>\n<tr>\n<td align=\"left\">case</td>\n<td align=\"center\">factory<sup>2</sup></td>\n<td align=\"center\">mixin<sup>2</sup></td>\n<td align=\"right\">throw</td>\n</tr>\n<tr>\n<td align=\"left\">catch</td>\n<td align=\"center\">false</td>\n<td align=\"center\">new</td>\n<td align=\"right\">true</td>\n</tr>\n<tr>\n<td align=\"left\">class</td>\n<td align=\"center\">final</td>\n<td align=\"center\">null</td>\n<td align=\"right\">try</td>\n</tr>\n<tr>\n<td align=\"left\">const</td>\n<td align=\"center\">finally</td>\n<td align=\"center\">on<sup>1</sup></td>\n<td align=\"right\">typedef<sup>2</sup></td>\n</tr>\n<tr>\n<td align=\"left\">continue</td>\n<td align=\"center\">for</td>\n<td align=\"center\">operator<sup>2</sup></td>\n<td align=\"right\">var</td>\n</tr>\n<tr>\n<td align=\"left\">convariant<sup>2</sup></td>\n<td align=\"center\">Function<sup>2</sup></td>\n<td align=\"center\">part<sup>2</sup></td>\n<td align=\"right\">void</td>\n</tr>\n<tr>\n<td align=\"left\">default</td>\n<td align=\"center\">get<sup>2</sup></td>\n<td align=\"center\">rethrow</td>\n<td align=\"right\">while</td>\n</tr>\n<tr>\n<td align=\"left\">deferred<sup>2</sup></td>\n<td align=\"center\">hide<sup>1</sup></td>\n<td align=\"center\">return</td>\n<td align=\"right\">with</td>\n</tr>\n<tr>\n<td align=\"left\">do</td>\n<td align=\"center\">if</td>\n<td align=\"center\">set<sup>2</sup></td>\n<td align=\"right\">yield<sup>3</sup></td>\n</tr>\n</tbody></table>\n<p>尽量避免使用以上关键字作为标识符。如果不可避免需要使用，可以用上角标标记：</p>\n<ul>\n<li>角标 1 单词是上下文相关的，只有在特定位置才有意义。他们可以在任意位置使用。</li>\n<li>角标 2 单词是自带标识符。为简化 JS 代码移植到 Dart 的难度，这些关键字不能用作类或者类型的名字以及导入的前缀。</li>\n<li>角标 3 单词是少有的几个跟异步操作相关的关键字，Dart 1.0 发布后才加入。不能在任何标记 <code>async</code>, <code>async*</code> 以及 <code>sync*</code> 的函数体中使用 <code>await</code> 和 <code>yield</code> 作为标识符。</li>\n</ul>\n<p>剩余的关键字是保留使用的，不能作为标识符。</p>\n<h2 id=\"4-变量\"><a href=\"#4-变量\" class=\"headerlink\" title=\"4. 变量\"></a>4. 变量</h2><p>创建并初始化一个变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>变量保存引用，<code>name</code> 变量保存对一个 <code>String</code> 对象的引用。</p>\n<p><code>name</code> 变量推断成 <code>String</code> 类型，也可以通过显示声明类型修改。如果对象不是限制为单一类型，可以使用 <code>Object</code> 或 <code>dynamic</code> 修饰。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dynamic</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>另一种方式是显示声明类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-默认值\"><a href=\"#4-1-默认值\" class=\"headerlink\" title=\"4.1 默认值\"></a>4.1 默认值</h3><p>未主动初始化的变量默认初始化为 <code>null</code>。即使是数值类型也是如此，在 Dart 的世界里，万物皆对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> lineCount;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;lineCount == <span class=\"keyword\">null</span>&#125;</span>'</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-Final-和-const-关键字\"><a href=\"#4-2-Final-和-const-关键字\" class=\"headerlink\" title=\"4.2 Final 和 const 关键字\"></a>4.2 Final 和 const 关键字</h3><p>对于初始化后就不再修改的变量，使用 <code>final</code> 或 <code>const</code> 替代 <code>var</code> 或者类型。final 变量只能设置一次，const 变量是一个编译期常量。一个顶层(top-level)的类变量在第一次使用的时候初始化。</p>\n<p>创建并设置一个 final 变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> name = <span class=\"string\">'Bab'</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"built_in\">String</span> nickname = <span class=\"string\">'Bobby'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>不能修改 final 变量的值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">'Alice'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>const</code> 创建<strong>编译期常量</strong>。如果是静态常量，使用 <code>static const</code> 修饰。常量必须在声明的时候用字面值或者算术表达式初始化:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">double</span> atm = <span class=\"number\">1.01325</span> * bar;</span><br></pre></td></tr></table></figure>\n\n<p><code>const</code> 关键字不仅限于声明常量，还可以用于创建常量的值，以及声明构造函数用于创建常量值。任意变量都可以有一个常量值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">const</span> [];</span><br><span class=\"line\"><span class=\"keyword\">final</span> bar = <span class=\"keyword\">const</span> [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = [];</span><br></pre></td></tr></table></figure>\n\n<p>当用 <code>const</code> 声明一个常量，可以省略初始化表达式中的 <code>const</code>。</p>\n<p>对于非 const 或 非 final 声明的变量，即使之前存的值是一个常量，仍然可以修改：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"comment\">// 之前是 []</span></span><br></pre></td></tr></table></figure>\n\n<p>但是不能修改一个 const 变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baz = [<span class=\"number\">42</span>]; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-自带类型\"><a href=\"#5-自带类型\" class=\"headerlink\" title=\"5. 自带类型\"></a>5. 自带类型</h2><p>Dart 对以下类型做了特殊支持：</p>\n<ul>\n<li>numbers</li>\n<li>strings</li>\n<li>booleans</li>\n<li>lists</li>\n<li>sets</li>\n<li>maps</li>\n<li>runes(用于在字符串中表达 Unicode 字符)</li>\n<li>symbols</li>\n</ul>\n<p>可以用以上任意类型的字面值初始化对象。比如，<code>this is a string</code> 是一个字符串字面值，<code>true</code> 是一个布尔字面值。</p>\n<p>因为 Dart 中的变量都保存一个对象的引用，所以可用构造器（<em>constructors</em>)初始化变量。部分自带类型有自己的构造器。比如，用 <code>Map()</code> 创建一个表。</p>\n<h3 id=\"5-1-数值\"><a href=\"#5-1-数值\" class=\"headerlink\" title=\"5.1 数值\"></a>5.1 数值</h3><p>Dart 支持两种数值：</p>\n<p>int<br><br>整型值。</p>\n<p>double<br><br>64位浮点数。</p>\n<p><code>int</code>, <code>float</code> 都是 num 子类（subtypes)。num 定义了 +, -, * 和 /，以及 <code>abs()</code>, <code>ceil()</code> 和 <code>floor()</code> 等方法（位运算符定义在 <code>int</code>）。其他方法可能定义在 <code>dart:math</code> 库中。</p>\n<p>整型值是不带小数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hex = <span class=\"number\">0xDEADBEEF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果数值包含小数，那它就是 double。浮点数字面值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> exponents = <span class=\"number\">1.42e5</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串和数值相互转换：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String -&gt; int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"built_in\">int</span>.parse(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(one == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String -&gt; double</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> onePointOne = <span class=\"built_in\">double</span>.parse(<span class=\"string\">'1.1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(onePointOne == <span class=\"number\">1.1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// int -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> oneAsString= <span class=\"number\">1.</span>toString();</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(oneAsString == <span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> piAsString = <span class=\"number\">3.14159</span>.toStringAsFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(piAsString == <span class=\"string\">'3.14'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>整型的位操作：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">1</span>) == <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>) == <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> | <span class=\"number\">4</span>) == <span class=\"number\">7</span>);</span><br></pre></td></tr></table></figure>\n\n<p>数值字面值是编译期常量。算术表达式包含的操作数都是编译期常量，那么该表达式也是编译期常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> msPerSecond = <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondsUntilRetry = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> msUntilRetry = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-字符串\"><a href=\"#5-2-字符串\" class=\"headerlink\" title=\"5.2 字符串\"></a>5.2 字符串</h3><p>Dart 字符串是 UTF-16 单元码的序列。可以用单引号或双引号创建字符串。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'Single quotes work well for string literals'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">\"Double quotes work just as well\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'It\\'s easy to escape the string delimeter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">\"It's even easier to use the other delimeter\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串包含表达式的方式，用 <code>${expression}</code>。如果表达式是个标识符，可以省略 {}。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'string interpolation'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'Dart has $s, which is very handy.'</span> ==</span><br><span class=\"line\">    <span class=\"string\">'Dart has string interpolation, '</span> +</span><br><span class=\"line\">        <span class=\"string\">'which is very handy.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'That deserves all caps. '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;s.toUpperCase()&#125;</span> is very handy!'</span> ==</span><br><span class=\"line\">    <span class=\"string\">'That deserves all caps. '</span> +</span><br><span class=\"line\">        <span class=\"string\">'STRING INTERPOLATION is very handy!'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>拼接字符串可以用 <code>+</code> 运算符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'String '</span></span><br><span class=\"line\">    <span class=\"string\">'concatenation'</span></span><br><span class=\"line\">    <span class=\"string\">\" works even over line breaks.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(s1 ==</span><br><span class=\"line\">    <span class=\"string\">'String concatenation works even over '</span></span><br><span class=\"line\">        <span class=\"string\">'line breaks.'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'The + operator '</span> + <span class=\"string\">'works, as well.'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(s2 == <span class=\"string\">'The + operator works, as well.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建多行字符串的方式：使用 <code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">You can create</span></span><br><span class=\"line\"><span class=\"string\">multi-line strings like this one.</span></span><br><span class=\"line\"><span class=\"string\">'''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">\"\"\"This is also a</span></span><br><span class=\"line\"><span class=\"string\">multi-line string.\"\"\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建原始的字符串方式：使用 <code>r</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">r'In a raw string, not even \\n gets special treatment.'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串字面值是编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// These work in a const string.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstBool = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstString = <span class=\"string\">'a constant string'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// These do NOT work in a const string.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> aNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aBool = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aString = <span class=\"string\">'a string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstList = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> validConstString = <span class=\"string\">'$aConstNum $aConstBool $aConstString'</span>;</span><br><span class=\"line\"><span class=\"comment\">// const invalidConstString = '$aNum $aBool $aString $aConstList';</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-布尔\"><a href=\"#5-3-布尔\" class=\"headerlink\" title=\"5.3 布尔\"></a>5.3 布尔</h3><p>Dart 用 <code>bool</code> 表示布尔值。只有两个对象有布尔类型：布尔字面值 <code>true</code> 和 <code>false</code>，两者都是编译期常量。</p>\n<p>Dart 是类型安全的，意味着 <code>if (nonbooleanValue)</code> 或者 <code>assert (nonbooleanValue)</code> 是不合法的。应该用显式的值校验：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Check for an empty string.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fullName = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(fullName.isEmpty);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for zero.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hitPoints = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(hitPoints &lt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for null.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> unicorn;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(unicorn == <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for NaN.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iMeantToDoThis = <span class=\"number\">0</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-数组\"><a href=\"#5-4-数组\" class=\"headerlink\" title=\"5.4 数组\"></a>5.4 数组</h3><p>几乎在所有编程语言中，最通用的集合(collection)是<em>数组*或者说是对象组。Dart 中，数组是 *List</em> 对象。</p>\n<p>Dart 数组字面值类似 JS。例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>数组索引范围[0, list.length-1]：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list.length == <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list[<span class=\"number\">1</span>] == <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list[<span class=\"number\">1</span>] == <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建编译期常量的数组方法，在数组字面值前加 <code>const</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> constantList = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">constantList[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 中引入了 <strong>展开操作符(spread operator(…))</strong> 和 <strong>可空的(null-aware)展开操作符(…?)</strong>，两者都提供了将多个元素插入集合的便捷方法。</p>\n<p>如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [<span class=\"number\">0</span>, ...list];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2.length == <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果展开操作符右边表达式可能为空，可用 <code>...?</code> 来避免异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list:</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [<span class=\"number\">0</span>, ...?list];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2.length == <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>另外，Dart 2.3 还引入了 <strong>collection if</strong> 和 <strong>collection for</strong>，用来构造集合。</p>\n<p><strong>Collection if</strong> 例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nav = [</span><br><span class=\"line\">    <span class=\"string\">'Home'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Furniture'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Plants'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promoActive) <span class=\"string\">'Outlet'</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>Collection for</strong> 例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [</span><br><span class=\"line\">    <span class=\"string\">'#0'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> list1) <span class=\"string\">'#$i'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2[<span class=\"number\">1</span>] == <span class=\"string\">'#1'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-集\"><a href=\"#5-5-集\" class=\"headerlink\" title=\"5.5 集\"></a>5.5 集</h3><p>Dart 集无序且元素唯一。Dart 通过两方面支持集，一个是字面值，另一个是 <code>Set</code> 类型。</p>\n<p>字面值创建集对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> halogens = &#123;<span class=\"string\">'fluorine'</span>, <span class=\"string\">'chlorine'</span>, <span class=\"string\">'bromine'</span>, <span class=\"string\">'iodine'</span>, <span class=\"string\">'astatine'</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建空集：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; set2 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;; <span class=\"comment\">// Create a map, not a set.</span></span><br></pre></td></tr></table></figure>\n\n<p>集添加元素，<code>add()</code> 或者 <code>addAll()</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\">set1.add(<span class=\"string\">'fluorine'</span>);</span><br><span class=\"line\">set1.addAll(halogens);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>.length</code> 获取集的大小：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\">set1.add(<span class=\"string\">'fluorine'</span>);</span><br><span class=\"line\">set1.addAll(halogens);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(set1.length == <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建集的编译期字面值，集字面值前加 <code>const</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> constantSet = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">'fluorine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'chlorine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'bromine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'iodine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'astatine'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// constantSet.add('helium'); // Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 后，集也同数组一样，支持展开操作符和 collection fors 以及 ifs。</p>\n<h3 id=\"5-6-表\"><a href=\"#5-6-表\" class=\"headerlink\" title=\"5.6 表\"></a>5.6 表</h3><p>表包含键值对，键值可以是任意类型的对象。Key 在表中唯一，value 可以重复。Dart 通过两方面支持表，一个是字面值，另一个是 Map 类型。</p>\n<p>Dart 表的字面值例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Key:    Value</span></span><br><span class=\"line\">  <span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>,</span><br><span class=\"line\">  <span class=\"string\">'second'</span>: <span class=\"string\">'turtledoves'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fifth'</span>: <span class=\"string\">'golden rings'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也可以用构造函数创建的表对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">gifts[<span class=\"string\">'first'</span>] = <span class=\"string\">'partridge'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'second'</span>] = <span class=\"string\">'turtledoves'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'fifth'</span>] = <span class=\"string\">'golden rings'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">nobleGases[<span class=\"number\">2</span>] = <span class=\"string\">'helium'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">10</span>] = <span class=\"string\">'neon'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">18</span>] = <span class=\"string\">'argon'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对已有表中增加键值对：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\">gifts[<span class=\"string\">'fourth'</span>] = <span class=\"string\">'calling birds'</span>; <span class=\"comment\">// Add a key-value pair</span></span><br></pre></td></tr></table></figure>\n\n<p>从表中获取值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts[<span class=\"string\">'first'</span>] == <span class=\"string\">'partridge'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>从表中查不到对应的 key：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts[<span class=\"string\">'fifth'</span>] == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>用 <code>.length</code> 获取表中键值对数量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\">gifts[<span class=\"string\">'fourth'</span>] = <span class=\"string\">'calling birds'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts.length == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建表的编译期常量，表字面值前加 <code>const</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> constantMap = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 后，表也同数组一样，支持展开操作符和 collection fors 以及 ifs。</p>\n<h3 id=\"5-7-Runes\"><a href=\"#5-7-Runes\" class=\"headerlink\" title=\"5.7 Runes\"></a>5.7 Runes</h3><p>Dart runes 是字符串的 UTF-32 码点。</p>\n<p>Unicode 为全世界所有字母，数字和符号定义了唯一的数值。由于 Dart 字符串是 UTF-16 单元码的序列，因此在字符串中药表示 32位 Unicode 值需要特殊语法。</p>\n<p>通常表达一个 Unicode 码点的形式是 <code>\\uXXXX</code>，XXXX 是一个4位的16进制数。比如，爱心字符(♥)是 <code>\\u2665</code>。当指定多于或少于4位数字时，将值放在花括号中。</p>\n<p>String 类有一些相关属性获取 rune 信息。比如，<code>codeUnitAt</code> 和 <code>codeUnit</code> 属性返回16位的单元码，用 <code>runes</code> 属性获取字符串中的 runes。</p>\n<p>16位和32位转换：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping.codeUnits);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping.runes.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">  Runes input = <span class=\"keyword\">new</span> Runes(</span><br><span class=\"line\">      <span class=\"string\">'\\u2665  \\u&#123;1f605&#125;  \\u&#123;1f60e&#125;  \\u&#123;1f47b&#125;  \\u&#123;1f596&#125;  \\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCodes(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-8-符号\"><a href=\"#5-8-符号\" class=\"headerlink\" title=\"5.8 符号\"></a>5.8 符号</h3><p><em>符号</em> 对象代表 Dart 程序中的运算符或者标识符。你可能从不会用符号，但它们对于按名称引用标识符的 API 非常有用，因为缩小会更改标识符名称而不会更改标识符符号。</p>\n<p>获取符号的方法，<code>#</code> 号后面跟着标识符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#radix</span><br><span class=\"line\">#bar</span><br></pre></td></tr></table></figure>\n\n<p>符号字面值是编译期常量。</p>\n<h2 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6. 函数\"></a>6. 函数</h2><p>Dart 是真正的面向对象语言，即使是函数也有类型，<em>Funtion</em>。这意味着函数可以赋值给变量或者作为参数传递。还可以调用类的实例，就好像它是一个函数。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#callable-classes\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>函数的实现如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isNoble(<span class=\"built_in\">int</span> atomicNumber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然类型标注更为高效，但是省略类型的函数依然可用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNoble(atomicNumber) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于只有一个表达式的函数，可以简写为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isNoble(<span class=\"built_in\">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>=&gt; expr</code> 语法是 <code>{ return expr; } 的简写。</code>=&gt;` 标注通常推断为<em>箭头</em>语法。</p>\n<p>函数参数支持两种类型：必需(required)和可选(optional)。必需参数在前，可选参数在后。命名为可选的参数仍然可以标记为 <code>@required</code>。</p>\n<h3 id=\"6-1-可选参数\"><a href=\"#6-1-可选参数\" class=\"headerlink\" title=\"6.1 可选参数\"></a>6.1 可选参数</h3><p>通过位置或命名中的一种来标记可选参数，但不能两者同时使用。</p>\n<h4 id=\"可选命名参数\"><a href=\"#可选命名参数\" class=\"headerlink\" title=\"可选命名参数 \"></a>可选命名参数 <!-- omit in toc --></h4><p>调用一个函数，可通过 <code>paramName: value</code> 指定命名的参数，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enableFlags(bold: <span class=\"keyword\">true</span>, hidde: <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在定义函数的时候，使用 <code>{param1, param2, ...}</code> 指定命名参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> enableFlags(&#123;<span class=\"built_in\">bool</span> bold, <span class=\"built_in\">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Flutter</em> 实例创建表达式较为复杂，所以 widget 构造函数只使用命名的参数。这能让实例创建表达式可读性更高。</p>\n<p>你可以在任意的 Dart 代码中使用 <code>@required</code> 来标记命名的参数，从而指定该参数为<em>必需</em>参数。举例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Scrollbar(&#123;Key key, <span class=\"meta\">@required</span> Widget child&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当构造一个 <code>Scrollbar</code> 时，如果 <code>child</code> 参数缺省，编译器会报错。</p>\n<p><em>Required</em> 定义在 <em>meta</em> 包中。两种方式导入：import <code>package:meta/meta.dart</code> 或导入其它导出 <code>meta</code> 的包。</p>\n<h4 id=\"可选位置参数\"><a href=\"#可选位置参数\" class=\"headerlink\" title=\"可选位置参数 \"></a>可选位置参数 <!-- omit in toc --></h4><p>函数参数列表中，将后面的参数用 <code>[]</code> 标记：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg, [<span class=\"built_in\">String</span> device]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'$from says $msg'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"string\">'$result with a $device'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不带可选参数的调用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>) == <span class=\"string\">'Bob says Howdy'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>携带可选参数的调用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>, <span class=\"string\">'smoke signal'</span>) == <span class=\"string\">'Bob says Howdy with a smoke signal'</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值 \"></a>默认参数值 <!-- omit in toc --></h4><p>函数参数支持给定默认值，包括命名和位置参数。默认值是编译期常量。如果没有主动提供默认值，默认值为 <code>null</code>。</p>\n<p>默认值例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> enableFlags(&#123;<span class=\"built_in\">bool</span> bold = <span class=\"keyword\">false</span>, <span class=\"built_in\">bool</span> hidden = <span class=\"keyword\">false</span>&#125;) &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bold will be true; hidden will be false.</span></span><br><span class=\"line\">enableFlags(bold: <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为位置参数提供默认值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg,</span><br><span class=\"line\">    [<span class=\"built_in\">String</span> device = <span class=\"string\">'carrier pigeon'</span>, <span class=\"built_in\">String</span> mood]) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"string\">'$from says $msg'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (device != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">'$result with a $device'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mood != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">'$result (in a $mood mood)'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>) ==</span><br><span class=\"line\">    <span class=\"string\">'Bob says Howdy with a carrier pigeon'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>函数参数类型为数组或表类型，也支持默认值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> doStuff(</span><br><span class=\"line\">    &#123;<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; list = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; gifts = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"string\">'first'</span>: <span class=\"string\">'paper'</span>,</span><br><span class=\"line\">      <span class=\"string\">'second'</span>: <span class=\"string\">'cotton'</span>,</span><br><span class=\"line\">      <span class=\"string\">'third'</span>: <span class=\"string\">'leather'</span></span><br><span class=\"line\">    &#125;&#125;) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'list:  $list'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'gifts: $gifts'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-main-函数\"><a href=\"#6-2-main-函数\" class=\"headerlink\" title=\"6.2 main() 函数\"></a>6.2 main() 函数</h3><p>每个应用都有一个顶层的 <code>main()</code> 函数作为程序入口。该函数返回值为 <code>void</code> 并且有一个可选参数，类型为 <code>List&lt;String&gt;</code>。</p>\n<p>Web 程序的 <code>main()</code> 函数例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#sample_text_id'</span>);</span><br><span class=\"line\">    ..text = <span class=\"string\">'Click me!'</span>;</span><br><span class=\"line\">    ..onClick.listen(reverseText);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命令行程序的 <code>main()</code> 函数例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Run the app like this: dart args.dart 1 test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt; arguments) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(arguments.length == <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"built_in\">int</span>.parse(arguments[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(arguments[<span class=\"number\">1</span>] == <span class=\"string\">'test'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用 <em>args library</em> 库定义并解析命令行参数。</p>\n<h3 id=\"6-3-一等公民函数\"><a href=\"#6-3-一等公民函数\" class=\"headerlink\" title=\"6.3 一等公民函数\"></a>6.3 一等公民函数</h3><p>函数可以作为其它函数的参数，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> printElement(<span class=\"built_in\">int</span> element) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pass printElement as aparameter.</span></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></table></figure>\n\n<p>函数也可以存到变量中，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loudify = (msg) =&gt; <span class=\"string\">'!!! <span class=\"subst\">$&#123;msg.toUpperCase()&#125;</span>!!!'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(loudify(<span class=\"string\">'hello'</span>) == <span class=\"string\">'!!!HELLO!!!'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面使用了匿名函数。</p>\n<h3 id=\"6-4-匿名函数\"><a href=\"#6-4-匿名函数\" class=\"headerlink\" title=\"6.4 匿名函数\"></a>6.4 匿名函数</h3><p>大多函数都有名字，比如 <code>main()</code> 和 <code>printElement()</code>，一些没有名字的函数叫做 <em>匿名函数(Anonymous funstions)<em>、</em>lambda</em> 或 <em>闭包(closure)</em>。函数存到变量中，可以被添加到集合中或者被移除。</p>\n<p>匿名函数和一般函数类似，0个或多个参数，参数间用逗号隔开，支持可选类型标注，参数用 <code>()</code> 包含。</p>\n<p>匿名函数如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([<span class=\"built_in\">Type</span>] param1[, ...]) &#123;</span><br><span class=\"line\">  codeBlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下例子定义一个匿名函数，函数携带一个未定义类型的参数 <code>item</code>。每遍历一个 list 中元素，函数都会被调用一次，并打印对应元素的信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'oranges'</span>];</span><br><span class=\"line\">list.forEach((item) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数也可以简写成箭头函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.forEach((item) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-作用域\"><a href=\"#6-5-作用域\" class=\"headerlink\" title=\"6.5 作用域\"></a>6.5 作用域</h3><p>Dart 是一种 <em>lexically scoped language</em>。代码的布局决定了变量的作用域。</p>\n<p>以下例子展示了嵌套函数的变量作用域：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> topLevel = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> insideMain = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> myFunction() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> insideFunction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> nestedFunction() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> insideNestedFunction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(topLevel);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideMain);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideFunction);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideNestedFunction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-6-词法闭包\"><a href=\"#6-6-词法闭包\" class=\"headerlink\" title=\"6.6 词法闭包\"></a>6.6 词法闭包</h3><p><em>闭包</em> 是函数，能访问作用域内的变量，即使该闭包在原来作用域外部被使用。</p>\n<p>函数能延长变量的生命周期。以下例子中，<code>makeAdder()</code> 捕获变量 <code>addBy</code>。当函数执行结束，<code>addBy</code> 被保存到函数中。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Returns a function that adds [addBy] to the</span></span><br><span class=\"line\"><span class=\"comment\">/// function's argument.</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> addBy) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; addBy + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 2.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 4.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add4 = makeAdder(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add2(<span class=\"number\">3</span>) == <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add4(<span class=\"number\">3</span>) == <span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-7-函数的等价性\"><a href=\"#6-7-函数的等价性\" class=\"headerlink\" title=\"6.7 函数的等价性\"></a>6.7 函数的等价性</h3><p>以下例子中，比较了顶层函数，静态方法和实例方法的等价性:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> bar() &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> baz() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing top-level functions.</span></span><br><span class=\"line\">  x = foo;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(foo == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing static methods.</span></span><br><span class=\"line\">  x = A.bar;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(A.bar == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing instance methods.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = A();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = A();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = w;</span><br><span class=\"line\">  x = w.baz;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(y.baz == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(v.baz != w.baz);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```Dart</span><br><span class=\"line\"></span><br><span class=\"line\">### <span class=\"number\">6.8</span> 返回值</span><br><span class=\"line\"></span><br><span class=\"line\">所有函数都有返回值。如果没有显示指定，会默认在函数体最后加上 `<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>`。</span><br><span class=\"line\">```Dart</span><br><span class=\"line\">foo() &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo() == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-运算符\"><a href=\"#7-运算符\" class=\"headerlink\" title=\"7. 运算符\"></a>7. 运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">描述</th>\n<th align=\"center\">运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">一元后缀运算符</td>\n<td align=\"center\"><code>expr++</code>, <code>expr--</code>, <code>()</code>, <code>.</code>, <code>?.</code></td>\n</tr>\n<tr>\n<td align=\"center\">一元前缀运算符</td>\n<td align=\"center\"><code>-expr</code>, <code>!expr</code>, <code>~expr</code>, <code>++expr</code>, <code>--expr</code></td>\n</tr>\n<tr>\n<td align=\"center\">乘法（multiplicative）</td>\n<td align=\"center\"><code>*</code>, <code>/</code>, <code>%</code>, <code>~/</code></td>\n</tr>\n<tr>\n<td align=\"center\">加法</td>\n<td align=\"center\"><code>+</code>, <code>-</code></td>\n</tr>\n<tr>\n<td align=\"center\">位移</td>\n<td align=\"center\"><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></td>\n</tr>\n<tr>\n<td align=\"center\">位与</td>\n<td align=\"center\"><code>&amp;</code></td>\n</tr>\n<tr>\n<td align=\"center\">位异或</td>\n<td align=\"center\"><code>^</code></td>\n</tr>\n<tr>\n<td align=\"center\">位或</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\">关系运算和类型推断</td>\n<td align=\"center\"><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>as</code>, <code>is</code>, <code>is!</code></td>\n</tr>\n<tr>\n<td align=\"center\">等价</td>\n<td align=\"center\"><code>==</code>, <code>!=</code></td>\n</tr>\n<tr>\n<td align=\"center\">逻辑与</td>\n<td align=\"center\"><code>&amp;&amp;</code></td>\n</tr>\n<tr>\n<td align=\"center\">逻辑或</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\">可选判断</td>\n<td align=\"center\"><code>??</code></td>\n</tr>\n<tr>\n<td align=\"center\">条件</td>\n<td align=\"center\"><code>expr1 ? expr2 : expr3</code></td>\n</tr>\n<tr>\n<td align=\"center\">多级</td>\n<td align=\"center\"><code>..</code></td>\n</tr>\n<tr>\n<td align=\"center\">赋值</td>\n<td align=\"center\"><code>=</code>, <code>*=</code>, <code>/=</code>, <code>+=</code>, <code>-=</code>, <code>&amp;=</code>, <code>^=</code>, etc</td>\n</tr>\n</tbody></table>\n<p>运算符使用例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++</span><br><span class=\"line\">a + b</span><br><span class=\"line\">a = b</span><br><span class=\"line\">a == b</span><br><span class=\"line\">c ? a : b</span><br><span class=\"line\">a <span class=\"keyword\">is</span> T</span><br></pre></td></tr></table></figure>\n\n<p>上述表中的运算符优先从高到底排列。运算符优先级的作用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((n % i == <span class=\"number\">0</span>) &amp;&amp; (d % i ) == <span class=\"number\">0</span>) ...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span> &amp;&amp; d % i == <span class=\"number\">0</span>) ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-算数运算符\"><a href=\"#7-1-算数运算符\" class=\"headerlink\" title=\"7.1 算数运算符\"></a>7.1 算数运算符</h3><p>Dart 支持的算术运算符：<br>|  运算符 | 意义 |<br>| ——: | :— |<br>|     <code>+</code> | 加   |<br>|     <code>-</code> | 减   |<br>| <code>-expr</code> | 负号 |<br>|     <code>*</code> | 乘   |<br>|     <code>/</code> | 除   |<br>|    <code>~/</code> | 取商 |<br>|     <code>%</code> | 取模 |</p>\n<p>Dart 支持的递增/递减运算符：<br>| 运算符  |                  意义                   |<br>| :—–: | :————————————-: |<br>| <code>++var</code> |  <code>var = var + 1</code>(表达式的值是加后的值)  |<br>| <code>var++</code> | <code>var = var + 1</code>（表达式的值是加前的值） |<br>| <code>--var</code> | <code>var = var - 1</code>（表达式的值是减后的值） |<br>| <code>var--</code> | <code>var = var - 1</code>（表达式的值是减前的值） |</p>\n<h3 id=\"7-2-关系运算法\"><a href=\"#7-2-关系运算法\" class=\"headerlink\" title=\"7.2 关系运算法\"></a>7.2 关系运算法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>==</code></td>\n<td align=\"center\">相等</td>\n</tr>\n<tr>\n<td align=\"center\"><code>!=</code></td>\n<td align=\"center\">不等</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;</code></td>\n<td align=\"center\">大于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;</code></td>\n<td align=\"center\">小于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;=</code></td>\n<td align=\"center\">大于等于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;=</code></td>\n<td align=\"center\">小于等于</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-3-类型推断运算符\"><a href=\"#7-3-类型推断运算符\" class=\"headerlink\" title=\"7.3 类型推断运算符\"></a>7.3 类型推断运算符</h3><p>运行时用于类型校验：<br>| 运算符 |               意义               |<br>| :—-: | :——————————: |<br>|  <code>as</code>  | 类型推断(类型推断错误会抛出异常) |<br>|  <code>is</code>  |    对象是指定类型时返回 true     |<br>| <code>is!</code>  |   对象不是指定类型时返回 true    |</p>\n<h3 id=\"7-4-赋值运算符\"><a href=\"#7-4-赋值运算符\" class=\"headerlink\" title=\"7.4 赋值运算符\"></a>7.4 赋值运算符</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td><code>-=</code></td>\n<td><code>/=</code></td>\n<td><code>%\\</code></td>\n<td><code>&gt;&gt;=</code></td>\n<td><code>^=</code></td>\n</tr>\n<tr>\n<td><code>+=</code></td>\n<td><code>*=</code></td>\n<td><code>~/=</code></td>\n<td><code>&lt;&lt;=</code></td>\n<td><code>&amp;=</code></td>\n<td>`</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">联合赋值</th>\n<th align=\"center\">等价表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">op</td>\n<td align=\"center\"><code>a op= b</code></td>\n<td align=\"center\"><code>a= a op b</code></td>\n</tr>\n<tr>\n<td align=\"center\">例子</td>\n<td align=\"center\"><code>a += b</code></td>\n<td align=\"center\"><code>a = a + b</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"7-5-逻辑运算符\"><a href=\"#7-5-逻辑运算符\" class=\"headerlink\" title=\"7.5 逻辑运算符\"></a>7.5 逻辑运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>!expr</code></td>\n<td align=\"center\">逻辑非</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;&amp;</code></td>\n<td align=\"center\">逻辑与</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-6-位移运算符\"><a href=\"#7-6-位移运算符\" class=\"headerlink\" title=\"7.6 位移运算符\"></a>7.6 位移运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&amp;</code></td>\n<td align=\"center\">位与</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">位异或（相同为0，不同为1）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>~expr</code></td>\n<td align=\"center\">位取反（0-&gt;1, 1-&gt;0）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;&lt;</code></td>\n<td align=\"center\">左移一位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;&gt;</code></td>\n<td align=\"center\">右移一位</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-7-条件表达式\"><a href=\"#7-7-条件表达式\" class=\"headerlink\" title=\"7.7 条件表达式\"></a>7.7 条件表达式</h3><p>Dart 支持两个条件表达式：</p>\n<p><code>condition ? expr1 : expr2</code><br><br>如果条件为真，执行表达式1并返回结果；否则，执行表达式2并返回结果。</p>\n<p><code>expr1 ?? expr2</code><br><br>如果表达式1非空，返回其值；否则，执行表达式2并返回结果。</p>\n<h3 id=\"7-8-多级表示法\"><a href=\"#7-8-多级表示法\" class=\"headerlink\" title=\"7.8 多级表示法\"></a>7.8 多级表示法</h3><p>连续调用相同对象，使用 <code>..</code> 可以简化写法，减少使用临时变量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#confirm'</span>)</span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirm!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于以下写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#confirm'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>嵌套写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> addressBook = (</span><br><span class=\"line\">  AddressBookBuilder()</span><br><span class=\"line\">    ..name = <span class=\"string\">'jenny'</span></span><br><span class=\"line\">    ..email = <span class=\"string\">'jenny@example.com'</span></span><br><span class=\"line\">    ..phone = (</span><br><span class=\"line\">      PhoneNumberBuilder()</span><br><span class=\"line\">        ..number = <span class=\"string\">'xxx-xxx-xxxx'</span></span><br><span class=\"line\">        ..label = <span class=\"string\">'home'</span></span><br><span class=\"line\">      .build();</span><br><span class=\"line\">    )</span><br><span class=\"line\">  .build();</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-其它\"><a href=\"#7-9-其它\" class=\"headerlink\" title=\"7.9 其它\"></a>7.9 其它</h3><p>其他运算符：<br>| 运算符 |         名字         |                  意义                   |<br>| :—-: | :——————: | :————————————-: |<br>|  <code>()</code>  | Function application |              表示调用函数               |<br>|  <code>[]</code>  |       访问数组       |      引用数组指定索引位置上的元素       |<br>|  <code>.</code>   |     访问成员变量     |             表达式访问属性              |<br>|  <code>?.</code>  |   条件访问成员变量   | 类似 <code>.</code>，支持空对象(类似 Swift 可选链) |</p>\n<h2 id=\"8-控制语句\"><a href=\"#8-控制语句\" class=\"headerlink\" title=\"8. 控制语句\"></a>8. 控制语句</h2><p>Dart 控制流：</p>\n<ul>\n<li><code>if else</code></li>\n<li><code>switch case</code></li>\n<li><code>while</code> &amp; <code>do-while</code></li>\n<li><code>break</code> &amp; <code>continue</code></li>\n<li><code>for</code> 循环</li>\n<li><code>assert</code></li>\n</ul>\n<p>另外，还有 <code>try-catch</code> 和 <code>throw</code>。</p>\n<h3 id=\"8-1-If-else\"><a href=\"#8-1-If-else\" class=\"headerlink\" title=\"8.1 If else\"></a>8.1 If else</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isRaining()) &#123;</span><br><span class=\"line\">  you.bringRainCoat();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isSnowing()) &#123;</span><br><span class=\"line\">  you.wearJacket();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  car.putTopDown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同于 JS 的地方， Dart 条件必须是布尔值。</p>\n<h3 id=\"8-2-For-循环\"><a href=\"#8-2-For-循环\" class=\"headerlink\" title=\"8.2 For 循环\"></a>8.2 For 循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"built_in\">StringBuffer</span>(<span class=\"string\">'Dart is fun'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  msg.write(<span class=\"string\">'!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>闭包捕获变量，并在内部拷贝，即使 <code>i</code> 改变也不会影响之前的值： </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">  callbacks.append(() =&gt; <span class=\"built_in\">print</span>(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c()); <span class=\"comment\">// Dart 输出 0, 1； JS 输出 2, 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-While-amp-do-while\"><a href=\"#8-3-While-amp-do-while\" class=\"headerlink\" title=\"8.3 While &amp; do-while\"></a>8.3 While &amp; do-while</h3><p><code>while</code> 在进入循环体之前判断条件：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>do-while</code> 先执行循环体再判断条件：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(!atEndOfPage())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-4-Break-amp-continue\"><a href=\"#8-4-Break-amp-continue\" class=\"headerlink\" title=\"8.4 Break &amp; continue\"></a>8.4 Break &amp; continue</h3><ul>\n<li><code>break</code> 跳出循环</li>\n<li><code>continue</code> 跳过当前循环</li>\n</ul>\n<h3 id=\"8-5-Switch-case\"><a href=\"#8-5-Switch-case\" class=\"headerlink\" title=\"8.5 Switch case\"></a>8.5 Switch case</h3><p>Dart switch 支持整型，字符串和编译期常量。对象必须是相同类型且该类没有重载 <code>==</code>。</p>\n<p>每个非空的 <code>case</code> 从句，必须要有 <code>break</code>。其他结束 <code>case</code> 的语句：<code>continue</code>, <code>return</code> 和 <code>throw</code>。</p>\n<p>非空的 <code>case</code> 中省略 <code>break</code> 会报编译错误：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">  executeOpen();</span><br><span class=\"line\">  <span class=\"comment\">// Error: Missing break</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSE'</span>:</span><br><span class=\"line\">  executeClose();</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>case</code> 可以为空：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">  executeNowClosed();</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart 支持 <code>continue</code> 加标签的方式控制代码执行：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span> nowClosed;</span><br><span class=\"line\">  <span class=\"comment\">// Continues executing at the nowClosed label.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  nowClosed:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>case</code> 内部可以定义局部变量，变量作用域仅限此代码块。</p>\n<h3 id=\"8-6-断言\"><a href=\"#8-6-断言\" class=\"headerlink\" title=\"8.6 断言\"></a>8.6 断言</h3><p>开发者模式下，支持 <code>assert(condition, optionalMessage)</code> 终止程序。</p>\n<h2 id=\"9-异常处理\"><a href=\"#9-异常处理\" class=\"headerlink\" title=\"9. 异常处理\"></a>9. 异常处理</h2><p>Dart 支持异常捕获机制。异常是程序运行过程中不可知的错误。如果程序没有捕获异常，抛出异常的<a href=\"https://zhuanlan.zhihu.com/p/40069285\" target=\"_blank\" rel=\"noopener\"><strong>isolate</strong></a> 会被挂起，通常情况下，isolate 和程序都会被终止。</p>\n<p>不同于 Java， Dart 的异常都是未经检查的。方法不会声明可能的异常，并且不需要去处理。</p>\n<p>Dart 提供了 <em>Exception<em>，</em>Error</em> 以及其他的子类。开发者可以自定义异常。另外，Dart 程序可以把所有非空对象作为异常抛出。</p>\n<h3 id=\"9-1-Throw\"><a href=\"#9-1-Throw\" class=\"headerlink\" title=\"9.1 Throw\"></a>9.1 Throw</h3><p>抛出异常的例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>抛出任意非空对象作为异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Out of llamas'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为抛出异常是一个表达式，所以可以出现在任何需要表达式的位置：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> distanceTo(Point point) =&gt; <span class=\"keyword\">throw</span> UnimplementedError();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-Catch\"><a href=\"#9-2-Catch\" class=\"headerlink\" title=\"9.2 Catch\"></a>9.2 Catch</h3><p>捕获异常能停止异常的传递，给程序处理异常的能力：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlammas();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于能抛出多种异常类型的代码，可以使用多个 catch 从句。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A specific exception</span></span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Anything else that is an exception</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: $e'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// No specified type, handles all</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Something really unknown: $e'</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>catch()</code> 可以指定两个参数，第一个是抛出的异常，第二个是栈回溯(<a href=\"https://api.dart.dev/stable/dart-core/StackTrace-class.html\" target=\"_blank\" rel=\"noopener\">StackTrace</a>)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n $e'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e, s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n $e'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Stack trace:\\n $s'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在当前位置处理异常并继续传递，使用 <code>rethrow</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> misbehave() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(foo++); <span class=\"comment\">// Runtime error</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'misbehave() partially handled <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">rethrow</span>; <span class=\"comment\">// Allow callers to see the exception.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    misbehave();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'main() finished handling <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-Finally\"><a href=\"#9-3-Finally\" class=\"headerlink\" title=\"9.3 Finally\"></a>9.3 Finally</h3><p>无论是否抛出异常，使用finally子句，确保代码运行。如果 <code>catch</code> 没有匹配到异常，该异常会在 <code>finally</code> 后继续传播：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Always clean up, even if an exception is thrown.</span></span><br><span class=\"line\">  cleanLlamaStalls();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 匹配到异常后，也会执行 <code>finally</code> 从句：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Error: $e'</span>); <span class=\"comment\">// Handle the exception first.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  cleanLlamaStalls(); <span class=\"comment\">// Then clean up.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-类\"><a href=\"#10-类\" class=\"headerlink\" title=\"10. 类\"></a>10. 类</h2><p>Dart 是面向对象语言，具有类和基于 mixin 的继承。每个对象都是类的实例，每个类继承自 <em>Object*。基于 *mixin</em> 的继承意味着类只有一个超类，但是类的成员可被多个类结构重用。</p>\n<h3 id=\"10-1-使用类成员变量\"><a href=\"#10-1-使用类成员变量\" class=\"headerlink\" title=\"10.1 使用类成员变量\"></a>10.1 使用类成员变量</h3><p>对象的成员由函数和数据组成。当一个方法被调用时，也就是调用对象的某个方法：通过对象的函数和数据获取方法。</p>\n<p>使用 <code>.</code> 引用实例变量或方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the value of the instance variable y.</span></span><br><span class=\"line\">p.y = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the value of y.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(p.y == <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Invoke distanceTo() on p.</span></span><br><span class=\"line\"><span class=\"built_in\">num</span> distance = p.distanceTo(Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>?.</code> 避免调用链为 null 时产生异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If p is non-null, set its y value to 4.</span></span><br><span class=\"line\">p?.y = <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-2-使用构造函数\"><a href=\"#10-2-使用构造函数\" class=\"headerlink\" title=\"10.2 使用构造函数\"></a>10.2 使用构造函数</h3><p>使用构造器构造对象。构造器命名可以是 <code>ClassName</code> 或 <code>ClassName.identifier</code>。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>以下代码效果相同，构造器前面多一个可选的 <code>new</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>部分类提供了<a href=\"https://dart.dev/guides/language/language-tour#constant-constructors\" target=\"_blank\" rel=\"noopener\">常量构造器</a>。构造器前加 <code>const</code> 修饰，以创建编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造两个等价的编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(identical(a, b)); <span class=\"comment\">// They are the same instance!</span></span><br></pre></td></tr></table></figure>\n\n<p>如果能通过上下文推断出是常量，则可省略 <code>const</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lots of const keywords here.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以简写为：</span></span><br><span class=\"line\"><span class=\"comment\">// Only one const, which establishes the constant context.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: [ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: [ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个常量构造器超出常量上下文，并且没用 <code>const</code> 修饰，则创建一个非常量对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">// Creates a constant</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">// Does NOT create a constant</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(!identical(a, b)); <span class=\"comment\">// NOT the same instance!</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-获取对象类型\"><a href=\"#10-3-获取对象类型\" class=\"headerlink\" title=\"10.3 获取对象类型\"></a>10.3 获取对象类型</h3><p>使用 Object <code>runtimeType</code> 属性，在运行时获取对象类型，返回 <code>Type</code> 对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'The type of a is <span class=\"subst\">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上内容介绍了如何<em>使用</em>类，下面介绍如何实现类。</p>\n<h3 id=\"10-4-实例变量\"><a href=\"#10-4-实例变量\" class=\"headerlink\" title=\"10.4 实例变量\"></a>10.4 实例变量</h3><p>如何声明一个实例变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x; <span class=\"comment\">// Declare instance variable x, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> y; <span class=\"comment\">// Declare y, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> z = <span class=\"number\">0</span>; <span class=\"comment\">// Declare z, initially 0.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>未初始化的实例变量默认为 <code>null</code>。</p>\n<p>所以实例变量隐式生成 <em>getter</em> 方法。所有实例变量（除了 final）隐式生成 <em>setter</em> 方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = Point();</span><br><span class=\"line\">  point.x = <span class=\"number\">4</span>; <span class=\"comment\">// Use the setter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.x == <span class=\"number\">4</span>); <span class=\"comment\">// Use the getter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.y == <span class=\"keyword\">null</span>); <span class=\"comment\">// Values default to null.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于实例变量的生命周期，实例变量在构造器和初始化器执行之前就已创建，如果声明实例变量的时候手动初始化了，那么初始化也在此时完成。</p>\n<h3 id=\"10-5-构造函数\"><a href=\"#10-5-构造函数\" class=\"headerlink\" title=\"10.5 构造函数\"></a>10.5 构造函数</h3><p>构造器写法：声明一个函数，函数名和类名相同。最常见的构造器形式就是生成构造器，会创建类的一个新实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"built_in\">num</span> x, <span class=\"built_in\">num</span> y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's a better way to do this, stay tuned.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>this</code> 关键字引用当前实例。</p>\n<p>构造器的一个语法糖写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Syntactic sugar for setting x and y</span></span><br><span class=\"line\">  <span class=\"comment\">// before the constructor body runs.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器 \"></a>默认构造器 <!-- omit in toc --></h4><p>如果没有生命构造器，Dart 会默认生成一个构造器。此构造器没有参数，并调用父类的不带参构造器。</p>\n<h4 id=\"构造器不继承\"><a href=\"#构造器不继承\" class=\"headerlink\" title=\"构造器不继承 \"></a>构造器不继承 <!-- omit in toc --></h4><p>构造器不支持继承。</p>\n<h4 id=\"带名字的构造器\"><a href=\"#带名字的构造器\" class=\"headerlink\" title=\"带名字的构造器 \"></a>带名字的构造器 <!-- omit in toc --></h4><p>如果需要创建多个构造器，使用带名字的构造器：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Named constructor</span></span><br><span class=\"line\">  Point.origin() &#123;</span><br><span class=\"line\">    x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用非默认的父类构造器\"><a href=\"#调用非默认的父类构造器\" class=\"headerlink\" title=\"调用非默认的父类构造器 \"></a>调用非默认的父类构造器 <!-- omit in toc --></h4><p>默认情况下，子类的构造器调用父类不带名字和参数的构造器，且在子类构造器的头部调用。如果使用了<a href=\"https://dart.dev/guides/language/language-tour#initializer-list\" target=\"_blank\" rel=\"noopener\">初始化列表</a>，此操作会在父类调用前执行。三者顺序：</p>\n<ol>\n<li>初始化列表</li>\n<li>父类无参构造器</li>\n<li>当前类无参构造器</li>\n</ol>\n<p>如果父类没有无名无参的构造器，必须手动调用父类的一个构造器。在 <code>:</code> 和函数体之间指定父类的构造器。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.fromJson(<span class=\"built_in\">Map</span> data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Person'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Person does not have a default constructor;</span></span><br><span class=\"line\">  <span class=\"comment\">// you must call super.fromJson(data).</span></span><br><span class=\"line\">  Employee.fromJson(<span class=\"built_in\">Map</span> data) : <span class=\"keyword\">super</span>.fromJson(data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Employee'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emp = <span class=\"keyword\">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Prints:</span></span><br><span class=\"line\">  <span class=\"comment\">// in Person</span></span><br><span class=\"line\">  <span class=\"comment\">// in Employee</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (emp <span class=\"keyword\">is</span> Person) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Type check</span></span><br><span class=\"line\">    emp.firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  (emp <span class=\"keyword\">as</span> Person).firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表 \"></a>初始化列表 <!-- omit in toc --></h4><p>除了调用父类构造器外，还可以在构造器函数体之前初始化实例变量。多个初始化之间用逗号分隔：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">num</span>&gt; json) : x = json[<span class=\"string\">'x'</span>], y = json[<span class=\"string\">'y'</span>] &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.fromJson(): ($x, $y)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开发模式下，初始化列表中可使用断言：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.withAssert(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y) : <span class=\"keyword\">assert</span>(x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.withAssert(): ($x, $y)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置 final 字段时，初始化列表较为便利。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> distanceFromOrigin;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(x, y)</span><br><span class=\"line\">      : x = x,</span><br><span class=\"line\">        y = y,</span><br><span class=\"line\">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(p.distanceFromOrigin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重定向构造器\"><a href=\"#重定向构造器\" class=\"headerlink\" title=\"重定向构造器 \"></a>重定向构造器 <!-- omit in toc --></h4><p>部分构造器的作用只是调用当前类的其它构造器。重定向构造器写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Point.alongzXAxis(<span class=\"built_in\">num</span> x) : <span class=\"keyword\">this</span>(x, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常量构造器\"><a href=\"#常量构造器\" class=\"headerlink\" title=\"常量构造器 \"></a>常量构造器 <!-- omit in toc --></h4><p>常量构造器用来表示类生成的实例不会改变。用 <code>const</code> 修饰构造器且全部实例变量使用 <code>final</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常量构造器不一定总是创建常量。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#using-constructors\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h4 id=\"工厂构造器\"><a href=\"#工厂构造器\" class=\"headerlink\" title=\"工厂构造器 \"></a>工厂构造器 <!-- omit in toc --></h4><p>关键字 <code>factory</code> 修饰的构造器表示，此构造器不会每次都创建新的实例。比如，工厂构造器可能返回一个缓存中的实例或者子类的实例。</p>\n<p>工厂构造器写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用工厂构造器同其他构造器方法一样：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> logger = Logger(<span class=\"string\">'UI'</span>);</span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-6-方法\"><a href=\"#10-6-方法\" class=\"headerlink\" title=\"10.6 方法\"></a>10.6 方法</h3><p>方法是定义在类内部的函数。</p>\n<h4 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法 \"></a>实例方法 <!-- omit in toc --></h4><p>对象的实例方法内部可访问实例变量和 <code>this</code>。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">num</span> distanceTo(Point other) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = x - other.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = y - other.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Getters-amp-setters\"><a href=\"#Getters-amp-setters\" class=\"headerlink\" title=\"Getters &amp; setters \"></a>Getters &amp; setters <!-- omit in toc --></h4><p>Getters 和 setters 是特殊的方法，能读写对象属性。实例变量默认都有 getter，通常也有 setter。也可用 <code>get</code> 和 <code>set</code> 自己实现：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> left, top, width, height;</span><br><span class=\"line\"></span><br><span class=\"line\">  Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Define two calculated properties: right and bottom.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right =&gt; left + width;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) =&gt; left = value - width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom =&gt; top + height;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rect = Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">  rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法 \"></a>抽象方法 <!-- omit in toc --></h4><p>实例方法，getter 和 setter 都能定义为抽象方法，当前类只定义接口，实现交由其它类。抽象方法只能定义在<a href=\"https://dart.dev/guides/language/language-tour#abstract-classes\" target=\"_blank\" rel=\"noopener\">抽象类</a>中。</p>\n<p>定义抽象方法，用分号替代函数体：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> soSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EffectiveDoer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> soSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-7-抽象类\"><a href=\"#10-7-抽象类\" class=\"headerlink\" title=\"10.7 抽象类\"></a>10.7 抽象类</h3><p>关键字 <code>abstract</code> 定义<em>抽象类</em>（不能被实例化）。抽象类多用于接口定义，实现较多的情况。定义<a href=\"https://dart.dev/guides/language/language-tour#factory-constructors\" target=\"_blank\" rel=\"noopener\">工厂构造器</a>可实例化抽象类。</p>\n<p>抽象类通常都有抽象方法，例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This class is declared abstract and thus</span></span><br><span class=\"line\"><span class=\"comment\">// can't be instantiated.</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define constructors, fields, methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> updateChildren(); <span class=\"comment\">// Abstract method.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-8-隐式接口\"><a href=\"#10-8-隐式接口\" class=\"headerlink\" title=\"10.8 隐式接口\"></a>10.8 隐式接口</h3><p>类隐式定义了一个接口列表，包括当前类实现的所有成员变量。类 A 在不继承类 B 的情况下，实现类 B 的接口，从而调用类 B 的成员。</p>\n<p>声明类的时候用 <code>implements</code> 并提供所需的 APIs，从而实现一个或多个接口：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, $who. I am $_name'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi $who. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>))); <span class=\"comment\">// 'Hello, Bob. I am $Kathy'</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(geetBob(Impostor())); <span class=\"comment\">// 'Hi Bob. Do you know who I am?'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个类实现多个接口：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>, <span class=\"title\">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-9-扩展类\"><a href=\"#10-9-扩展类\" class=\"headerlink\" title=\"10.9 扩展类\"></a>10.9 扩展类</h3><p>使用 <code>extends</code> 创建子类，<code>super</code> 指向父类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    _illuminateDisplay();</span><br><span class=\"line\">    _activateIrSensor();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.turnOn();</span><br><span class=\"line\">    _bootNetworkInterface();</span><br><span class=\"line\">    _initializeMemory();</span><br><span class=\"line\">    _upgradeApps();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重写成员\"><a href=\"#重写成员\" class=\"headerlink\" title=\"重写成员 \"></a>重写成员 <!-- omit in toc --></h4><p>子类可重载实例方法、getters 和 setters。<code>@override</code> 关键字表示成员被重载：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可重载运算符\"><a href=\"#可重载运算符\" class=\"headerlink\" title=\"可重载运算符 \"></a>可重载运算符 <!-- omit in toc --></h4><p>下表中运算符支持重载：<br>|       |       |       |       |<br>| :—: | :—: | :—: | :—: |<br>|  <code>&lt;</code>  |  <code>+</code>  |  <code>|</code>  | <code>[]</code>  |<br>|  <code>&gt;</code>  |  <code>/</code>  |  <code>^</code>  | <code>[]=</code> |<br>| <code>&lt;=</code>  | <code>~/</code>  |  <code>&amp;</code>  |  <code>~</code>  |<br>| <code>&gt;=</code>  |  <code>*</code>  | <code>&lt;&lt;</code>  | <code>==</code>  |<br>|  <code>-</code>  |  <code>%</code>  | <code>&gt;&gt;</code>  |       |</p>\n<p>重载 <code>+</code>, <code>-</code> 运算符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> v = Vector(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> w = Vector(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v + w == Vector(<span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v - w == Vector(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"noSuchMethod\"><a href=\"#noSuchMethod\" class=\"headerlink\" title=\"noSuchMethod() \"></a>noSuchMethod() <!-- omit in toc --></h4><p>重载 <code>noSuchMethod()</code> 方法，及时处理调用对象不存在的实例变量和方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Unless you override noSuchMethod, using a</span></span><br><span class=\"line\">  <span class=\"comment\">// non-existent member results in a NoSuchMethodError.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'You tried to use a non-existent member: '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不可调用对象未实现的方法，除非实现以下任意情况：</p>\n<ul>\n<li>消息接受者有静态类型 <code>dynamic</code></li>\n<li>接收器有一个定义未实现方法的静态类型（包括抽象类型），接收器的动态类型有一个noSuchMethod（）实现，它与Object类中的实现不同。</li>\n</ul>\n<h3 id=\"10-10-枚举类型\"><a href=\"#10-10-枚举类型\" class=\"headerlink\" title=\"10.10 枚举类型\"></a>10.10 枚举类型</h3><p>枚举表示固定数量的常量值。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法 \"></a>用法 <!-- omit in toc --></h4><p>使用 <code>enum</code> 关键字声明枚举类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举值有个 <code>index</code> getter，返回该值在枚举声明中的位置，从 0 开始。第一个值为 0，第二个值为 1…</p>\n<p>使用 <code>values</code> 在运行时获取所有枚举值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(colors[<span class=\"number\">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 switch case 中使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aColor = Color.red;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (aColor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.red:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.green:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'green'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(aColor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举类型的局限性：</p>\n<ul>\n<li>不可子类化，<em>mix in</em>，或实现</li>\n<li>不能显示实例一个枚举类型</li>\n</ul>\n<h3 id=\"10-11-类添加特性\"><a href=\"#10-11-类添加特性\" class=\"headerlink\" title=\"10.11 类添加特性\"></a>10.11 类添加特性</h3><p>Mixins 是一种将类代码共享给其他类的功能。</p>\n<p><code>with</code> 关键字<em>使用</em> mixin 功能。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musician</span> <span class=\"keyword\">extends</span> <span class=\"title\">Performer</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maestro</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span>, <span class=\"title\">Aggressive</span>, <span class=\"title\">Demented</span> </span>&#123;</span><br><span class=\"line\">  Maestro(<span class=\"built_in\">String</span> maestroname) &#123;</span><br><span class=\"line\">    name = maestroName;</span><br><span class=\"line\">    canConduct = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>实现</em> mixin：创建一个 Object 子类，并且不声明构造器。另外，如果不想该类被当作普通的类，用 <code>mixin</code> 关键字代替 <code>class</code>。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin Musical &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canPlayPiano = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canCompose = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canConduct = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> entertainMe() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canPlayPiano) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Playing piano'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (canConduct) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Waving hands'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Humming to self'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要指定只有某些类型可以使用mixin，使用 <code>on</code> 指定所需的超类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin MusicalPerformer on Musician &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-12-类变量和方法\"><a href=\"#10-12-类变量和方法\" class=\"headerlink\" title=\"10.12 类变量和方法\"></a>10.12 类变量和方法</h3><p>使用 <code>static</code> 关键字创建静态变量和方法。静态方法和变量都是面向类型的，实例无法访问。</p>\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法 \"></a>静态方法 <!-- omit in toc --></h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> initialCapacity = <span class=\"number\">16</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Queue.initialCapacity == <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态变量只有在使用时才会被初始化。</p>\n<h4 id=\"静态方法-1\"><a href=\"#静态方法-1\" class=\"headerlink\" title=\"静态方法 \"></a>静态方法 <!-- omit in toc --></h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = a.x - b.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = a.y - b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> distance = Point.distanceBetween(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"number\">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class=\"number\">2.9</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(distance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-泛型\"><a href=\"#11-泛型\" class=\"headerlink\" title=\"11. 泛型\"></a>11. 泛型</h2><p>数组类型声明：<code>List&lt;E&gt;</code>，其中 &lt;…&gt; 将类型标记为<em>泛型</em>，即，类型内部有个形式上的参数。通常的命名规范，泛型参数名字为单字符，如 E, T, S, K 和 V。</p>\n<h3 id=\"11-1-为什么使用泛型\"><a href=\"#11-1-为什么使用泛型\" class=\"headerlink\" title=\"11.1 为什么使用泛型\"></a>11.1 为什么使用泛型</h3><p>泛型要求代码是类型安全的，但是使用泛型有很多好处：</p>\n<ul>\n<li>正确使用泛型使代码结构更好</li>\n<li>减少重复代码</li>\n</ul>\n<p>声明一个只含字符串的数组：<code>List&lt;String&gt;</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\">names.add(<span class=\"number\">42</span>);<span class=\"comment\">//编译报错</span></span><br></pre></td></tr></table></figure>\n\n<p>受益于静态分析的前提下，泛型能为多个类型共享一个接口。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存 Object</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">Object</span> value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缓存 String</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">String</span> value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用泛型</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  T getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, T value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-使用集合字面值\"><a href=\"#11-2-使用集合字面值\" class=\"headerlink\" title=\"11.2 使用集合字面值\"></a>11.2 使用集合字面值</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = &lt;<span class=\"built_in\">String</span>&gt;[<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> uniqueNames = &lt;<span class=\"built_in\">String</span>&gt;&#123;<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pages = &lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"string\">'index.html'</span>: <span class=\"string\">'Homepage'</span>,</span><br><span class=\"line\">  <span class=\"string\">'robots.txt'</span>: <span class=\"string\">'Hints for web robots'</span>,</span><br><span class=\"line\">  <span class=\"string\">'humans.txt'</span>: <span class=\"string\">'We are people, not machines'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-3-使用带参数化类型的构造函数\"><a href=\"#11-3-使用带参数化类型的构造函数\" class=\"headerlink\" title=\"11.3 使用带参数化类型的构造函数\"></a>11.3 使用带参数化类型的构造函数</h3><p>使用构造器时，指定一个或多个类型，类型放在 <code>&lt;&gt;</code> 中间。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nameSet = <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-4-泛型集合\"><a href=\"#11-4-泛型集合\" class=\"headerlink\" title=\"11.4 泛型集合\"></a>11.4 泛型集合</h3><p>Dart 泛型类型是<em>具体化的</em>，这意味着泛型变量在运行时携带类型信息。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(names <span class=\"keyword\">is</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-5-泛型约束\"><a href=\"#11-5-泛型约束\" class=\"headerlink\" title=\"11.5 泛型约束\"></a>11.5 泛型约束</h3><p>当定义泛型，可使用 <code>extends</code> 约束泛型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> toString() =&gt; <span class=\"string\">\"Instance of 'Foo&lt;$T&gt;'\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extender</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class=\"line\"><span class=\"keyword\">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>不指定泛型参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo();</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo); <span class=\"comment\">// Instance of 'Foo&lt;SomeBaseClass&gt;'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-6-使用泛型方法\"><a href=\"#11-6-使用泛型方法\" class=\"headerlink\" title=\"11.6 使用泛型方法\"></a>11.6 使用泛型方法</h3><p>Dart 支持泛型方法或函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first&lt;T&gt;(<span class=\"built_in\">List</span>&lt;T&gt; ts) &#123;</span><br><span class=\"line\">  T tmp = ts[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码展示了函数泛型参数可使用的位置：</p>\n<ul>\n<li>函数返回值</li>\n<li>函数参数</li>\n<li>内部布局变量</li>\n</ul>\n<h2 id=\"12-库\"><a href=\"#12-库\" class=\"headerlink\" title=\"12. 库\"></a>12. 库</h2><p>使用 <code>import</code> 和 <code>library</code> 指令创建模块化和可共享的代码。库不仅提供 APIs，还是私有的作用域块：下划线开头的标识符仅在库内部可见。每个 Dart 应用都是一个库，即使并不使用 <code>library</code> 指令。</p>\n<p>库可作为包(package)发布。</p>\n<h3 id=\"12-1-使用库\"><a href=\"#12-1-使用库\" class=\"headerlink\" title=\"12.1 使用库\"></a>12.1 使用库</h3><p>使用 <code>import</code>，在一个库中指定另一个库的命名空间。</p>\n<p>举个例子，Dart 网页应用通常使用 <code>dart:html</code> 库，可以如下导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:html'</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>import</code> 指令后面的参数是指向目标库的 URI。对于 Dart 自带的库，使用 <code>dart:</code> 作为 sheme。其他库，使用文件路径或 <code>package:</code> scheme。包管理工具提供的库使用 <code>package:</code> scheme。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指定库前缀\"><a href=\"#指定库前缀\" class=\"headerlink\" title=\"指定库前缀 \"></a>指定库前缀 <!-- omit in toc --></h4><p>当引入的两个库有冲突的标识符，可以为两个库指定前缀，从而避免冲突。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> <span class=\"keyword\">as</span> lib2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Element</span> element1 = <span class=\"built_in\">Element</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">lib2.<span class=\"built_in\">Element</span> element2 = lib2.<span class=\"built_in\">Element</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导入库的部分接口\"><a href=\"#导入库的部分接口\" class=\"headerlink\" title=\"导入库的部分接口 \"></a>导入库的部分接口 <!-- omit in toc --></h4><p>Dart 支持导入库的部分功能，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"库懒加载\"><a href=\"#库懒加载\" class=\"headerlink\" title=\"库懒加载 \"></a>库懒加载 <!-- omit in toc --></h4><p>库的按需加载。以下场景可以使用库按需加载：</p>\n<ul>\n<li>加快应用启动时间</li>\n<li>A/B test</li>\n<li>加载较少使用的库</li>\n</ul>\n<p>实现懒加载，首先要用 <code>deferred as</code> 导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:greetings/hello.dart'</span> deferred <span class=\"keyword\">as</span> hello;</span><br></pre></td></tr></table></figure>\n\n<p>需要使用的地方，用库的标识调用 <code>loadLibrary()</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future greet() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，<code>await</code> 关键字会阻塞代码直到库加载完成。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#asynchrony-support\" target=\"_blank\" rel=\"noopener\">异步操作</a>。</p>\n<p>多次调用 <code>loadLibrary()</code> 加载同一个库不会出错，且库只会被加载一次。</p>\n<p>使用库的懒加载时，记住以下几点：</p>\n<ul>\n<li>懒加载的库中的常量，只有在懒加载完成后才能作为常量使用</li>\n<li>不能使用懒加载库中的类型。而应该将接口类型放到第三方库中，让目标库和当前文件共同导入第三方库</li>\n<li>开发者用 <code>deferred as namespace</code> 定义懒加载库的命名空间，Dart 在命名空间后面隐式插入 <code>loadLibrary()</code>。<code>loadLibrary()</code> 返回 <em>Future</em>。</li>\n</ul>\n<h3 id=\"12-2-实现库\"><a href=\"#12-2-实现库\" class=\"headerlink\" title=\"12.2 实现库\"></a>12.2 实现库</h3><p>实现一个库，请查看 <a href=\"https://dart.dev/guides/libraries/create-library-packages\" target=\"_blank\" rel=\"noopener\">Create Library Package</a>：</p>\n<ul>\n<li>如何组织库的源码</li>\n<li>如何使用 <code>export</code> 指令</li>\n<li>何时使用 <code>part</code> 指令</li>\n<li>何时使用 <code>library</code> 指令</li>\n</ul>\n<h2 id=\"13-异步\"><a href=\"#13-异步\" class=\"headerlink\" title=\"13. 异步\"></a>13. 异步</h2><p>Dart 库中有很多返回值为 <code>Future</code> 和 <code>Stream</code> 的函数。这些函数是异步函数：派发一个耗时任务后直接返回，并不等待任务完成。</p>\n<p><code>async</code> 和 <code>await</code> 关键字实现异步编程，让异步任务像同步的代码顺序执行。</p>\n<h3 id=\"13-1-处理-Future\"><a href=\"#13-1-处理-Future\" class=\"headerlink\" title=\"13.1 处理 Future\"></a>13.1 处理 Future</h3><p>两种方式处理 Future：</p>\n<ul>\n<li>使用 <code>async</code> 和 <code>await</code></li>\n<li>使用 Future API，查看 <a href=\"https://dart.dev/guides/libraries/library-tour#future\" target=\"_blank\" rel=\"noopener\">the library tour</a></li>\n</ul>\n<p><code>async</code> 和 <code>await</code> 使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>await</code> 的代码，必须要写在 <em>async</em> 函数内：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future checkVersion() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>try</code>, <code>catch</code> 和 <code>finally</code> 用于处理 <code>await</code> 代码中的错误并执行清理代码：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个异步函数中，可使用多个 <code>await</code>，下述代码中，使用了三个 await 处理任务：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entrypoint = <span class=\"keyword\">await</span> findEntrypoint();</span><br><span class=\"line\"><span class=\"keyword\">var</span> exitCode = <span class=\"keyword\">await</span> runExecutable(entrypoint, args);</span><br><span class=\"line\"><span class=\"keyword\">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>await expr</code> 中，<code>expr</code> 的值通常是 Future，如果不是，系统会自动用 Future 包装。该 Future 对象表示一个会返回对象的 promise。<code>await expr</code> 的值就是最终返回的对象。Await 表达式会阻塞代码直到返回最终的对象。</p>\n<p><strong>使用 <code>await</code> 的时候报了编译错误，确保 <code>await</code> 实在异步函数中。</strong> 比如，想在 <code>main()</code> 函数中使用 <code>await</code>，那么函数体必须标记为 <code>async</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  checkVersion();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In main: version is <span class=\"subst\">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-声明异步函数\"><a href=\"#13-2-声明异步函数\" class=\"headerlink\" title=\"13.2 声明异步函数\"></a>13.2 声明异步函数</h3><p>异步函数的函数体用 <code>async</code> 标记。</p>\n<p>为函数添加 <code>async</code> 关键字，使得函数返回 Future。如下例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> lookUpVersion() =&gt; <span class=\"string\">'1.0.0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; lookUpVersion() <span class=\"keyword\">async</span> =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码可知，Dart 自动用 Future 包装返回值。</p>\n<p>如果函数没有实际返回值，就返回 <code>Future&lt;void&gt;</code>。</p>\n<h3 id=\"13-3-处理流\"><a href=\"#13-3-处理流\" class=\"headerlink\" title=\"13.3 处理流\"></a>13.3 处理流</h3><p>两种方式从流(Stream)中获取值：</p>\n<ul>\n<li>用 <code>async</code> 和 <em>asynchronous for loop</em>(<code>await for</code>)</li>\n<li>使用 <a href=\"https://dart.dev/guides/libraries/library-tour#stream\" target=\"_blank\" rel=\"noopener\">Stream API</a></li>\n</ul>\n<p>异步循环格式：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (varOrType identifier <span class=\"keyword\">in</span> expression) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，<code>expression</code> 必须是 Stream 类型。代码执行顺序：</p>\n<ol>\n<li>等待流释放一个值</li>\n<li>变量被赋值为 (1) 释放的值，并执行循环体</li>\n<li>重复步骤(1), (2)，直到流被关闭</li>\n</ol>\n<p>使用 <code>break</code> 或 <code>return</code> 停止监听流，执行命令后会跳出循环并对流取消订阅</p>\n<p><strong>当实现一个异步循环的时候，报编译错误，确保 <code>await for</code> 代码实在异步函数中。</strong> 比如，在 <code>main()</code> 函数中使用异步循环，将 <code>main()</code> 函数体标记为 <code>async</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> request <span class=\"keyword\">in</span> requestServer) &#123;</span><br><span class=\"line\">    handleRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更多异步编程信息，查看 <a href=\"https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming\" target=\"_blank\" rel=\"noopener\"><em>dart:async</em></a>。</p>\n<h2 id=\"14-生成器\"><a href=\"#14-生成器\" class=\"headerlink\" title=\"14. 生成器\"></a>14. 生成器</h2><p>用 <em>生成器函数</em> 惰性生成一些列值。Dart 自带两种生成器：</p>\n<ul>\n<li><strong>Synchronous</strong> 生成器：返回一个 <a href=\"https://api.dart.dev/stable/dart-core/Iterable-class.html\" target=\"_blank\" rel=\"noopener\"><em>Iterable</em></a> 对象</li>\n<li><strong>Asynchronous</strong> 生成器：返回一个 <a href=\"https://api.dart.dev/stable/dart-async/Stream-class.html\" target=\"_blank\" rel=\"noopener\"><em>Stream</em></a> 对象</li>\n</ul>\n<p>实现 <strong>synchronous</strong> 生成器函数方法：用 <code>sync*</code> 标记函数体，并用 <code>yield</code> 语句发送值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;Int&gt; naturalTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现 <strong>asynchronous</strong> 生成器函数方法：用 <code>async*</code> 标记函数体，并用 <code>yield</code> 发送值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Int&gt; asynchronousNaturalTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归生成器，用 <code>yield*</code> 改进性能：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;Int&gt; naturalsDownFrom(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* naturalsDownFrom(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-可调用的类\"><a href=\"#15-可调用的类\" class=\"headerlink\" title=\"15. 可调用的类\"></a>15. 可调用的类</h2><p>类实现 <code>call()</code> 方法后，该类的实例可以像函数一样被调用。</p>\n<p>如下例子，<code>WannabeFunction</code> 类实现了 call() 函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'$a $b $c!'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">'Hi'</span>, <span class=\"string\">'there'</span>, <span class=\"string\">'gang'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(out);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-独立性\"><a href=\"#16-独立性\" class=\"headerlink\" title=\"16. 独立性\"></a>16. 独立性</h2><p>多数计算机包括手机都有多核 CPU。开发者通常用共享内存的线程并发执行程序，以提高 CPU 利用率。然而，共享状态的并发执行更易出错，也使得代码更加复杂。</p>\n<p>Dart 用 <em>isolate</em> 替代线程。每个 isolate 有自己的堆内存，以确保 isolates 之间不会共享状态。</p>\n<p>更多信息查看 <a href=\"https://api.dart.dev/stable/dart-isolate\" target=\"_blank\" rel=\"noopener\">dart:isolate library document</a>。</p>\n<h2 id=\"17-类型定义\"><a href=\"#17-类型定义\" class=\"headerlink\" title=\"17. 类型定义\"></a>17. 类型定义</h2><p>Dart 中，函数同字符串和数值一样都是对象。<em>Typedef</em> 或者说 <em>funtion-type alias</em> 给函数定义个名字，在其它地方使用。类型定义会保留类型信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"built_in\">Function</span> f) &#123;</span><br><span class=\"line\">    compare = f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用类型定义后：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  Compare compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"keyword\">this</span>.compare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">main &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> Compare); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型定义结合泛型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare&lt;T&gt; = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(T a, Tb);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">main &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(sort <span class=\"keyword\">is</span> Compare&lt;Int&gt;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"18-元数据\"><a href=\"#18-元数据\" class=\"headerlink\" title=\"18. 元数据\"></a>18. 元数据</h2><p>元数据标注写法：<code>@</code> 开头，后跟着编译期常量或者常量构造器。</p>\n<p>Dart 中两种标注对所有代码使用: <code>@deprecated</code> 和 <code>override</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> activate &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义元数据标注：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> who;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> what;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Todo(<span class=\"keyword\">this</span>.who, <span class=\"keyword\">this</span>.what);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用自定义的元数据：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'todo.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Todo</span>(<span class=\"string\">'seth'</span>, <span class=\"string\">'make this do something'</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元数据可以出现在以下指令前：库，类，类型定义，类型参数，构造器，工厂方法，字段，参数，变量声明，导入导出。运行时可通过 reflection 获取元数据。</p>\n<h2 id=\"19-注释\"><a href=\"#19-注释\" class=\"headerlink\" title=\"19. 注释\"></a>19. 注释</h2><p>Dart 支持单行、多行和文档注释。</p>\n<h2 id=\"20-小结\"><a href=\"#20-小结\" class=\"headerlink\" title=\"20. 小结\"></a>20. 小结</h2><p>此文档摘录了 Dart 中较为通用的特性。此外，更多新特性正在开发，尽量兼容当前代码。下一步：<a href=\"https://dart.dev/guides/language/spec\" target=\"_blank\" rel=\"noopener\">language specification</a> 和 <a href=\"https://dart.dev/guides/language/effective-dart\" target=\"_blank\" rel=\"noopener\">Effective Dart</a>。</p>\n<p>了解更多关于 Dart 核心库，查看 <a href=\"https://dart.dev/guides/libraries/library-tour\" target=\"_blank\" rel=\"noopener\">A Tour of the Dart Libraries</a>。</p>\n","site":{"data":{}},"excerpt":"<p>本文列出了 Dart 语言的每个主要功能的用法，从变量和运算符到类库。本文适用于有其他编程语言经验的开发者。<br>想学习更多 Dart 核心库的，请查看此<a href=\"https://dart.dev/guides/libraries/library-tour\" target=\"_blank\" rel=\"noopener\">文档</a>。想学习更多语言细节的，请查看此<a href=\"https://dart.dev/guides/language/spec\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>","more":"<p>目录</p>\n<ul>\n<li><a href=\"#1-%e4%b8%80%e6%ae%b5%e5%9f%ba%e7%a1%80%e7%9a%84-dart-%e7%a8%8b%e5%ba%8f\">1. 一段基础的 Dart 程序</a></li>\n<li><a href=\"#2-%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5\">2. 重要概念</a></li>\n<li><a href=\"#3-%e5%85%b3%e9%94%ae%e5%ad%97\">3. 关键字</a></li>\n<li><a href=\"#4-%e5%8f%98%e9%87%8f\">4. 变量</a><ul>\n<li><a href=\"#41-%e9%bb%98%e8%ae%a4%e5%80%bc\">4.1 默认值</a></li>\n<li><a href=\"#42-final-%e5%92%8c-const-%e5%85%b3%e9%94%ae%e5%ad%97\">4.2 Final 和 const 关键字</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%e8%87%aa%e5%b8%a6%e7%b1%bb%e5%9e%8b\">5. 自带类型</a><ul>\n<li><a href=\"#51-%e6%95%b0%e5%80%bc\">5.1 数值</a></li>\n<li><a href=\"#52-%e5%ad%97%e7%ac%a6%e4%b8%b2\">5.2 字符串</a></li>\n<li><a href=\"#53-%e5%b8%83%e5%b0%94\">5.3 布尔</a></li>\n<li><a href=\"#54-%e6%95%b0%e7%bb%84\">5.4 数组</a></li>\n<li><a href=\"#55-%e9%9b%86\">5.5 集</a></li>\n<li><a href=\"#56-%e8%a1%a8\">5.6 表</a></li>\n<li><a href=\"#57-runes\">5.7 Runes</a></li>\n<li><a href=\"#58-%e7%ac%a6%e5%8f%b7\">5.8 符号</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%e5%87%bd%e6%95%b0\">6. 函数</a><ul>\n<li><a href=\"#61-%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0\">6.1 可选参数</a></li>\n<li><a href=\"#62-main-%e5%87%bd%e6%95%b0\">6.2 main() 函数</a></li>\n<li><a href=\"#63-%e4%b8%80%e7%ad%89%e5%85%ac%e6%b0%91%e5%87%bd%e6%95%b0\">6.3 一等公民函数</a></li>\n<li><a href=\"#64-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0\">6.4 匿名函数</a></li>\n<li><a href=\"#65-%e4%bd%9c%e7%94%a8%e5%9f%9f\">6.5 作用域</a></li>\n<li><a href=\"#66-%e8%af%8d%e6%b3%95%e9%97%ad%e5%8c%85\">6.6 词法闭包</a></li>\n<li><a href=\"#67-%e5%87%bd%e6%95%b0%e7%9a%84%e7%ad%89%e4%bb%b7%e6%80%a7\">6.7 函数的等价性</a></li>\n<li><a href=\"#68-%e8%bf%94%e5%9b%9e%e5%80%bc\">6.8 返回值</a></li>\n</ul>\n</li>\n<li><a href=\"#7-%e8%bf%90%e7%ae%97%e7%ac%a6\">7. 运算符</a><ul>\n<li><a href=\"#71-%e7%ae%97%e6%95%b0%e8%bf%90%e7%ae%97%e7%ac%a6\">7.1 算数运算符</a></li>\n<li><a href=\"#72-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e6%b3%95\">7.2 关系运算法</a></li>\n<li><a href=\"#73-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad%e8%bf%90%e7%ae%97%e7%ac%a6\">7.3 类型推断运算符</a></li>\n<li><a href=\"#74-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6\">7.4 赋值运算符</a></li>\n<li><a href=\"#75-%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6\">7.5 逻辑运算符</a></li>\n<li><a href=\"#76-%e4%bd%8d%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6\">7.6 位移运算符</a></li>\n<li><a href=\"#77-%e6%9d%a1%e4%bb%b6%e8%a1%a8%e8%be%be%e5%bc%8f\">7.7 条件表达式</a></li>\n<li><a href=\"#78-%e5%a4%9a%e7%ba%a7%e8%a1%a8%e7%a4%ba%e6%b3%95\">7.8 多级表示法</a></li>\n<li><a href=\"#79-%e5%85%b6%e5%ae%83\">7.9 其它</a></li>\n</ul>\n</li>\n<li><a href=\"#8-%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5\">8. 控制语句</a><ul>\n<li><a href=\"#81-if-else\">8.1 If else</a></li>\n<li><a href=\"#82-for-%e5%be%aa%e7%8e%af\">8.2 For 循环</a></li>\n<li><a href=\"#83-while--do-while\">8.3 While &amp; do-while</a></li>\n<li><a href=\"#84-break--continue\">8.4 Break &amp; continue</a></li>\n<li><a href=\"#85-switch-case\">8.5 Switch case</a></li>\n<li><a href=\"#86-%e6%96%ad%e8%a8%80\">8.6 断言</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86\">9. 异常处理</a><ul>\n<li><a href=\"#91-throw\">9.1 Throw</a></li>\n<li><a href=\"#92-catch\">9.2 Catch</a></li>\n<li><a href=\"#93-finally\">9.3 Finally</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%e7%b1%bb\">10. 类</a><ul>\n<li><a href=\"#101-%e4%bd%bf%e7%94%a8%e7%b1%bb%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f\">10.1 使用类成员变量</a></li>\n<li><a href=\"#102-%e4%bd%bf%e7%94%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">10.2 使用构造函数</a></li>\n<li><a href=\"#103-%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b\">10.3 获取对象类型</a></li>\n<li><a href=\"#104-%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f\">10.4 实例变量</a></li>\n<li><a href=\"#105-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">10.5 构造函数</a></li>\n<li><a href=\"#106-%e6%96%b9%e6%b3%95\">10.6 方法</a></li>\n<li><a href=\"#107-%e6%8a%bd%e8%b1%a1%e7%b1%bb\">10.7 抽象类</a></li>\n<li><a href=\"#108-%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3\">10.8 隐式接口</a></li>\n<li><a href=\"#109-%e6%89%a9%e5%b1%95%e7%b1%bb\">10.9 扩展类</a></li>\n<li><a href=\"#1010-%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b\">10.10 枚举类型</a></li>\n<li><a href=\"#1011-%e7%b1%bb%e6%b7%bb%e5%8a%a0%e7%89%b9%e6%80%a7\">10.11 类添加特性</a></li>\n<li><a href=\"#1012-%e7%b1%bb%e5%8f%98%e9%87%8f%e5%92%8c%e6%96%b9%e6%b3%95\">10.12 类变量和方法</a></li>\n</ul>\n</li>\n<li><a href=\"#11-%e6%b3%9b%e5%9e%8b\">11. 泛型</a><ul>\n<li><a href=\"#111-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b\">11.1 为什么使用泛型</a></li>\n<li><a href=\"#112-%e4%bd%bf%e7%94%a8%e9%9b%86%e5%90%88%e5%ad%97%e9%9d%a2%e5%80%bc\">11.2 使用集合字面值</a></li>\n<li><a href=\"#113-%e4%bd%bf%e7%94%a8%e5%b8%a6%e5%8f%82%e6%95%b0%e5%8c%96%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0\">11.3 使用带参数化类型的构造函数</a></li>\n<li><a href=\"#114-%e6%b3%9b%e5%9e%8b%e9%9b%86%e5%90%88\">11.4 泛型集合</a></li>\n<li><a href=\"#115-%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f\">11.5 泛型约束</a></li>\n<li><a href=\"#116-%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95\">11.6 使用泛型方法</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%e5%ba%93\">12. 库</a><ul>\n<li><a href=\"#121-%e4%bd%bf%e7%94%a8%e5%ba%93\">12.1 使用库</a></li>\n<li><a href=\"#122-%e5%ae%9e%e7%8e%b0%e5%ba%93\">12.2 实现库</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%e5%bc%82%e6%ad%a5\">13. 异步</a><ul>\n<li><a href=\"#131-%e5%a4%84%e7%90%86-future\">13.1 处理 Future</a></li>\n<li><a href=\"#132-%e5%a3%b0%e6%98%8e%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0\">13.2 声明异步函数</a></li>\n<li><a href=\"#133-%e5%a4%84%e7%90%86%e6%b5%81\">13.3 处理流</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%e7%94%9f%e6%88%90%e5%99%a8\">14. 生成器</a></li>\n<li><a href=\"#15-%e5%8f%af%e8%b0%83%e7%94%a8%e7%9a%84%e7%b1%bb\">15. 可调用的类</a></li>\n<li><a href=\"#16-%e7%8b%ac%e7%ab%8b%e6%80%a7\">16. 独立性</a></li>\n<li><a href=\"#17-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89\">17. 类型定义</a></li>\n<li><a href=\"#18-%e5%85%83%e6%95%b0%e6%8d%ae\">18. 元数据</a></li>\n<li><a href=\"#19-%e6%b3%a8%e9%87%8a\">19. 注释</a></li>\n<li><a href=\"#20-%e5%b0%8f%e7%bb%93\">20. 小结</a></li>\n</ul>\n<h2 id=\"1-一段基础的-Dart-程序\"><a href=\"#1-一段基础的-Dart-程序\" class=\"headerlink\" title=\"1. 一段基础的 Dart 程序\"></a>1. 一段基础的 Dart 程序</h2><p>从以下代码片段感受下 Dart 语言的特性：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Define a function.</span></span><br><span class=\"line\">printIteger(<span class=\"built_in\">int</span> number) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'The number is $number'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This is where the app starts executing.</span></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"number\">42</span>; <span class=\"comment\">// Declare and initialize a variable.</span></span><br><span class=\"line\">    printInteger(number); <span class=\"comment\">// Call a function.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段程序使用的特性适用于其他所有 Dart 应用：</p>\n<p>// This is a comment.<br><br>一个单行注释。另外，Dart 也支持多行和文档注视。更多信息看<a href=\"https://dart.dev/guides/language/language-tour#comments\" target=\"_blank\" rel=\"noopener\">注释文档</a>。</p>\n<p>int<br><br>Dart 自带类型之一，其他的还有 <em>String</em>, <em>List</em> 和 <em>bool</em>。</p>\n<p>42<br><br>数值字面值，编译时期常量。</p>\n<p>print()<br><br>打印输出。</p>\n<p>‘…’ 或者 “…”<br><br>字符串字面值。</p>\n<p>$variableNmae 或者 ${variableName}<br><br>字符串差值写法。更多请查看<a href=\"https://dart.dev/guides/language/language-tour#strings\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>main()<br><br>App 执行入口，每个应用必须有。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#the-main-function\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"2-重要概念\"><a href=\"#2-重要概念\" class=\"headerlink\" title=\"2. 重要概念\"></a>2. 重要概念</h2><p>学习 Dart 过程中，牢记以下概念：<br></p>\n<ul>\n<li>任何可以存到变量中的都是对象，每个对象都是类的实例。数值、函数和 <code>null</code> 都是对象。所有对象都继承自 <a href=\"https://api.dart.dev/stable/dart-core/Object-class.html\" target=\"_blank\" rel=\"noopener\">Object</a> 类。</li>\n<li>虽然 Dart 是强类型的，但类型声明是可选的，因为 Dart 有类型推断。上述代码中， <code>number</code> 并没有声明类型，被自动推断成 <code>int</code>j。可以使用<a href=\"https://dart.dev/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed\" target=\"_blank\" rel=\"noopener\">特定的动态类型</a>，来声明任意类型的变量。</li>\n<li>Dart 支持泛型，比如 <code>List&lt;int&gt;</code> 和 <code>List&lt;dynamic&gt;</code>。</li>\n<li>Dart 支持将函数声明在类内部（<em>实例方法</em>）和外部（<em>静态方法</em>），也支持<em>嵌套函数</em>。</li>\n<li>类似的，Dart 也支持将变量声明在类内部（<em>实例变量<em>）和外部（</em>静态变量<em>）。实例变量也叫做域(</em>field</em>)或属性(<em>property</em>)。</li>\n<li>不同于 Java，Dart 没有 <code>public</code>, <code>protected</code> 和 <code>private</code> 关键字。可以使用 <code>_</code> 开头的标识符来表示变量是库内私有的。更多信息请看<a href=\"https://dart.dev/guides/language/language-tour#libraries-and-visibility\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n<li>标识符以字母和下划线开头，后面可以跟字母数字下划线。</li>\n<li>Dart 有表达式(<em>expressions</em>)和语句(<em>statements</em>)。</li>\n<li>Dart 工具有两种报错类型：<em>警告</em>和<em>错误</em>。警告表示代码运行结果可能不同于期望，但不会使程序退出。错误分为编译期和运行时。编译器错误会导致程序无法启动，运行时错误会导致程序运行时抛出异常。</li>\n</ul>\n<h2 id=\"3-关键字\"><a href=\"#3-关键字\" class=\"headerlink\" title=\"3. 关键字\"></a>3. 关键字</h2><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"right\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">abstract<sup>2</sup></td>\n<td align=\"center\">dynamic<sup>2</sup></td>\n<td align=\"center\">implements<sup>2</sup></td>\n<td align=\"right\">show<sup>1</sup></td>\n</tr>\n<tr>\n<td align=\"left\">as<sup>2</sup></td>\n<td align=\"center\">else</td>\n<td align=\"center\">import<sup>2</sup></td>\n<td align=\"right\">static<sup>2</sup></td>\n</tr>\n<tr>\n<td align=\"left\">assert</td>\n<td align=\"center\">enum</td>\n<td align=\"center\">in</td>\n<td align=\"right\">super</td>\n</tr>\n<tr>\n<td align=\"left\">async<sup>1</sup></td>\n<td align=\"center\">export<sup>2</sup></td>\n<td align=\"center\">interface<sup>2</sup></td>\n<td align=\"right\">switch</td>\n</tr>\n<tr>\n<td align=\"left\">await<sup>3</sup></td>\n<td align=\"center\">extends</td>\n<td align=\"center\">is</td>\n<td align=\"right\">sync<sup>1</sup></td>\n</tr>\n<tr>\n<td align=\"left\">break</td>\n<td align=\"center\">external<sup>2</sup></td>\n<td align=\"center\">library<sup>2</sup></td>\n<td align=\"right\">this</td>\n</tr>\n<tr>\n<td align=\"left\">case</td>\n<td align=\"center\">factory<sup>2</sup></td>\n<td align=\"center\">mixin<sup>2</sup></td>\n<td align=\"right\">throw</td>\n</tr>\n<tr>\n<td align=\"left\">catch</td>\n<td align=\"center\">false</td>\n<td align=\"center\">new</td>\n<td align=\"right\">true</td>\n</tr>\n<tr>\n<td align=\"left\">class</td>\n<td align=\"center\">final</td>\n<td align=\"center\">null</td>\n<td align=\"right\">try</td>\n</tr>\n<tr>\n<td align=\"left\">const</td>\n<td align=\"center\">finally</td>\n<td align=\"center\">on<sup>1</sup></td>\n<td align=\"right\">typedef<sup>2</sup></td>\n</tr>\n<tr>\n<td align=\"left\">continue</td>\n<td align=\"center\">for</td>\n<td align=\"center\">operator<sup>2</sup></td>\n<td align=\"right\">var</td>\n</tr>\n<tr>\n<td align=\"left\">convariant<sup>2</sup></td>\n<td align=\"center\">Function<sup>2</sup></td>\n<td align=\"center\">part<sup>2</sup></td>\n<td align=\"right\">void</td>\n</tr>\n<tr>\n<td align=\"left\">default</td>\n<td align=\"center\">get<sup>2</sup></td>\n<td align=\"center\">rethrow</td>\n<td align=\"right\">while</td>\n</tr>\n<tr>\n<td align=\"left\">deferred<sup>2</sup></td>\n<td align=\"center\">hide<sup>1</sup></td>\n<td align=\"center\">return</td>\n<td align=\"right\">with</td>\n</tr>\n<tr>\n<td align=\"left\">do</td>\n<td align=\"center\">if</td>\n<td align=\"center\">set<sup>2</sup></td>\n<td align=\"right\">yield<sup>3</sup></td>\n</tr>\n</tbody></table>\n<p>尽量避免使用以上关键字作为标识符。如果不可避免需要使用，可以用上角标标记：</p>\n<ul>\n<li>角标 1 单词是上下文相关的，只有在特定位置才有意义。他们可以在任意位置使用。</li>\n<li>角标 2 单词是自带标识符。为简化 JS 代码移植到 Dart 的难度，这些关键字不能用作类或者类型的名字以及导入的前缀。</li>\n<li>角标 3 单词是少有的几个跟异步操作相关的关键字，Dart 1.0 发布后才加入。不能在任何标记 <code>async</code>, <code>async*</code> 以及 <code>sync*</code> 的函数体中使用 <code>await</code> 和 <code>yield</code> 作为标识符。</li>\n</ul>\n<p>剩余的关键字是保留使用的，不能作为标识符。</p>\n<h2 id=\"4-变量\"><a href=\"#4-变量\" class=\"headerlink\" title=\"4. 变量\"></a>4. 变量</h2><p>创建并初始化一个变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>变量保存引用，<code>name</code> 变量保存对一个 <code>String</code> 对象的引用。</p>\n<p><code>name</code> 变量推断成 <code>String</code> 类型，也可以通过显示声明类型修改。如果对象不是限制为单一类型，可以使用 <code>Object</code> 或 <code>dynamic</code> 修饰。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dynamic</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>另一种方式是显示声明类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> name = <span class=\"string\">'Bob'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-默认值\"><a href=\"#4-1-默认值\" class=\"headerlink\" title=\"4.1 默认值\"></a>4.1 默认值</h3><p>未主动初始化的变量默认初始化为 <code>null</code>。即使是数值类型也是如此，在 Dart 的世界里，万物皆对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> lineCount;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;lineCount == <span class=\"keyword\">null</span>&#125;</span>'</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-Final-和-const-关键字\"><a href=\"#4-2-Final-和-const-关键字\" class=\"headerlink\" title=\"4.2 Final 和 const 关键字\"></a>4.2 Final 和 const 关键字</h3><p>对于初始化后就不再修改的变量，使用 <code>final</code> 或 <code>const</code> 替代 <code>var</code> 或者类型。final 变量只能设置一次，const 变量是一个编译期常量。一个顶层(top-level)的类变量在第一次使用的时候初始化。</p>\n<p>创建并设置一个 final 变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> name = <span class=\"string\">'Bab'</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"built_in\">String</span> nickname = <span class=\"string\">'Bobby'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>不能修改 final 变量的值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">'Alice'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>const</code> 创建<strong>编译期常量</strong>。如果是静态常量，使用 <code>static const</code> 修饰。常量必须在声明的时候用字面值或者算术表达式初始化:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">double</span> atm = <span class=\"number\">1.01325</span> * bar;</span><br></pre></td></tr></table></figure>\n\n<p><code>const</code> 关键字不仅限于声明常量，还可以用于创建常量的值，以及声明构造函数用于创建常量值。任意变量都可以有一个常量值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">const</span> [];</span><br><span class=\"line\"><span class=\"keyword\">final</span> bar = <span class=\"keyword\">const</span> [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = [];</span><br></pre></td></tr></table></figure>\n\n<p>当用 <code>const</code> 声明一个常量，可以省略初始化表达式中的 <code>const</code>。</p>\n<p>对于非 const 或 非 final 声明的变量，即使之前存的值是一个常量，仍然可以修改：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"comment\">// 之前是 []</span></span><br></pre></td></tr></table></figure>\n\n<p>但是不能修改一个 const 变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baz = [<span class=\"number\">42</span>]; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-自带类型\"><a href=\"#5-自带类型\" class=\"headerlink\" title=\"5. 自带类型\"></a>5. 自带类型</h2><p>Dart 对以下类型做了特殊支持：</p>\n<ul>\n<li>numbers</li>\n<li>strings</li>\n<li>booleans</li>\n<li>lists</li>\n<li>sets</li>\n<li>maps</li>\n<li>runes(用于在字符串中表达 Unicode 字符)</li>\n<li>symbols</li>\n</ul>\n<p>可以用以上任意类型的字面值初始化对象。比如，<code>this is a string</code> 是一个字符串字面值，<code>true</code> 是一个布尔字面值。</p>\n<p>因为 Dart 中的变量都保存一个对象的引用，所以可用构造器（<em>constructors</em>)初始化变量。部分自带类型有自己的构造器。比如，用 <code>Map()</code> 创建一个表。</p>\n<h3 id=\"5-1-数值\"><a href=\"#5-1-数值\" class=\"headerlink\" title=\"5.1 数值\"></a>5.1 数值</h3><p>Dart 支持两种数值：</p>\n<p>int<br><br>整型值。</p>\n<p>double<br><br>64位浮点数。</p>\n<p><code>int</code>, <code>float</code> 都是 num 子类（subtypes)。num 定义了 +, -, * 和 /，以及 <code>abs()</code>, <code>ceil()</code> 和 <code>floor()</code> 等方法（位运算符定义在 <code>int</code>）。其他方法可能定义在 <code>dart:math</code> 库中。</p>\n<p>整型值是不带小数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hex = <span class=\"number\">0xDEADBEEF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果数值包含小数，那它就是 double。浮点数字面值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> exponents = <span class=\"number\">1.42e5</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串和数值相互转换：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String -&gt; int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"built_in\">int</span>.parse(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(one == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String -&gt; double</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> onePointOne = <span class=\"built_in\">double</span>.parse(<span class=\"string\">'1.1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(onePointOne == <span class=\"number\">1.1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// int -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> oneAsString= <span class=\"number\">1.</span>toString();</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(oneAsString == <span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double -&gt; String</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> piAsString = <span class=\"number\">3.14159</span>.toStringAsFixed(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(piAsString == <span class=\"string\">'3.14'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>整型的位操作：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">1</span>) == <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>) == <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>((<span class=\"number\">3</span> | <span class=\"number\">4</span>) == <span class=\"number\">7</span>);</span><br></pre></td></tr></table></figure>\n\n<p>数值字面值是编译期常量。算术表达式包含的操作数都是编译期常量，那么该表达式也是编译期常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> msPerSecond = <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondsUntilRetry = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> msUntilRetry = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-字符串\"><a href=\"#5-2-字符串\" class=\"headerlink\" title=\"5.2 字符串\"></a>5.2 字符串</h3><p>Dart 字符串是 UTF-16 单元码的序列。可以用单引号或双引号创建字符串。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'Single quotes work well for string literals'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">\"Double quotes work just as well\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"string\">'It\\'s easy to escape the string delimeter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"string\">\"It's even easier to use the other delimeter\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串包含表达式的方式，用 <code>${expression}</code>。如果表达式是个标识符，可以省略 {}。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'string interpolation'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'Dart has $s, which is very handy.'</span> ==</span><br><span class=\"line\">    <span class=\"string\">'Dart has string interpolation, '</span> +</span><br><span class=\"line\">        <span class=\"string\">'which is very handy.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'That deserves all caps. '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;s.toUpperCase()&#125;</span> is very handy!'</span> ==</span><br><span class=\"line\">    <span class=\"string\">'That deserves all caps. '</span> +</span><br><span class=\"line\">        <span class=\"string\">'STRING INTERPOLATION is very handy!'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>拼接字符串可以用 <code>+</code> 运算符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'String '</span></span><br><span class=\"line\">    <span class=\"string\">'concatenation'</span></span><br><span class=\"line\">    <span class=\"string\">\" works even over line breaks.\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(s1 ==</span><br><span class=\"line\">    <span class=\"string\">'String concatenation works even over '</span></span><br><span class=\"line\">        <span class=\"string\">'line breaks.'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">'The + operator '</span> + <span class=\"string\">'works, as well.'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(s2 == <span class=\"string\">'The + operator works, as well.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建多行字符串的方式：使用 <code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">You can create</span></span><br><span class=\"line\"><span class=\"string\">multi-line strings like this one.</span></span><br><span class=\"line\"><span class=\"string\">'''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"string\">\"\"\"This is also a</span></span><br><span class=\"line\"><span class=\"string\">multi-line string.\"\"\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建原始的字符串方式：使用 <code>r</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">r'In a raw string, not even \\n gets special treatment.'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>字符串字面值是编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// These work in a const string.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstBool = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstString = <span class=\"string\">'a constant string'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// These do NOT work in a const string.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> aNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aBool = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> aString = <span class=\"string\">'a string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> aConstList = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> validConstString = <span class=\"string\">'$aConstNum $aConstBool $aConstString'</span>;</span><br><span class=\"line\"><span class=\"comment\">// const invalidConstString = '$aNum $aBool $aString $aConstList';</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-布尔\"><a href=\"#5-3-布尔\" class=\"headerlink\" title=\"5.3 布尔\"></a>5.3 布尔</h3><p>Dart 用 <code>bool</code> 表示布尔值。只有两个对象有布尔类型：布尔字面值 <code>true</code> 和 <code>false</code>，两者都是编译期常量。</p>\n<p>Dart 是类型安全的，意味着 <code>if (nonbooleanValue)</code> 或者 <code>assert (nonbooleanValue)</code> 是不合法的。应该用显式的值校验：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Check for an empty string.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fullName = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(fullName.isEmpty);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for zero.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hitPoints = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(hitPoints &lt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for null.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> unicorn;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(unicorn == <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for NaN.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iMeantToDoThis = <span class=\"number\">0</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-数组\"><a href=\"#5-4-数组\" class=\"headerlink\" title=\"5.4 数组\"></a>5.4 数组</h3><p>几乎在所有编程语言中，最通用的集合(collection)是<em>数组*或者说是对象组。Dart 中，数组是 *List</em> 对象。</p>\n<p>Dart 数组字面值类似 JS。例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p>数组索引范围[0, list.length-1]：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list.length == <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list[<span class=\"number\">1</span>] == <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list[<span class=\"number\">1</span>] == <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建编译期常量的数组方法，在数组字面值前加 <code>const</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> constantList = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">constantList[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 中引入了 <strong>展开操作符(spread operator(…))</strong> 和 <strong>可空的(null-aware)展开操作符(…?)</strong>，两者都提供了将多个元素插入集合的便捷方法。</p>\n<p>如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [<span class=\"number\">0</span>, ...list];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2.length == <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果展开操作符右边表达式可能为空，可用 <code>...?</code> 来避免异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list:</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [<span class=\"number\">0</span>, ...?list];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2.length == <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>另外，Dart 2.3 还引入了 <strong>collection if</strong> 和 <strong>collection for</strong>，用来构造集合。</p>\n<p><strong>Collection if</strong> 例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nav = [</span><br><span class=\"line\">    <span class=\"string\">'Home'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Furniture'</span>,</span><br><span class=\"line\">    <span class=\"string\">'Plants'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promoActive) <span class=\"string\">'Outlet'</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><strong>Collection for</strong> 例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = [</span><br><span class=\"line\">    <span class=\"string\">'#0'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> list1) <span class=\"string\">'#$i'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(list2[<span class=\"number\">1</span>] == <span class=\"string\">'#1'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-集\"><a href=\"#5-5-集\" class=\"headerlink\" title=\"5.5 集\"></a>5.5 集</h3><p>Dart 集无序且元素唯一。Dart 通过两方面支持集，一个是字面值，另一个是 <code>Set</code> 类型。</p>\n<p>字面值创建集对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> halogens = &#123;<span class=\"string\">'fluorine'</span>, <span class=\"string\">'chlorine'</span>, <span class=\"string\">'bromine'</span>, <span class=\"string\">'iodine'</span>, <span class=\"string\">'astatine'</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建空集：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; set2 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> map = &#123;&#125;; <span class=\"comment\">// Create a map, not a set.</span></span><br></pre></td></tr></table></figure>\n\n<p>集添加元素，<code>add()</code> 或者 <code>addAll()</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\">set1.add(<span class=\"string\">'fluorine'</span>);</span><br><span class=\"line\">set1.addAll(halogens);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>.length</code> 获取集的大小：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set1 = &lt;<span class=\"built_in\">String</span>&gt;&#123;&#125;;</span><br><span class=\"line\">set1.add(<span class=\"string\">'fluorine'</span>);</span><br><span class=\"line\">set1.addAll(halogens);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(set1.length == <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建集的编译期字面值，集字面值前加 <code>const</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> constantSet = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">'fluorine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'chlorine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'bromine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'iodine'</span>,</span><br><span class=\"line\">  <span class=\"string\">'astatine'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// constantSet.add('helium'); // Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 后，集也同数组一样，支持展开操作符和 collection fors 以及 ifs。</p>\n<h3 id=\"5-6-表\"><a href=\"#5-6-表\" class=\"headerlink\" title=\"5.6 表\"></a>5.6 表</h3><p>表包含键值对，键值可以是任意类型的对象。Key 在表中唯一，value 可以重复。Dart 通过两方面支持表，一个是字面值，另一个是 Map 类型。</p>\n<p>Dart 表的字面值例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Key:    Value</span></span><br><span class=\"line\">  <span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>,</span><br><span class=\"line\">  <span class=\"string\">'second'</span>: <span class=\"string\">'turtledoves'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fifth'</span>: <span class=\"string\">'golden rings'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也可以用构造函数创建的表对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">gifts[<span class=\"string\">'first'</span>] = <span class=\"string\">'partridge'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'second'</span>] = <span class=\"string\">'turtledoves'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'fifth'</span>] = <span class=\"string\">'golden rings'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">nobleGases[<span class=\"number\">2</span>] = <span class=\"string\">'helium'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">10</span>] = <span class=\"string\">'neon'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">18</span>] = <span class=\"string\">'argon'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对已有表中增加键值对：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\">gifts[<span class=\"string\">'fourth'</span>] = <span class=\"string\">'calling birds'</span>; <span class=\"comment\">// Add a key-value pair</span></span><br></pre></td></tr></table></figure>\n\n<p>从表中获取值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts[<span class=\"string\">'first'</span>] == <span class=\"string\">'partridge'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>从表中查不到对应的 key：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts[<span class=\"string\">'fifth'</span>] == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>用 <code>.length</code> 获取表中键值对数量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;<span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>&#125;;</span><br><span class=\"line\">gifts[<span class=\"string\">'fourth'</span>] = <span class=\"string\">'calling birds'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(gifts.length == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>创建表的编译期常量，表字面值前加 <code>const</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> constantMap = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Dart 2.3 后，表也同数组一样，支持展开操作符和 collection fors 以及 ifs。</p>\n<h3 id=\"5-7-Runes\"><a href=\"#5-7-Runes\" class=\"headerlink\" title=\"5.7 Runes\"></a>5.7 Runes</h3><p>Dart runes 是字符串的 UTF-32 码点。</p>\n<p>Unicode 为全世界所有字母，数字和符号定义了唯一的数值。由于 Dart 字符串是 UTF-16 单元码的序列，因此在字符串中药表示 32位 Unicode 值需要特殊语法。</p>\n<p>通常表达一个 Unicode 码点的形式是 <code>\\uXXXX</code>，XXXX 是一个4位的16进制数。比如，爱心字符(♥)是 <code>\\u2665</code>。当指定多于或少于4位数字时，将值放在花括号中。</p>\n<p>String 类有一些相关属性获取 rune 信息。比如，<code>codeUnitAt</code> 和 <code>codeUnit</code> 属性返回16位的单元码，用 <code>runes</code> 属性获取字符串中的 runes。</p>\n<p>16位和32位转换：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping.codeUnits);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(clapping.runes.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">  Runes input = <span class=\"keyword\">new</span> Runes(</span><br><span class=\"line\">      <span class=\"string\">'\\u2665  \\u&#123;1f605&#125;  \\u&#123;1f60e&#125;  \\u&#123;1f47b&#125;  \\u&#123;1f596&#125;  \\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCodes(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-8-符号\"><a href=\"#5-8-符号\" class=\"headerlink\" title=\"5.8 符号\"></a>5.8 符号</h3><p><em>符号</em> 对象代表 Dart 程序中的运算符或者标识符。你可能从不会用符号，但它们对于按名称引用标识符的 API 非常有用，因为缩小会更改标识符名称而不会更改标识符符号。</p>\n<p>获取符号的方法，<code>#</code> 号后面跟着标识符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#radix</span><br><span class=\"line\">#bar</span><br></pre></td></tr></table></figure>\n\n<p>符号字面值是编译期常量。</p>\n<h2 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6. 函数\"></a>6. 函数</h2><p>Dart 是真正的面向对象语言，即使是函数也有类型，<em>Funtion</em>。这意味着函数可以赋值给变量或者作为参数传递。还可以调用类的实例，就好像它是一个函数。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#callable-classes\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>函数的实现如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isNoble(<span class=\"built_in\">int</span> atomicNumber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然类型标注更为高效，但是省略类型的函数依然可用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNoble(atomicNumber) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于只有一个表达式的函数，可以简写为：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> isNoble(<span class=\"built_in\">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>=&gt; expr</code> 语法是 <code>{ return expr; } 的简写。</code>=&gt;` 标注通常推断为<em>箭头</em>语法。</p>\n<p>函数参数支持两种类型：必需(required)和可选(optional)。必需参数在前，可选参数在后。命名为可选的参数仍然可以标记为 <code>@required</code>。</p>\n<h3 id=\"6-1-可选参数\"><a href=\"#6-1-可选参数\" class=\"headerlink\" title=\"6.1 可选参数\"></a>6.1 可选参数</h3><p>通过位置或命名中的一种来标记可选参数，但不能两者同时使用。</p>\n<h4 id=\"可选命名参数\"><a href=\"#可选命名参数\" class=\"headerlink\" title=\"可选命名参数 \"></a>可选命名参数 <!-- omit in toc --></h4><p>调用一个函数，可通过 <code>paramName: value</code> 指定命名的参数，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enableFlags(bold: <span class=\"keyword\">true</span>, hidde: <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在定义函数的时候，使用 <code>{param1, param2, ...}</code> 指定命名参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> enableFlags(&#123;<span class=\"built_in\">bool</span> bold, <span class=\"built_in\">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>Flutter</em> 实例创建表达式较为复杂，所以 widget 构造函数只使用命名的参数。这能让实例创建表达式可读性更高。</p>\n<p>你可以在任意的 Dart 代码中使用 <code>@required</code> 来标记命名的参数，从而指定该参数为<em>必需</em>参数。举例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Scrollbar(&#123;Key key, <span class=\"meta\">@required</span> Widget child&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>当构造一个 <code>Scrollbar</code> 时，如果 <code>child</code> 参数缺省，编译器会报错。</p>\n<p><em>Required</em> 定义在 <em>meta</em> 包中。两种方式导入：import <code>package:meta/meta.dart</code> 或导入其它导出 <code>meta</code> 的包。</p>\n<h4 id=\"可选位置参数\"><a href=\"#可选位置参数\" class=\"headerlink\" title=\"可选位置参数 \"></a>可选位置参数 <!-- omit in toc --></h4><p>函数参数列表中，将后面的参数用 <code>[]</code> 标记：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg, [<span class=\"built_in\">String</span> device]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'$from says $msg'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"string\">'$result with a $device'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不带可选参数的调用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>) == <span class=\"string\">'Bob says Howdy'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>携带可选参数的调用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>, <span class=\"string\">'smoke signal'</span>) == <span class=\"string\">'Bob says Howdy with a smoke signal'</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认参数值\"><a href=\"#默认参数值\" class=\"headerlink\" title=\"默认参数值 \"></a>默认参数值 <!-- omit in toc --></h4><p>函数参数支持给定默认值，包括命名和位置参数。默认值是编译期常量。如果没有主动提供默认值，默认值为 <code>null</code>。</p>\n<p>默认值例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> enableFlags(&#123;<span class=\"built_in\">bool</span> bold = <span class=\"keyword\">false</span>, <span class=\"built_in\">bool</span> hidden = <span class=\"keyword\">false</span>&#125;) &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bold will be true; hidden will be false.</span></span><br><span class=\"line\">enableFlags(bold: <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为位置参数提供默认值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> say(<span class=\"built_in\">String</span> from, <span class=\"built_in\">String</span> msg,</span><br><span class=\"line\">    [<span class=\"built_in\">String</span> device = <span class=\"string\">'carrier pigeon'</span>, <span class=\"built_in\">String</span> mood]) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"string\">'$from says $msg'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (device != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">'$result with a $device'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mood != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"string\">'$result (in a $mood mood)'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(say(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Howdy'</span>) ==</span><br><span class=\"line\">    <span class=\"string\">'Bob says Howdy with a carrier pigeon'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>函数参数类型为数组或表类型，也支持默认值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> doStuff(</span><br><span class=\"line\">    &#123;<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; list = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">    <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; gifts = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      <span class=\"string\">'first'</span>: <span class=\"string\">'paper'</span>,</span><br><span class=\"line\">      <span class=\"string\">'second'</span>: <span class=\"string\">'cotton'</span>,</span><br><span class=\"line\">      <span class=\"string\">'third'</span>: <span class=\"string\">'leather'</span></span><br><span class=\"line\">    &#125;&#125;) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'list:  $list'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'gifts: $gifts'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-main-函数\"><a href=\"#6-2-main-函数\" class=\"headerlink\" title=\"6.2 main() 函数\"></a>6.2 main() 函数</h3><p>每个应用都有一个顶层的 <code>main()</code> 函数作为程序入口。该函数返回值为 <code>void</code> 并且有一个可选参数，类型为 <code>List&lt;String&gt;</code>。</p>\n<p>Web 程序的 <code>main()</code> 函数例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#sample_text_id'</span>);</span><br><span class=\"line\">    ..text = <span class=\"string\">'Click me!'</span>;</span><br><span class=\"line\">    ..onClick.listen(reverseText);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命令行程序的 <code>main()</code> 函数例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Run the app like this: dart args.dart 1 test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt; arguments) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(arguments.length == <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"built_in\">int</span>.parse(arguments[<span class=\"number\">0</span>]) == <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(arguments[<span class=\"number\">1</span>] == <span class=\"string\">'test'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用 <em>args library</em> 库定义并解析命令行参数。</p>\n<h3 id=\"6-3-一等公民函数\"><a href=\"#6-3-一等公民函数\" class=\"headerlink\" title=\"6.3 一等公民函数\"></a>6.3 一等公民函数</h3><p>函数可以作为其它函数的参数，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> printElement(<span class=\"built_in\">int</span> element) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pass printElement as aparameter.</span></span><br><span class=\"line\">list.forEach(printElement);</span><br></pre></td></tr></table></figure>\n\n<p>函数也可以存到变量中，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loudify = (msg) =&gt; <span class=\"string\">'!!! <span class=\"subst\">$&#123;msg.toUpperCase()&#125;</span>!!!'</span>;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(loudify(<span class=\"string\">'hello'</span>) == <span class=\"string\">'!!!HELLO!!!'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面使用了匿名函数。</p>\n<h3 id=\"6-4-匿名函数\"><a href=\"#6-4-匿名函数\" class=\"headerlink\" title=\"6.4 匿名函数\"></a>6.4 匿名函数</h3><p>大多函数都有名字，比如 <code>main()</code> 和 <code>printElement()</code>，一些没有名字的函数叫做 <em>匿名函数(Anonymous funstions)<em>、</em>lambda</em> 或 <em>闭包(closure)</em>。函数存到变量中，可以被添加到集合中或者被移除。</p>\n<p>匿名函数和一般函数类似，0个或多个参数，参数间用逗号隔开，支持可选类型标注，参数用 <code>()</code> 包含。</p>\n<p>匿名函数如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([<span class=\"built_in\">Type</span>] param1[, ...]) &#123;</span><br><span class=\"line\">  codeBlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下例子定义一个匿名函数，函数携带一个未定义类型的参数 <code>item</code>。每遍历一个 list 中元素，函数都会被调用一次，并打印对应元素的信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'oranges'</span>];</span><br><span class=\"line\">list.forEach((item) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数也可以简写成箭头函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.forEach((item) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-作用域\"><a href=\"#6-5-作用域\" class=\"headerlink\" title=\"6.5 作用域\"></a>6.5 作用域</h3><p>Dart 是一种 <em>lexically scoped language</em>。代码的布局决定了变量的作用域。</p>\n<p>以下例子展示了嵌套函数的变量作用域：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> topLevel = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> insideMain = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> myFunction() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> insideFunction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> nestedFunction() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> insideNestedFunction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(topLevel);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideMain);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideFunction);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span>(insideNestedFunction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-6-词法闭包\"><a href=\"#6-6-词法闭包\" class=\"headerlink\" title=\"6.6 词法闭包\"></a>6.6 词法闭包</h3><p><em>闭包</em> 是函数，能访问作用域内的变量，即使该闭包在原来作用域外部被使用。</p>\n<p>函数能延长变量的生命周期。以下例子中，<code>makeAdder()</code> 捕获变量 <code>addBy</code>。当函数执行结束，<code>addBy</code> 被保存到函数中。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Returns a function that adds [addBy] to the</span></span><br><span class=\"line\"><span class=\"comment\">/// function's argument.</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makeAdder(<span class=\"built_in\">num</span> addBy) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; addBy + i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 2.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add2 = makeAdder(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create a function that adds 4.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> add4 = makeAdder(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add2(<span class=\"number\">3</span>) == <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(add4(<span class=\"number\">3</span>) == <span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-7-函数的等价性\"><a href=\"#6-7-函数的等价性\" class=\"headerlink\" title=\"6.7 函数的等价性\"></a>6.7 函数的等价性</h3><p>以下例子中，比较了顶层函数，静态方法和实例方法的等价性:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> foo() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> bar() &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> baz() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing top-level functions.</span></span><br><span class=\"line\">  x = foo;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(foo == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing static methods.</span></span><br><span class=\"line\">  x = A.bar;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(A.bar == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Comparing instance methods.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = A();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = A();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = w;</span><br><span class=\"line\">  x = w.baz;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(y.baz == x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(v.baz != w.baz);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```Dart</span><br><span class=\"line\"></span><br><span class=\"line\">### <span class=\"number\">6.8</span> 返回值</span><br><span class=\"line\"></span><br><span class=\"line\">所有函数都有返回值。如果没有显示指定，会默认在函数体最后加上 `<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>`。</span><br><span class=\"line\">```Dart</span><br><span class=\"line\">foo() &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo() == <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-运算符\"><a href=\"#7-运算符\" class=\"headerlink\" title=\"7. 运算符\"></a>7. 运算符</h2><table>\n<thead>\n<tr>\n<th align=\"center\">描述</th>\n<th align=\"center\">运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">一元后缀运算符</td>\n<td align=\"center\"><code>expr++</code>, <code>expr--</code>, <code>()</code>, <code>.</code>, <code>?.</code></td>\n</tr>\n<tr>\n<td align=\"center\">一元前缀运算符</td>\n<td align=\"center\"><code>-expr</code>, <code>!expr</code>, <code>~expr</code>, <code>++expr</code>, <code>--expr</code></td>\n</tr>\n<tr>\n<td align=\"center\">乘法（multiplicative）</td>\n<td align=\"center\"><code>*</code>, <code>/</code>, <code>%</code>, <code>~/</code></td>\n</tr>\n<tr>\n<td align=\"center\">加法</td>\n<td align=\"center\"><code>+</code>, <code>-</code></td>\n</tr>\n<tr>\n<td align=\"center\">位移</td>\n<td align=\"center\"><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></td>\n</tr>\n<tr>\n<td align=\"center\">位与</td>\n<td align=\"center\"><code>&amp;</code></td>\n</tr>\n<tr>\n<td align=\"center\">位异或</td>\n<td align=\"center\"><code>^</code></td>\n</tr>\n<tr>\n<td align=\"center\">位或</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\">关系运算和类型推断</td>\n<td align=\"center\"><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>as</code>, <code>is</code>, <code>is!</code></td>\n</tr>\n<tr>\n<td align=\"center\">等价</td>\n<td align=\"center\"><code>==</code>, <code>!=</code></td>\n</tr>\n<tr>\n<td align=\"center\">逻辑与</td>\n<td align=\"center\"><code>&amp;&amp;</code></td>\n</tr>\n<tr>\n<td align=\"center\">逻辑或</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\">可选判断</td>\n<td align=\"center\"><code>??</code></td>\n</tr>\n<tr>\n<td align=\"center\">条件</td>\n<td align=\"center\"><code>expr1 ? expr2 : expr3</code></td>\n</tr>\n<tr>\n<td align=\"center\">多级</td>\n<td align=\"center\"><code>..</code></td>\n</tr>\n<tr>\n<td align=\"center\">赋值</td>\n<td align=\"center\"><code>=</code>, <code>*=</code>, <code>/=</code>, <code>+=</code>, <code>-=</code>, <code>&amp;=</code>, <code>^=</code>, etc</td>\n</tr>\n</tbody></table>\n<p>运算符使用例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++</span><br><span class=\"line\">a + b</span><br><span class=\"line\">a = b</span><br><span class=\"line\">a == b</span><br><span class=\"line\">c ? a : b</span><br><span class=\"line\">a <span class=\"keyword\">is</span> T</span><br></pre></td></tr></table></figure>\n\n<p>上述表中的运算符优先从高到底排列。运算符优先级的作用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((n % i == <span class=\"number\">0</span>) &amp;&amp; (d % i ) == <span class=\"number\">0</span>) ...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (n % i == <span class=\"number\">0</span> &amp;&amp; d % i == <span class=\"number\">0</span>) ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-算数运算符\"><a href=\"#7-1-算数运算符\" class=\"headerlink\" title=\"7.1 算数运算符\"></a>7.1 算数运算符</h3><p>Dart 支持的算术运算符：<br>|  运算符 | 意义 |<br>| ——: | :— |<br>|     <code>+</code> | 加   |<br>|     <code>-</code> | 减   |<br>| <code>-expr</code> | 负号 |<br>|     <code>*</code> | 乘   |<br>|     <code>/</code> | 除   |<br>|    <code>~/</code> | 取商 |<br>|     <code>%</code> | 取模 |</p>\n<p>Dart 支持的递增/递减运算符：<br>| 运算符  |                  意义                   |<br>| :—–: | :————————————-: |<br>| <code>++var</code> |  <code>var = var + 1</code>(表达式的值是加后的值)  |<br>| <code>var++</code> | <code>var = var + 1</code>（表达式的值是加前的值） |<br>| <code>--var</code> | <code>var = var - 1</code>（表达式的值是减后的值） |<br>| <code>var--</code> | <code>var = var - 1</code>（表达式的值是减前的值） |</p>\n<h3 id=\"7-2-关系运算法\"><a href=\"#7-2-关系运算法\" class=\"headerlink\" title=\"7.2 关系运算法\"></a>7.2 关系运算法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>==</code></td>\n<td align=\"center\">相等</td>\n</tr>\n<tr>\n<td align=\"center\"><code>!=</code></td>\n<td align=\"center\">不等</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;</code></td>\n<td align=\"center\">大于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;</code></td>\n<td align=\"center\">小于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;=</code></td>\n<td align=\"center\">大于等于</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;=</code></td>\n<td align=\"center\">小于等于</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-3-类型推断运算符\"><a href=\"#7-3-类型推断运算符\" class=\"headerlink\" title=\"7.3 类型推断运算符\"></a>7.3 类型推断运算符</h3><p>运行时用于类型校验：<br>| 运算符 |               意义               |<br>| :—-: | :——————————: |<br>|  <code>as</code>  | 类型推断(类型推断错误会抛出异常) |<br>|  <code>is</code>  |    对象是指定类型时返回 true     |<br>| <code>is!</code>  |   对象不是指定类型时返回 true    |</p>\n<h3 id=\"7-4-赋值运算符\"><a href=\"#7-4-赋值运算符\" class=\"headerlink\" title=\"7.4 赋值运算符\"></a>7.4 赋值运算符</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td><code>-=</code></td>\n<td><code>/=</code></td>\n<td><code>%\\</code></td>\n<td><code>&gt;&gt;=</code></td>\n<td><code>^=</code></td>\n</tr>\n<tr>\n<td><code>+=</code></td>\n<td><code>*=</code></td>\n<td><code>~/=</code></td>\n<td><code>&lt;&lt;=</code></td>\n<td><code>&amp;=</code></td>\n<td>`</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">联合赋值</th>\n<th align=\"center\">等价表达式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">op</td>\n<td align=\"center\"><code>a op= b</code></td>\n<td align=\"center\"><code>a= a op b</code></td>\n</tr>\n<tr>\n<td align=\"center\">例子</td>\n<td align=\"center\"><code>a += b</code></td>\n<td align=\"center\"><code>a = a + b</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"7-5-逻辑运算符\"><a href=\"#7-5-逻辑运算符\" class=\"headerlink\" title=\"7.5 逻辑运算符\"></a>7.5 逻辑运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>!expr</code></td>\n<td align=\"center\">逻辑非</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;&amp;</code></td>\n<td align=\"center\">逻辑与</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-6-位移运算符\"><a href=\"#7-6-位移运算符\" class=\"headerlink\" title=\"7.6 位移运算符\"></a>7.6 位移运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">运算符</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&amp;</code></td>\n<td align=\"center\">位与</td>\n</tr>\n<tr>\n<td align=\"center\">`</td>\n<td align=\"center\">`</td>\n</tr>\n<tr>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">位异或（相同为0，不同为1）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>~expr</code></td>\n<td align=\"center\">位取反（0-&gt;1, 1-&gt;0）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&lt;&lt;</code></td>\n<td align=\"center\">左移一位</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;&gt;</code></td>\n<td align=\"center\">右移一位</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-7-条件表达式\"><a href=\"#7-7-条件表达式\" class=\"headerlink\" title=\"7.7 条件表达式\"></a>7.7 条件表达式</h3><p>Dart 支持两个条件表达式：</p>\n<p><code>condition ? expr1 : expr2</code><br><br>如果条件为真，执行表达式1并返回结果；否则，执行表达式2并返回结果。</p>\n<p><code>expr1 ?? expr2</code><br><br>如果表达式1非空，返回其值；否则，执行表达式2并返回结果。</p>\n<h3 id=\"7-8-多级表示法\"><a href=\"#7-8-多级表示法\" class=\"headerlink\" title=\"7.8 多级表示法\"></a>7.8 多级表示法</h3><p>连续调用相同对象，使用 <code>..</code> 可以简化写法，减少使用临时变量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">querySelector</span>(<span class=\"string\">'#confirm'</span>)</span><br><span class=\"line\">  ..text = <span class=\"string\">'Confirm'</span></span><br><span class=\"line\">  ..classes.add(<span class=\"string\">'important'</span>)</span><br><span class=\"line\">  ..onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirm!'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于以下写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">querySelector</span>(<span class=\"string\">'#confirm'</span>);</span><br><span class=\"line\">button.text = <span class=\"string\">'Confirm'</span>;</span><br><span class=\"line\">button.classes.add(<span class=\"string\">'important'</span>);</span><br><span class=\"line\">button.onClick.listen((e) =&gt; <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>嵌套写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> addressBook = (</span><br><span class=\"line\">  AddressBookBuilder()</span><br><span class=\"line\">    ..name = <span class=\"string\">'jenny'</span></span><br><span class=\"line\">    ..email = <span class=\"string\">'jenny@example.com'</span></span><br><span class=\"line\">    ..phone = (</span><br><span class=\"line\">      PhoneNumberBuilder()</span><br><span class=\"line\">        ..number = <span class=\"string\">'xxx-xxx-xxxx'</span></span><br><span class=\"line\">        ..label = <span class=\"string\">'home'</span></span><br><span class=\"line\">      .build();</span><br><span class=\"line\">    )</span><br><span class=\"line\">  .build();</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-其它\"><a href=\"#7-9-其它\" class=\"headerlink\" title=\"7.9 其它\"></a>7.9 其它</h3><p>其他运算符：<br>| 运算符 |         名字         |                  意义                   |<br>| :—-: | :——————: | :————————————-: |<br>|  <code>()</code>  | Function application |              表示调用函数               |<br>|  <code>[]</code>  |       访问数组       |      引用数组指定索引位置上的元素       |<br>|  <code>.</code>   |     访问成员变量     |             表达式访问属性              |<br>|  <code>?.</code>  |   条件访问成员变量   | 类似 <code>.</code>，支持空对象(类似 Swift 可选链) |</p>\n<h2 id=\"8-控制语句\"><a href=\"#8-控制语句\" class=\"headerlink\" title=\"8. 控制语句\"></a>8. 控制语句</h2><p>Dart 控制流：</p>\n<ul>\n<li><code>if else</code></li>\n<li><code>switch case</code></li>\n<li><code>while</code> &amp; <code>do-while</code></li>\n<li><code>break</code> &amp; <code>continue</code></li>\n<li><code>for</code> 循环</li>\n<li><code>assert</code></li>\n</ul>\n<p>另外，还有 <code>try-catch</code> 和 <code>throw</code>。</p>\n<h3 id=\"8-1-If-else\"><a href=\"#8-1-If-else\" class=\"headerlink\" title=\"8.1 If else\"></a>8.1 If else</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isRaining()) &#123;</span><br><span class=\"line\">  you.bringRainCoat();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isSnowing()) &#123;</span><br><span class=\"line\">  you.wearJacket();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  car.putTopDown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不同于 JS 的地方， Dart 条件必须是布尔值。</p>\n<h3 id=\"8-2-For-循环\"><a href=\"#8-2-For-循环\" class=\"headerlink\" title=\"8.2 For 循环\"></a>8.2 For 循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"built_in\">StringBuffer</span>(<span class=\"string\">'Dart is fun'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  msg.write(<span class=\"string\">'!'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>闭包捕获变量，并在内部拷贝，即使 <code>i</code> 改变也不会影响之前的值： </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">  callbacks.append(() =&gt; <span class=\"built_in\">print</span>(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c()); <span class=\"comment\">// Dart 输出 0, 1； JS 输出 2, 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-While-amp-do-while\"><a href=\"#8-3-While-amp-do-while\" class=\"headerlink\" title=\"8.3 While &amp; do-while\"></a>8.3 While &amp; do-while</h3><p><code>while</code> 在进入循环体之前判断条件：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>do-while</code> 先执行循环体再判断条件：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(!atEndOfPage())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-4-Break-amp-continue\"><a href=\"#8-4-Break-amp-continue\" class=\"headerlink\" title=\"8.4 Break &amp; continue\"></a>8.4 Break &amp; continue</h3><ul>\n<li><code>break</code> 跳出循环</li>\n<li><code>continue</code> 跳过当前循环</li>\n</ul>\n<h3 id=\"8-5-Switch-case\"><a href=\"#8-5-Switch-case\" class=\"headerlink\" title=\"8.5 Switch case\"></a>8.5 Switch case</h3><p>Dart switch 支持整型，字符串和编译期常量。对象必须是相同类型且该类没有重载 <code>==</code>。</p>\n<p>每个非空的 <code>case</code> 从句，必须要有 <code>break</code>。其他结束 <code>case</code> 的语句：<code>continue</code>, <code>return</code> 和 <code>throw</code>。</p>\n<p>非空的 <code>case</code> 中省略 <code>break</code> 会报编译错误：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">  executeOpen();</span><br><span class=\"line\">  <span class=\"comment\">// Error: Missing break</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSE'</span>:</span><br><span class=\"line\">  executeClose();</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>case</code> 可以为空：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">  executeNowClosed();</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dart 支持 <code>continue</code> 加标签的方式控制代码执行：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span> nowClosed;</span><br><span class=\"line\">  <span class=\"comment\">// Continues executing at the nowClosed label.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  nowClosed:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>case</code> 内部可以定义局部变量，变量作用域仅限此代码块。</p>\n<h3 id=\"8-6-断言\"><a href=\"#8-6-断言\" class=\"headerlink\" title=\"8.6 断言\"></a>8.6 断言</h3><p>开发者模式下，支持 <code>assert(condition, optionalMessage)</code> 终止程序。</p>\n<h2 id=\"9-异常处理\"><a href=\"#9-异常处理\" class=\"headerlink\" title=\"9. 异常处理\"></a>9. 异常处理</h2><p>Dart 支持异常捕获机制。异常是程序运行过程中不可知的错误。如果程序没有捕获异常，抛出异常的<a href=\"https://zhuanlan.zhihu.com/p/40069285\" target=\"_blank\" rel=\"noopener\"><strong>isolate</strong></a> 会被挂起，通常情况下，isolate 和程序都会被终止。</p>\n<p>不同于 Java， Dart 的异常都是未经检查的。方法不会声明可能的异常，并且不需要去处理。</p>\n<p>Dart 提供了 <em>Exception<em>，</em>Error</em> 以及其他的子类。开发者可以自定义异常。另外，Dart 程序可以把所有非空对象作为异常抛出。</p>\n<h3 id=\"9-1-Throw\"><a href=\"#9-1-Throw\" class=\"headerlink\" title=\"9.1 Throw\"></a>9.1 Throw</h3><p>抛出异常的例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>抛出任意非空对象作为异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Out of llamas'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为抛出异常是一个表达式，所以可以出现在任何需要表达式的位置：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> distanceTo(Point point) =&gt; <span class=\"keyword\">throw</span> UnimplementedError();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-Catch\"><a href=\"#9-2-Catch\" class=\"headerlink\" title=\"9.2 Catch\"></a>9.2 Catch</h3><p>捕获异常能停止异常的传递，给程序处理异常的能力：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlammas();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于能抛出多种异常类型的代码，可以使用多个 catch 从句。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A specific exception</span></span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Anything else that is an exception</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: $e'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// No specified type, handles all</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Something really unknown: $e'</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>catch()</code> 可以指定两个参数，第一个是抛出的异常，第二个是栈回溯(<a href=\"https://api.dart.dev/stable/dart-core/StackTrace-class.html\" target=\"_blank\" rel=\"noopener\">StackTrace</a>)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n $e'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e, s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n $e'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Stack trace:\\n $s'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在当前位置处理异常并继续传递，使用 <code>rethrow</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> misbehave() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(foo++); <span class=\"comment\">// Runtime error</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'misbehave() partially handled <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">rethrow</span>; <span class=\"comment\">// Allow callers to see the exception.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    misbehave();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'main() finished handling <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-Finally\"><a href=\"#9-3-Finally\" class=\"headerlink\" title=\"9.3 Finally\"></a>9.3 Finally</h3><p>无论是否抛出异常，使用finally子句，确保代码运行。如果 <code>catch</code> 没有匹配到异常，该异常会在 <code>finally</code> 后继续传播：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Always clean up, even if an exception is thrown.</span></span><br><span class=\"line\">  cleanLlamaStalls();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 匹配到异常后，也会执行 <code>finally</code> 从句：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Error: $e'</span>); <span class=\"comment\">// Handle the exception first.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  cleanLlamaStalls(); <span class=\"comment\">// Then clean up.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-类\"><a href=\"#10-类\" class=\"headerlink\" title=\"10. 类\"></a>10. 类</h2><p>Dart 是面向对象语言，具有类和基于 mixin 的继承。每个对象都是类的实例，每个类继承自 <em>Object*。基于 *mixin</em> 的继承意味着类只有一个超类，但是类的成员可被多个类结构重用。</p>\n<h3 id=\"10-1-使用类成员变量\"><a href=\"#10-1-使用类成员变量\" class=\"headerlink\" title=\"10.1 使用类成员变量\"></a>10.1 使用类成员变量</h3><p>对象的成员由函数和数据组成。当一个方法被调用时，也就是调用对象的某个方法：通过对象的函数和数据获取方法。</p>\n<p>使用 <code>.</code> 引用实例变量或方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set the value of the instance variable y.</span></span><br><span class=\"line\">p.y = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get the value of y.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(p.y == <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Invoke distanceTo() on p.</span></span><br><span class=\"line\"><span class=\"built_in\">num</span> distance = p.distanceTo(Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>?.</code> 避免调用链为 null 时产生异常：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If p is non-null, set its y value to 4.</span></span><br><span class=\"line\">p?.y = <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-2-使用构造函数\"><a href=\"#10-2-使用构造函数\" class=\"headerlink\" title=\"10.2 使用构造函数\"></a>10.2 使用构造函数</h3><p>使用构造器构造对象。构造器命名可以是 <code>ClassName</code> 或 <code>ClassName.identifier</code>。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>以下代码效果相同，构造器前面多一个可选的 <code>new</code> 关键字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>部分类提供了<a href=\"https://dart.dev/guides/language/language-tour#constant-constructors\" target=\"_blank\" rel=\"noopener\">常量构造器</a>。构造器前加 <code>const</code> 修饰，以创建编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造两个等价的编译期常量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(identical(a, b)); <span class=\"comment\">// They are the same instance!</span></span><br></pre></td></tr></table></figure>\n\n<p>如果能通过上下文推断出是常量，则可省略 <code>const</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lots of const keywords here.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以简写为：</span></span><br><span class=\"line\"><span class=\"comment\">// Only one const, which establishes the constant context.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: [ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: [ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个常量构造器超出常量上下文，并且没用 <code>const</code> 修饰，则创建一个非常量对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">// Creates a constant</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">// Does NOT create a constant</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(!identical(a, b)); <span class=\"comment\">// NOT the same instance!</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-获取对象类型\"><a href=\"#10-3-获取对象类型\" class=\"headerlink\" title=\"10.3 获取对象类型\"></a>10.3 获取对象类型</h3><p>使用 Object <code>runtimeType</code> 属性，在运行时获取对象类型，返回 <code>Type</code> 对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'The type of a is <span class=\"subst\">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上内容介绍了如何<em>使用</em>类，下面介绍如何实现类。</p>\n<h3 id=\"10-4-实例变量\"><a href=\"#10-4-实例变量\" class=\"headerlink\" title=\"10.4 实例变量\"></a>10.4 实例变量</h3><p>如何声明一个实例变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x; <span class=\"comment\">// Declare instance variable x, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> y; <span class=\"comment\">// Declare y, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> z = <span class=\"number\">0</span>; <span class=\"comment\">// Declare z, initially 0.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>未初始化的实例变量默认为 <code>null</code>。</p>\n<p>所以实例变量隐式生成 <em>getter</em> 方法。所有实例变量（除了 final）隐式生成 <em>setter</em> 方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = Point();</span><br><span class=\"line\">  point.x = <span class=\"number\">4</span>; <span class=\"comment\">// Use the setter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.x == <span class=\"number\">4</span>); <span class=\"comment\">// Use the getter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.y == <span class=\"keyword\">null</span>); <span class=\"comment\">// Values default to null.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于实例变量的生命周期，实例变量在构造器和初始化器执行之前就已创建，如果声明实例变量的时候手动初始化了，那么初始化也在此时完成。</p>\n<h3 id=\"10-5-构造函数\"><a href=\"#10-5-构造函数\" class=\"headerlink\" title=\"10.5 构造函数\"></a>10.5 构造函数</h3><p>构造器写法：声明一个函数，函数名和类名相同。最常见的构造器形式就是生成构造器，会创建类的一个新实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"built_in\">num</span> x, <span class=\"built_in\">num</span> y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's a better way to do this, stay tuned.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>this</code> 关键字引用当前实例。</p>\n<p>构造器的一个语法糖写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Syntactic sugar for setting x and y</span></span><br><span class=\"line\">  <span class=\"comment\">// before the constructor body runs.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器 \"></a>默认构造器 <!-- omit in toc --></h4><p>如果没有生命构造器，Dart 会默认生成一个构造器。此构造器没有参数，并调用父类的不带参构造器。</p>\n<h4 id=\"构造器不继承\"><a href=\"#构造器不继承\" class=\"headerlink\" title=\"构造器不继承 \"></a>构造器不继承 <!-- omit in toc --></h4><p>构造器不支持继承。</p>\n<h4 id=\"带名字的构造器\"><a href=\"#带名字的构造器\" class=\"headerlink\" title=\"带名字的构造器 \"></a>带名字的构造器 <!-- omit in toc --></h4><p>如果需要创建多个构造器，使用带名字的构造器：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Named constructor</span></span><br><span class=\"line\">  Point.origin() &#123;</span><br><span class=\"line\">    x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用非默认的父类构造器\"><a href=\"#调用非默认的父类构造器\" class=\"headerlink\" title=\"调用非默认的父类构造器 \"></a>调用非默认的父类构造器 <!-- omit in toc --></h4><p>默认情况下，子类的构造器调用父类不带名字和参数的构造器，且在子类构造器的头部调用。如果使用了<a href=\"https://dart.dev/guides/language/language-tour#initializer-list\" target=\"_blank\" rel=\"noopener\">初始化列表</a>，此操作会在父类调用前执行。三者顺序：</p>\n<ol>\n<li>初始化列表</li>\n<li>父类无参构造器</li>\n<li>当前类无参构造器</li>\n</ol>\n<p>如果父类没有无名无参的构造器，必须手动调用父类的一个构造器。在 <code>:</code> 和函数体之间指定父类的构造器。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.fromJson(<span class=\"built_in\">Map</span> data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Person'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Person does not have a default constructor;</span></span><br><span class=\"line\">  <span class=\"comment\">// you must call super.fromJson(data).</span></span><br><span class=\"line\">  Employee.fromJson(<span class=\"built_in\">Map</span> data) : <span class=\"keyword\">super</span>.fromJson(data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Employee'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emp = <span class=\"keyword\">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Prints:</span></span><br><span class=\"line\">  <span class=\"comment\">// in Person</span></span><br><span class=\"line\">  <span class=\"comment\">// in Employee</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (emp <span class=\"keyword\">is</span> Person) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Type check</span></span><br><span class=\"line\">    emp.firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  (emp <span class=\"keyword\">as</span> Person).firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表 \"></a>初始化列表 <!-- omit in toc --></h4><p>除了调用父类构造器外，还可以在构造器函数体之前初始化实例变量。多个初始化之间用逗号分隔：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">num</span>&gt; json) : x = json[<span class=\"string\">'x'</span>], y = json[<span class=\"string\">'y'</span>] &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.fromJson(): ($x, $y)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开发模式下，初始化列表中可使用断言：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.withAssert(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y) : <span class=\"keyword\">assert</span>(x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.withAssert(): ($x, $y)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置 final 字段时，初始化列表较为便利。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> distanceFromOrigin;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(x, y)</span><br><span class=\"line\">      : x = x,</span><br><span class=\"line\">        y = y,</span><br><span class=\"line\">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(p.distanceFromOrigin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重定向构造器\"><a href=\"#重定向构造器\" class=\"headerlink\" title=\"重定向构造器 \"></a>重定向构造器 <!-- omit in toc --></h4><p>部分构造器的作用只是调用当前类的其它构造器。重定向构造器写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Point.alongzXAxis(<span class=\"built_in\">num</span> x) : <span class=\"keyword\">this</span>(x, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常量构造器\"><a href=\"#常量构造器\" class=\"headerlink\" title=\"常量构造器 \"></a>常量构造器 <!-- omit in toc --></h4><p>常量构造器用来表示类生成的实例不会改变。用 <code>const</code> 修饰构造器且全部实例变量使用 <code>final</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常量构造器不一定总是创建常量。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#using-constructors\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h4 id=\"工厂构造器\"><a href=\"#工厂构造器\" class=\"headerlink\" title=\"工厂构造器 \"></a>工厂构造器 <!-- omit in toc --></h4><p>关键字 <code>factory</code> 修饰的构造器表示，此构造器不会每次都创建新的实例。比如，工厂构造器可能返回一个缓存中的实例或者子类的实例。</p>\n<p>工厂构造器写法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用工厂构造器同其他构造器方法一样：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> logger = Logger(<span class=\"string\">'UI'</span>);</span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-6-方法\"><a href=\"#10-6-方法\" class=\"headerlink\" title=\"10.6 方法\"></a>10.6 方法</h3><p>方法是定义在类内部的函数。</p>\n<h4 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法 \"></a>实例方法 <!-- omit in toc --></h4><p>对象的实例方法内部可访问实例变量和 <code>this</code>。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">num</span> distanceTo(Point other) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = x - other.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = y - other.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Getters-amp-setters\"><a href=\"#Getters-amp-setters\" class=\"headerlink\" title=\"Getters &amp; setters \"></a>Getters &amp; setters <!-- omit in toc --></h4><p>Getters 和 setters 是特殊的方法，能读写对象属性。实例变量默认都有 getter，通常也有 setter。也可用 <code>get</code> 和 <code>set</code> 自己实现：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> left, top, width, height;</span><br><span class=\"line\"></span><br><span class=\"line\">  Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Define two calculated properties: right and bottom.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right =&gt; left + width;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) =&gt; left = value - width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom =&gt; top + height;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rect = Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">  rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法 \"></a>抽象方法 <!-- omit in toc --></h4><p>实例方法，getter 和 setter 都能定义为抽象方法，当前类只定义接口，实现交由其它类。抽象方法只能定义在<a href=\"https://dart.dev/guides/language/language-tour#abstract-classes\" target=\"_blank\" rel=\"noopener\">抽象类</a>中。</p>\n<p>定义抽象方法，用分号替代函数体：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> soSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EffectiveDoer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> soSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-7-抽象类\"><a href=\"#10-7-抽象类\" class=\"headerlink\" title=\"10.7 抽象类\"></a>10.7 抽象类</h3><p>关键字 <code>abstract</code> 定义<em>抽象类</em>（不能被实例化）。抽象类多用于接口定义，实现较多的情况。定义<a href=\"https://dart.dev/guides/language/language-tour#factory-constructors\" target=\"_blank\" rel=\"noopener\">工厂构造器</a>可实例化抽象类。</p>\n<p>抽象类通常都有抽象方法，例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This class is declared abstract and thus</span></span><br><span class=\"line\"><span class=\"comment\">// can't be instantiated.</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define constructors, fields, methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> updateChildren(); <span class=\"comment\">// Abstract method.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-8-隐式接口\"><a href=\"#10-8-隐式接口\" class=\"headerlink\" title=\"10.8 隐式接口\"></a>10.8 隐式接口</h3><p>类隐式定义了一个接口列表，包括当前类实现的所有成员变量。类 A 在不继承类 B 的情况下，实现类 B 的接口，从而调用类 B 的成员。</p>\n<p>声明类的时候用 <code>implements</code> 并提供所需的 APIs，从而实现一个或多个接口：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, $who. I am $_name'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi $who. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>))); <span class=\"comment\">// 'Hello, Bob. I am $Kathy'</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(geetBob(Impostor())); <span class=\"comment\">// 'Hi Bob. Do you know who I am?'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个类实现多个接口：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>, <span class=\"title\">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-9-扩展类\"><a href=\"#10-9-扩展类\" class=\"headerlink\" title=\"10.9 扩展类\"></a>10.9 扩展类</h3><p>使用 <code>extends</code> 创建子类，<code>super</code> 指向父类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    _illuminateDisplay();</span><br><span class=\"line\">    _activateIrSensor();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.turnOn();</span><br><span class=\"line\">    _bootNetworkInterface();</span><br><span class=\"line\">    _initializeMemory();</span><br><span class=\"line\">    _upgradeApps();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重写成员\"><a href=\"#重写成员\" class=\"headerlink\" title=\"重写成员 \"></a>重写成员 <!-- omit in toc --></h4><p>子类可重载实例方法、getters 和 setters。<code>@override</code> 关键字表示成员被重载：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可重载运算符\"><a href=\"#可重载运算符\" class=\"headerlink\" title=\"可重载运算符 \"></a>可重载运算符 <!-- omit in toc --></h4><p>下表中运算符支持重载：<br>|       |       |       |       |<br>| :—: | :—: | :—: | :—: |<br>|  <code>&lt;</code>  |  <code>+</code>  |  <code>|</code>  | <code>[]</code>  |<br>|  <code>&gt;</code>  |  <code>/</code>  |  <code>^</code>  | <code>[]=</code> |<br>| <code>&lt;=</code>  | <code>~/</code>  |  <code>&amp;</code>  |  <code>~</code>  |<br>| <code>&gt;=</code>  |  <code>*</code>  | <code>&lt;&lt;</code>  | <code>==</code>  |<br>|  <code>-</code>  |  <code>%</code>  | <code>&gt;&gt;</code>  |       |</p>\n<p>重载 <code>+</code>, <code>-</code> 运算符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> v = Vector(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> w = Vector(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v + w == Vector(<span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v - w == Vector(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"noSuchMethod\"><a href=\"#noSuchMethod\" class=\"headerlink\" title=\"noSuchMethod() \"></a>noSuchMethod() <!-- omit in toc --></h4><p>重载 <code>noSuchMethod()</code> 方法，及时处理调用对象不存在的实例变量和方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Unless you override noSuchMethod, using a</span></span><br><span class=\"line\">  <span class=\"comment\">// non-existent member results in a NoSuchMethodError.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'You tried to use a non-existent member: '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不可调用对象未实现的方法，除非实现以下任意情况：</p>\n<ul>\n<li>消息接受者有静态类型 <code>dynamic</code></li>\n<li>接收器有一个定义未实现方法的静态类型（包括抽象类型），接收器的动态类型有一个noSuchMethod（）实现，它与Object类中的实现不同。</li>\n</ul>\n<h3 id=\"10-10-枚举类型\"><a href=\"#10-10-枚举类型\" class=\"headerlink\" title=\"10.10 枚举类型\"></a>10.10 枚举类型</h3><p>枚举表示固定数量的常量值。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法 \"></a>用法 <!-- omit in toc --></h4><p>使用 <code>enum</code> 关键字声明枚举类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举值有个 <code>index</code> getter，返回该值在枚举声明中的位置，从 0 开始。第一个值为 0，第二个值为 1…</p>\n<p>使用 <code>values</code> 在运行时获取所有枚举值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(colors[<span class=\"number\">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>\n\n<p>枚举在 switch case 中使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aColor = Color.red;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (aColor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.red:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'red'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.green:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'green'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(aColor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举类型的局限性：</p>\n<ul>\n<li>不可子类化，<em>mix in</em>，或实现</li>\n<li>不能显示实例一个枚举类型</li>\n</ul>\n<h3 id=\"10-11-类添加特性\"><a href=\"#10-11-类添加特性\" class=\"headerlink\" title=\"10.11 类添加特性\"></a>10.11 类添加特性</h3><p>Mixins 是一种将类代码共享给其他类的功能。</p>\n<p><code>with</code> 关键字<em>使用</em> mixin 功能。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musician</span> <span class=\"keyword\">extends</span> <span class=\"title\">Performer</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maestro</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span>, <span class=\"title\">Aggressive</span>, <span class=\"title\">Demented</span> </span>&#123;</span><br><span class=\"line\">  Maestro(<span class=\"built_in\">String</span> maestroname) &#123;</span><br><span class=\"line\">    name = maestroName;</span><br><span class=\"line\">    canConduct = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>实现</em> mixin：创建一个 Object 子类，并且不声明构造器。另外，如果不想该类被当作普通的类，用 <code>mixin</code> 关键字代替 <code>class</code>。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin Musical &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canPlayPiano = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canCompose = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canConduct = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> entertainMe() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canPlayPiano) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Playing piano'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (canConduct) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Waving hands'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Humming to self'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要指定只有某些类型可以使用mixin，使用 <code>on</code> 指定所需的超类：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mixin MusicalPerformer on Musician &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-12-类变量和方法\"><a href=\"#10-12-类变量和方法\" class=\"headerlink\" title=\"10.12 类变量和方法\"></a>10.12 类变量和方法</h3><p>使用 <code>static</code> 关键字创建静态变量和方法。静态方法和变量都是面向类型的，实例无法访问。</p>\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法 \"></a>静态方法 <!-- omit in toc --></h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> initialCapacity = <span class=\"number\">16</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Queue.initialCapacity == <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态变量只有在使用时才会被初始化。</p>\n<h4 id=\"静态方法-1\"><a href=\"#静态方法-1\" class=\"headerlink\" title=\"静态方法 \"></a>静态方法 <!-- omit in toc --></h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = a.x - b.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = a.y - b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> distance = Point.distanceBetween(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"number\">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class=\"number\">2.9</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(distance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-泛型\"><a href=\"#11-泛型\" class=\"headerlink\" title=\"11. 泛型\"></a>11. 泛型</h2><p>数组类型声明：<code>List&lt;E&gt;</code>，其中 &lt;…&gt; 将类型标记为<em>泛型</em>，即，类型内部有个形式上的参数。通常的命名规范，泛型参数名字为单字符，如 E, T, S, K 和 V。</p>\n<h3 id=\"11-1-为什么使用泛型\"><a href=\"#11-1-为什么使用泛型\" class=\"headerlink\" title=\"11.1 为什么使用泛型\"></a>11.1 为什么使用泛型</h3><p>泛型要求代码是类型安全的，但是使用泛型有很多好处：</p>\n<ul>\n<li>正确使用泛型使代码结构更好</li>\n<li>减少重复代码</li>\n</ul>\n<p>声明一个只含字符串的数组：<code>List&lt;String&gt;</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\">names.add(<span class=\"number\">42</span>);<span class=\"comment\">//编译报错</span></span><br></pre></td></tr></table></figure>\n\n<p>受益于静态分析的前提下，泛型能为多个类型共享一个接口。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存 Object</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">Object</span> value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缓存 String</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">String</span> value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用泛型</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  T getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, T value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-使用集合字面值\"><a href=\"#11-2-使用集合字面值\" class=\"headerlink\" title=\"11.2 使用集合字面值\"></a>11.2 使用集合字面值</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = &lt;<span class=\"built_in\">String</span>&gt;[<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> uniqueNames = &lt;<span class=\"built_in\">String</span>&gt;&#123;<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pages = &lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"string\">'index.html'</span>: <span class=\"string\">'Homepage'</span>,</span><br><span class=\"line\">  <span class=\"string\">'robots.txt'</span>: <span class=\"string\">'Hints for web robots'</span>,</span><br><span class=\"line\">  <span class=\"string\">'humans.txt'</span>: <span class=\"string\">'We are people, not machines'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-3-使用带参数化类型的构造函数\"><a href=\"#11-3-使用带参数化类型的构造函数\" class=\"headerlink\" title=\"11.3 使用带参数化类型的构造函数\"></a>11.3 使用带参数化类型的构造函数</h3><p>使用构造器时，指定一个或多个类型，类型放在 <code>&lt;&gt;</code> 中间。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nameSet = <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-4-泛型集合\"><a href=\"#11-4-泛型集合\" class=\"headerlink\" title=\"11.4 泛型集合\"></a>11.4 泛型集合</h3><p>Dart 泛型类型是<em>具体化的</em>，这意味着泛型变量在运行时携带类型信息。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(names <span class=\"keyword\">is</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-5-泛型约束\"><a href=\"#11-5-泛型约束\" class=\"headerlink\" title=\"11.5 泛型约束\"></a>11.5 泛型约束</h3><p>当定义泛型，可使用 <code>extends</code> 约束泛型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> toString() =&gt; <span class=\"string\">\"Instance of 'Foo&lt;$T&gt;'\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extender</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class=\"line\"><span class=\"keyword\">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>不指定泛型参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo();</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo); <span class=\"comment\">// Instance of 'Foo&lt;SomeBaseClass&gt;'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-6-使用泛型方法\"><a href=\"#11-6-使用泛型方法\" class=\"headerlink\" title=\"11.6 使用泛型方法\"></a>11.6 使用泛型方法</h3><p>Dart 支持泛型方法或函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first&lt;T&gt;(<span class=\"built_in\">List</span>&lt;T&gt; ts) &#123;</span><br><span class=\"line\">  T tmp = ts[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码展示了函数泛型参数可使用的位置：</p>\n<ul>\n<li>函数返回值</li>\n<li>函数参数</li>\n<li>内部布局变量</li>\n</ul>\n<h2 id=\"12-库\"><a href=\"#12-库\" class=\"headerlink\" title=\"12. 库\"></a>12. 库</h2><p>使用 <code>import</code> 和 <code>library</code> 指令创建模块化和可共享的代码。库不仅提供 APIs，还是私有的作用域块：下划线开头的标识符仅在库内部可见。每个 Dart 应用都是一个库，即使并不使用 <code>library</code> 指令。</p>\n<p>库可作为包(package)发布。</p>\n<h3 id=\"12-1-使用库\"><a href=\"#12-1-使用库\" class=\"headerlink\" title=\"12.1 使用库\"></a>12.1 使用库</h3><p>使用 <code>import</code>，在一个库中指定另一个库的命名空间。</p>\n<p>举个例子，Dart 网页应用通常使用 <code>dart:html</code> 库，可以如下导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:html'</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>import</code> 指令后面的参数是指向目标库的 URI。对于 Dart 自带的库，使用 <code>dart:</code> 作为 sheme。其他库，使用文件路径或 <code>package:</code> scheme。包管理工具提供的库使用 <code>package:</code> scheme。比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"指定库前缀\"><a href=\"#指定库前缀\" class=\"headerlink\" title=\"指定库前缀 \"></a>指定库前缀 <!-- omit in toc --></h4><p>当引入的两个库有冲突的标识符，可以为两个库指定前缀，从而避免冲突。例子如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> <span class=\"keyword\">as</span> lib2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Element</span> element1 = <span class=\"built_in\">Element</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">lib2.<span class=\"built_in\">Element</span> element2 = lib2.<span class=\"built_in\">Element</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导入库的部分接口\"><a href=\"#导入库的部分接口\" class=\"headerlink\" title=\"导入库的部分接口 \"></a>导入库的部分接口 <!-- omit in toc --></h4><p>Dart 支持导入库的部分功能，比如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"库懒加载\"><a href=\"#库懒加载\" class=\"headerlink\" title=\"库懒加载 \"></a>库懒加载 <!-- omit in toc --></h4><p>库的按需加载。以下场景可以使用库按需加载：</p>\n<ul>\n<li>加快应用启动时间</li>\n<li>A/B test</li>\n<li>加载较少使用的库</li>\n</ul>\n<p>实现懒加载，首先要用 <code>deferred as</code> 导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:greetings/hello.dart'</span> deferred <span class=\"keyword\">as</span> hello;</span><br></pre></td></tr></table></figure>\n\n<p>需要使用的地方，用库的标识调用 <code>loadLibrary()</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future greet() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，<code>await</code> 关键字会阻塞代码直到库加载完成。更多信息查看<a href=\"https://dart.dev/guides/language/language-tour#asynchrony-support\" target=\"_blank\" rel=\"noopener\">异步操作</a>。</p>\n<p>多次调用 <code>loadLibrary()</code> 加载同一个库不会出错，且库只会被加载一次。</p>\n<p>使用库的懒加载时，记住以下几点：</p>\n<ul>\n<li>懒加载的库中的常量，只有在懒加载完成后才能作为常量使用</li>\n<li>不能使用懒加载库中的类型。而应该将接口类型放到第三方库中，让目标库和当前文件共同导入第三方库</li>\n<li>开发者用 <code>deferred as namespace</code> 定义懒加载库的命名空间，Dart 在命名空间后面隐式插入 <code>loadLibrary()</code>。<code>loadLibrary()</code> 返回 <em>Future</em>。</li>\n</ul>\n<h3 id=\"12-2-实现库\"><a href=\"#12-2-实现库\" class=\"headerlink\" title=\"12.2 实现库\"></a>12.2 实现库</h3><p>实现一个库，请查看 <a href=\"https://dart.dev/guides/libraries/create-library-packages\" target=\"_blank\" rel=\"noopener\">Create Library Package</a>：</p>\n<ul>\n<li>如何组织库的源码</li>\n<li>如何使用 <code>export</code> 指令</li>\n<li>何时使用 <code>part</code> 指令</li>\n<li>何时使用 <code>library</code> 指令</li>\n</ul>\n<h2 id=\"13-异步\"><a href=\"#13-异步\" class=\"headerlink\" title=\"13. 异步\"></a>13. 异步</h2><p>Dart 库中有很多返回值为 <code>Future</code> 和 <code>Stream</code> 的函数。这些函数是异步函数：派发一个耗时任务后直接返回，并不等待任务完成。</p>\n<p><code>async</code> 和 <code>await</code> 关键字实现异步编程，让异步任务像同步的代码顺序执行。</p>\n<h3 id=\"13-1-处理-Future\"><a href=\"#13-1-处理-Future\" class=\"headerlink\" title=\"13.1 处理 Future\"></a>13.1 处理 Future</h3><p>两种方式处理 Future：</p>\n<ul>\n<li>使用 <code>async</code> 和 <code>await</code></li>\n<li>使用 Future API，查看 <a href=\"https://dart.dev/guides/libraries/library-tour#future\" target=\"_blank\" rel=\"noopener\">the library tour</a></li>\n</ul>\n<p><code>async</code> 和 <code>await</code> 使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>await</code> 的代码，必须要写在 <em>async</em> 函数内：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future checkVersion() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>try</code>, <code>catch</code> 和 <code>finally</code> 用于处理 <code>await</code> 代码中的错误并执行清理代码：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个异步函数中，可使用多个 <code>await</code>，下述代码中，使用了三个 await 处理任务：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entrypoint = <span class=\"keyword\">await</span> findEntrypoint();</span><br><span class=\"line\"><span class=\"keyword\">var</span> exitCode = <span class=\"keyword\">await</span> runExecutable(entrypoint, args);</span><br><span class=\"line\"><span class=\"keyword\">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>await expr</code> 中，<code>expr</code> 的值通常是 Future，如果不是，系统会自动用 Future 包装。该 Future 对象表示一个会返回对象的 promise。<code>await expr</code> 的值就是最终返回的对象。Await 表达式会阻塞代码直到返回最终的对象。</p>\n<p><strong>使用 <code>await</code> 的时候报了编译错误，确保 <code>await</code> 实在异步函数中。</strong> 比如，想在 <code>main()</code> 函数中使用 <code>await</code>，那么函数体必须标记为 <code>async</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  checkVersion();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In main: version is <span class=\"subst\">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-声明异步函数\"><a href=\"#13-2-声明异步函数\" class=\"headerlink\" title=\"13.2 声明异步函数\"></a>13.2 声明异步函数</h3><p>异步函数的函数体用 <code>async</code> 标记。</p>\n<p>为函数添加 <code>async</code> 关键字，使得函数返回 Future。如下例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> lookUpVersion() =&gt; <span class=\"string\">'1.0.0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; lookUpVersion() <span class=\"keyword\">async</span> =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码可知，Dart 自动用 Future 包装返回值。</p>\n<p>如果函数没有实际返回值，就返回 <code>Future&lt;void&gt;</code>。</p>\n<h3 id=\"13-3-处理流\"><a href=\"#13-3-处理流\" class=\"headerlink\" title=\"13.3 处理流\"></a>13.3 处理流</h3><p>两种方式从流(Stream)中获取值：</p>\n<ul>\n<li>用 <code>async</code> 和 <em>asynchronous for loop</em>(<code>await for</code>)</li>\n<li>使用 <a href=\"https://dart.dev/guides/libraries/library-tour#stream\" target=\"_blank\" rel=\"noopener\">Stream API</a></li>\n</ul>\n<p>异步循环格式：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (varOrType identifier <span class=\"keyword\">in</span> expression) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，<code>expression</code> 必须是 Stream 类型。代码执行顺序：</p>\n<ol>\n<li>等待流释放一个值</li>\n<li>变量被赋值为 (1) 释放的值，并执行循环体</li>\n<li>重复步骤(1), (2)，直到流被关闭</li>\n</ol>\n<p>使用 <code>break</code> 或 <code>return</code> 停止监听流，执行命令后会跳出循环并对流取消订阅</p>\n<p><strong>当实现一个异步循环的时候，报编译错误，确保 <code>await for</code> 代码实在异步函数中。</strong> 比如，在 <code>main()</code> 函数中使用异步循环，将 <code>main()</code> 函数体标记为 <code>async</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> request <span class=\"keyword\">in</span> requestServer) &#123;</span><br><span class=\"line\">    handleRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更多异步编程信息，查看 <a href=\"https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming\" target=\"_blank\" rel=\"noopener\"><em>dart:async</em></a>。</p>\n<h2 id=\"14-生成器\"><a href=\"#14-生成器\" class=\"headerlink\" title=\"14. 生成器\"></a>14. 生成器</h2><p>用 <em>生成器函数</em> 惰性生成一些列值。Dart 自带两种生成器：</p>\n<ul>\n<li><strong>Synchronous</strong> 生成器：返回一个 <a href=\"https://api.dart.dev/stable/dart-core/Iterable-class.html\" target=\"_blank\" rel=\"noopener\"><em>Iterable</em></a> 对象</li>\n<li><strong>Asynchronous</strong> 生成器：返回一个 <a href=\"https://api.dart.dev/stable/dart-async/Stream-class.html\" target=\"_blank\" rel=\"noopener\"><em>Stream</em></a> 对象</li>\n</ul>\n<p>实现 <strong>synchronous</strong> 生成器函数方法：用 <code>sync*</code> 标记函数体，并用 <code>yield</code> 语句发送值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;Int&gt; naturalTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现 <strong>asynchronous</strong> 生成器函数方法：用 <code>async*</code> 标记函数体，并用 <code>yield</code> 发送值：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Int&gt; asynchronousNaturalTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归生成器，用 <code>yield*</code> 改进性能：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;Int&gt; naturalsDownFrom(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* naturalsDownFrom(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-可调用的类\"><a href=\"#15-可调用的类\" class=\"headerlink\" title=\"15. 可调用的类\"></a>15. 可调用的类</h2><p>类实现 <code>call()</code> 方法后，该类的实例可以像函数一样被调用。</p>\n<p>如下例子，<code>WannabeFunction</code> 类实现了 call() 函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'$a $b $c!'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">'Hi'</span>, <span class=\"string\">'there'</span>, <span class=\"string\">'gang'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(out);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-独立性\"><a href=\"#16-独立性\" class=\"headerlink\" title=\"16. 独立性\"></a>16. 独立性</h2><p>多数计算机包括手机都有多核 CPU。开发者通常用共享内存的线程并发执行程序，以提高 CPU 利用率。然而，共享状态的并发执行更易出错，也使得代码更加复杂。</p>\n<p>Dart 用 <em>isolate</em> 替代线程。每个 isolate 有自己的堆内存，以确保 isolates 之间不会共享状态。</p>\n<p>更多信息查看 <a href=\"https://api.dart.dev/stable/dart-isolate\" target=\"_blank\" rel=\"noopener\">dart:isolate library document</a>。</p>\n<h2 id=\"17-类型定义\"><a href=\"#17-类型定义\" class=\"headerlink\" title=\"17. 类型定义\"></a>17. 类型定义</h2><p>Dart 中，函数同字符串和数值一样都是对象。<em>Typedef</em> 或者说 <em>funtion-type alias</em> 给函数定义个名字，在其它地方使用。类型定义会保留类型信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"built_in\">Function</span> f) &#123;</span><br><span class=\"line\">    compare = f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用类型定义后：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  Compare compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"keyword\">this</span>.compare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">main &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(coll.compare <span class=\"keyword\">is</span> Compare); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型定义结合泛型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare&lt;T&gt; = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(T a, Tb);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">main &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(sort <span class=\"keyword\">is</span> Compare&lt;Int&gt;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"18-元数据\"><a href=\"#18-元数据\" class=\"headerlink\" title=\"18. 元数据\"></a>18. 元数据</h2><p>元数据标注写法：<code>@</code> 开头，后跟着编译期常量或者常量构造器。</p>\n<p>Dart 中两种标注对所有代码使用: <code>@deprecated</code> 和 <code>override</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> activate &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义元数据标注：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> who;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> what;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Todo(<span class=\"keyword\">this</span>.who, <span class=\"keyword\">this</span>.what);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用自定义的元数据：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'todo.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Todo</span>(<span class=\"string\">'seth'</span>, <span class=\"string\">'make this do something'</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元数据可以出现在以下指令前：库，类，类型定义，类型参数，构造器，工厂方法，字段，参数，变量声明，导入导出。运行时可通过 reflection 获取元数据。</p>\n<h2 id=\"19-注释\"><a href=\"#19-注释\" class=\"headerlink\" title=\"19. 注释\"></a>19. 注释</h2><p>Dart 支持单行、多行和文档注释。</p>\n<h2 id=\"20-小结\"><a href=\"#20-小结\" class=\"headerlink\" title=\"20. 小结\"></a>20. 小结</h2><p>此文档摘录了 Dart 中较为通用的特性。此外，更多新特性正在开发，尽量兼容当前代码。下一步：<a href=\"https://dart.dev/guides/language/spec\" target=\"_blank\" rel=\"noopener\">language specification</a> 和 <a href=\"https://dart.dev/guides/language/effective-dart\" target=\"_blank\" rel=\"noopener\">Effective Dart</a>。</p>\n<p>了解更多关于 Dart 核心库，查看 <a href=\"https://dart.dev/guides/libraries/library-tour\" target=\"_blank\" rel=\"noopener\">A Tour of the Dart Libraries</a>。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjyhubj9k0000g4xpv25we6zx","tag_id":"cjyhubjak0001g4xpz901t42l","_id":"cjyhubjao0003g4xpfz028jt4"},{"post_id":"cjyhubj9k0000g4xpv25we6zx","tag_id":"cjyhubjao0002g4xp5ypr7c1n","_id":"cjyhubjao0004g4xpoqynzghh"}],"Tag":[{"name":"dart","_id":"cjyhubjak0001g4xpz901t42l"},{"name":"flutter","_id":"cjyhubjao0002g4xp5ypr7c1n"}]}}