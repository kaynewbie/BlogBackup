# 并发编程指南

为了提高 `CPU` 计算能力，增加芯片核心数，为了让应用更充分利用 `CPU`，应用使用多线程


## 操作队列

*	NSOperation 基类

通常要加到操作队列中执行(操作队列并不是直接执行，而是由其他线程执行或者通过 `GCD` );
如果不加到操作队列，可以直接调用 `start`。手动执行操作会让代码负担更重，因为一个没有就绪的操作调用 `start` 就会发出异常。
<!-- more -->

**依赖**		
设置依赖是一个很方便的确定操作执行顺序的方法。`addDependency:`,`removeDependency:`。只有依赖执行完了，这个操作才能进入就绪状态。	
不管依赖是否执行成功，对原来的操作无影响。一个操作的依赖被取消或者执行失败，
由你来决定是否执行这个操作，这需要你让操作结合一些错误追踪的能力。

**键值观察属性**		
isCancelled - read-only		
isAsynchronous - read-only	
isExecuting - read-only		
isFinished - read-only		
isReady - read-only		
dependencies - read-only	
queuePriority - readable and writable	
completionBlock - readable and writable		
虽然可以讲观察者绑定在这些属性，但不应该和**视图**元素绑定，因为关于视图的代码要在**主线程**执行，操作可以在任何线程执行，和这些操作绑定的 `KVO` 通知也会在任何线程执行。

**多线程注意**		
`NSOperation` 子类，实现一些 `accessors`，要注意线程同步。

**异步VS同步**

**方法重写**
不并发的操作，只需要重写 `main`，可能有数据，如果实现了`settter`, `getter`，要保证线程安全;并发的操作，至少实现这些方法或属性 `start`, `asynchronous`, `executing`, `finished`。
`start`负责让操作在异步方式运行,开线程或调用异步函数，并且更新执行状态;通过 `executing` 属性报告,通过发送通知，让感兴趣的知道，这个属性需要线程安全;

**cancel命令**	
`cancel` 不会立即强行停止操作。所有的操作都认可 `cancelled` 属性，你可以在代码中判断。**NOTE**:一个线程是否被加入到队列中决定了 `cancel` 的行为。未加入，这个方法会将操作标记成**已完成**；已加入，将操作标记成**就绪**，并立刻调 `start`,然后退出，操作从队列中清楚。	
主要代码要周期性地检查 `cancelled` 属性。实现 `start` 方法，应该早点检查是否取消然后再决定怎么做。	

**执行operation**		
`start`: 更新执行状态，并调用 `main`；手动执行操作才调用这个方法。	
`main`: 实现这个方法，不要调 `super`。自动执行在 `NSOperation` 提供的自动释放池，所以不需要手动创建。并发操作不需要实现这个方法。		
`cancel`: 这个方法会更新状态，但不会强制停止你的操作。如果已经执行结束，不会有影响。如果一些已经添加到队列，但还没执行操作，可以将其更快地移出队列。
如果操作已经加入队列，并且等待其他依赖操作完成时，这些操作之后会被忽略。队列会很快调用这个操作的 `start`，并将它移出队列。

*	NSBlockOperation	

一个对象可以管理一个或多个代码块。当管理多个代码块时，只有所有代码块完成，这个操作才会完成。	
添加了代码块的操作是按默认优先级添加到队列中。这些代码块本身不会获得任何执行环境的配置。		
操作正在执行或已经执行结束的时候调用`addExecutionBlock:`会抛出异常。

初始化至少添加一个代码块。当要执行一个`NSBlockOperation`时，他会将所有的代码块按照默认优先级提交到并行分发队列。这个操作是在一个单独线程中执行，

*	NSInvocationOperation

管理一个方法封装的单个任务。这个类实习了一个非并发的操作。

```
- (instancetype)initWithTarget:(id)target
                      selector:(SEL)sel
                        object:(id)arg   
sel:可以有0或1个参数。如果有参数，参数类型必须是 `id`；返回值可以是 `void`，纯量值或者 `id`。操作执行结束后，可以在 `result` 中访问返回值。
                  
```

`- (instancetype)initWithInvocation:(NSInvocation *)inv`, `inv` 会对他的参数引用计数加一。
可以通过查看 `result` 属性，看是否有异常。

使用情况：你调用的方法会根据环境改变。例如，根据用户的动态输入选择方法执行。


**自定义操作**	
自定义非并行操作只需要响应`主任务`和`取消`；并行操作则需要重写更多代码。

---	
无论什么操作，都要在创建之后，添加到队列中之前，进行配置。	
多个依赖不能在同一个队列中运算。两个操作不能相互设置为对方的依赖。	
**优先级**	
添加到队列中的操作的执行顺序，**首先**是根据操作的就绪状态；**然后**是根据优先级。	
通过 `setQueuePriority:` 改变优先级。	
优先级只使用在同一队列中的操作。不同队列确定各自的优先级，所以这就会出现不同队列，低优先级的操作比高优先级的先执行。	

如果你想要拿到执行完的结果，需要对操作保持引用，因为你没有机会再从队列中获取。队列会迅速执行完操作，然后将其移除。

**执行**	
通常队列都会很快执行加入队列的操作，但有几个原因会导致延迟执行加入队列的操作。1.操作依赖还未执行完成的操作；2.队列被挂起或者已经执行最大数量的操作。

** 重要 **		
不要修改已经添加到队列中的操作。因为操作在队列中等待的时候，它可能随时会被执行，修改配置可能会产生不好的影响。

虽然队列是为了并发执行设计的，但是它也可以强制队列一个时间只执行一个操作(`setMaxConcurrentOperationCount:`)。虽然可以达到串行的效果，但是执行顺序还是根据就绪状态和优先级决定的。所以，这个串行表现比不上 `GCD` 中的串行队列。如果你对顺序由要求，那你应该在操作进入队列前，设置依赖。

** 手动执行 **	
手动执行要确保操作处于就绪状态，并且调用 `start`。`start` 会多次检查状态。如果你的操作被取消或者没有处于就绪状态而抛出异常，它就会避免执行。	
如果定义了一个并发的操作，应该最开始判断 `isConcurrent`，如果返回 `NO`，确保能决定是否重开一条线程。


## 分发队列

## 分发源